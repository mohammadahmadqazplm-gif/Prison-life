-- =============================================
-- Update: PC Bug Fixes
-- [Fix 1] Anti-death ÿπŸÜÿØ ÿßŸÑÿ™ŸäŸÑŸäÿ®Ÿàÿ±ÿ™: PC + Mobile
--         (SetStateEnabled Dead + Died event hook)
-- [Fix 2] ÿßŸÑÿØÿ±ÿπ ŸäÿÆÿ™ŸÅŸä ÿ®ÿπÿØ 5 ÿ´ŸàÿßŸÜŸä ÿ´ÿßÿ®ÿ™
--         (teleport + gun) - ŸÑÿß Ÿäÿ™ÿ∫Ÿäÿ± ÿ£ÿ®ÿØÿßŸã
-- =============================================

pcall(function()
    loadstring(game:HttpGet('https://raw.githubusercontent.com/14ms-alt/Roblox-Scripts/main/CS%20Prison%20Life%20AntiCheat%20Bypass.lua'))()
end)
task.wait(0.5)

pcall(function()
    local _OldNewIndex
    _OldNewIndex = hookmetamethod(game, "__newindex", function(self, property, value)
        if not checkcaller() then
            local name = tostring(self)
            if (name == "Head" or name == "Torso") and property == "CanCollide" then
                return
            end
        end
        return _OldNewIndex(self, property, value)
    end)
end)

FORCEFIELD_MODE = "SMART"

local earlyNotification = function(title, msg, dur)
    pcall(function()
        game:GetService("StarterGui"):SetCore("SendNotification", {
            Title = title,
            Text = msg,
            Duration = dur or 3
        })
    end)
end

local REMOTE_WHITELIST = {

    "switchteam", "switch_team", "changeteam", "change_team",
    "setteam",    "set_team",    "teamswitch",  "teamchange",
    "selectteam", "chooseteam",  "jointeam",    "team",

    "requestteamchange", "requestteam", "request_team",
    "pickteam", "pick_team", "spawnplayer",
    "spawn",      "respawn",     "requestspawn", "spawnplayer",
    "selectspawn", "choosespawn", "setspawn",
    "spawnrequest", "charspawn", "loadchar", "reloadchar",

    "shoot",      "fire",        "damage",      "hit",
    "reload",     "equipgun",    "unequipgun",  "pickup",
    "buy",        "purchase",    "interact",

    "animation",  "chat",        "message",
}

local function isWhitelisted(name)
    if not name then return false end
    local lower = tostring(name):lower()
    for _, w in ipairs(REMOTE_WHITELIST) do
        if lower:find(w, 1, true) then
            return true
        end
    end
    return false
end

local function smartNotify(title, content, duration)
    pcall(function()

        local success = pcall(function()
            if _G.Rayfield and _G.Rayfield.Notify then
                _G.Rayfield:Notify({
                    Title = title,
                    Content = content,
                    Duration = duration or 2,
                    Image = 4483362458
                })
                return true
            end
        end)

        if not success then
            earlyNotification(title, content, duration)
        end
    end)
end

local PositionCryptor = {
    enabled = true,
    keys = {},
    currentKeyIndex = 1,
    keyRotationInterval = 15,
    encryptionLayers = 4,
    noiseLevel = 0.02,

    generateKeys = function(self)
        for i = 1, 12 do
            self.keys[i] = {
                seed = math.random(1000000, 9999999),
                multiplier = math.random(100, 999),
                offset = Vector3.new(
                    math.random(-150, 150) / 1000,
                    math.random(-150, 150) / 1000,
                    math.random(-150, 150) / 1000
                ),
                rotation = math.random(1, 360),
                phase = math.random(1, 100)
            }
        end
    end,

    encrypt = function(self, position)
        if not self.enabled then return position end
        local key = self.keys[self.currentKeyIndex]
        if not key then return position end

        local encrypted = position + key.offset

        for layer = 1, self.encryptionLayers do
            local layerKey = self.keys[(self.currentKeyIndex + layer - 1) % #self.keys + 1]
            local noise = self.noiseLevel * layer
            encrypted = Vector3.new(
                encrypted.X + math.sin((layerKey.seed + layer * 1000 + layerKey.phase) / 1000) * noise,
                encrypted.Y + math.sin((layerKey.seed + layer * 2000 + layerKey.phase) / 2000) * (noise * 0.5),
                encrypted.Z + math.cos((layerKey.seed + layer * 1000 + layerKey.phase) / 1000) * noise
            )
        end

        local rotationAngle = math.rad(key.rotation / 360)
        local rotatedX = encrypted.X * math.cos(rotationAngle) - encrypted.Z * math.sin(rotationAngle)
        local rotatedZ = encrypted.X * math.sin(rotationAngle) + encrypted.Z * math.cos(rotationAngle)

        return Vector3.new(rotatedX, encrypted.Y, rotatedZ)
    end,

    rotateKey = function(self)
        self.currentKeyIndex = (self.currentKeyIndex % #self.keys) + 1
    end
}

PositionCryptor:generateKeys()
task.spawn(function()
    while task.wait(PositionCryptor.keyRotationInterval) do
        PositionCryptor:rotateKey()
    end
end)

local TeleportValidator = {
    enabled = true,
    baseCooldown = 10,
    extendedCooldown = 60,
    groupSize = 4,
    _count = 0,
    _cooldownUntil = 0,
    _isExtended = false,
    _lastNotifTime = 0,
    _locked = false,

    canTeleport = function(self)
        if not self.enabled then return true end
        local now = tick()

        if self._locked or now < self._cooldownUntil then
            if now - self._lastNotifTime >= 2 then
                self._lastNotifTime = now
                local left = math.ceil(self._cooldownUntil - now)
                local label = self._isExtended
                    and ("‚è≥ Long CD: " .. left .. "s")
                    or  ("‚è± CD: " .. math.max(left, 1) .. "s")
                smartNotify("Teleport Cooldown", label .. " remaining", 2)
            end
            return false
        end

        self._locked = true
        return true
    end,

    recordTeleport = function(self)
        local now = tick()
        self._count = self._count + 1
        local isLong = (self._count % self.groupSize == 0)
        local cd = isLong and self.extendedCooldown or self.baseCooldown
        self._cooldownUntil = now + cd
        self._isExtended = isLong
        self._locked = false

        local tpsLeft = self.groupSize - (self._count % self.groupSize)
        if tpsLeft == self.groupSize then tpsLeft = 0 end
        local info
        if isLong then
            info = "‚è≥ Long CD: " .. self.extendedCooldown .. "s ‚Äî ÿ±ŸäŸëÿ≠ ÿ¥ŸàŸä!"
        else
            info = "‚è± CD: " .. self.baseCooldown .. "s | " .. tpsLeft .. " TPs to long CD"
        end
        smartNotify("TP #" .. self._count, info, 2)
    end,

    failTeleport = function(self)
        self._locked = false
    end,

    getStatus = function(self)
        local now = tick()
        local left = math.max(0, self._cooldownUntil - now)
        local tpsLeft = self.groupSize - (self._count % self.groupSize)
        if tpsLeft == self.groupSize then tpsLeft = 0 end
        return {
            count = self._count,
            ready = (not self._locked) and left == 0,
            secondsLeft = math.ceil(left),
            isExtended = self._isExtended,
            tpsUntilLong = tpsLeft
        }
    end,

    reset = function(self)
        self._count = 0
        self._cooldownUntil = 0
        self._isExtended = false
        self._locked = false
        self._lastNotifTime = 0
    end
}

local TeleportDistanceValidator = {
    enabled = true,
    lastPosition = nil,
    maxSafeDistance = 400,
    longTpCount = 0,
    longTpDecayTime = 0,

    validateDistance = function(self, newPosition)
        if not self.enabled or not self.lastPosition then
            self.lastPosition = newPosition
            return true
        end
        local distance = (newPosition - self.lastPosition).Magnitude
        self.lastPosition = newPosition

        if tick() - self.longTpDecayTime > 30 then
            self.longTpCount = 0
        end

        if distance > self.maxSafeDistance then
            self.longTpCount = self.longTpCount + 1
            self.longTpDecayTime = tick()

            if self.longTpCount >= 2 then
                local extra = math.random(15, 25)
                TeleportValidator._cooldownUntil = math.max(
                    TeleportValidator._cooldownUntil,
                    tick() + extra
                )
                smartNotify("Long Distance", "Extra CD: " .. extra .. "s", 2)
            end
        end
        return true
    end,

    reset = function(self)
        self.lastPosition = nil
        self.longTpCount = 0
        self.longTpDecayTime = 0
    end
}

task.spawn(function()
    while task.wait(10) do

    end
end)

local CharacterModes = {
    Headless = {
        enabled = false,
        originalHead = nil,

        toggle = function(self, enabled)
            self.enabled = enabled
            local player = game.Players.LocalPlayer
            local char = player.Character

            if not char then return end

            if enabled then
                local head = char:FindFirstChild("Head")
                if head then
                    self.originalHead = {
                        Transparency = head.Transparency,
                        Size = head.Size
                    }

                    head.Transparency = 1

                    for _, child in pairs(head:GetChildren()) do
                        if child:IsA("Decal") or child:IsA("Texture") then
                            child.Transparency = 1
                        end
                    end

                    for _, accessory in pairs(char:GetChildren()) do
                        if accessory:IsA("Accessory") then
                            local handle = accessory:FindFirstChild("Handle")
                            if handle then
                                local attachment = handle:FindFirstChild("FaceFrontAttachment")
                                    or handle:FindFirstChild("HatAttachment")
                                    or handle:FindFirstChild("FaceCenterAttachment")
                                if attachment then
                                    handle.Transparency = 1
                                end
                            end
                        end
                    end

                end
            else
                local head = char:FindFirstChild("Head")
                if head and self.originalHead then
                    head.Transparency = self.originalHead.Transparency

                    for _, child in pairs(head:GetChildren()) do
                        if child:IsA("Decal") or child:IsA("Texture") then
                            child.Transparency = 0
                        end
                    end

                    for _, accessory in pairs(char:GetChildren()) do
                        if accessory:IsA("Accessory") then
                            local handle = accessory:FindFirstChild("Handle")
                            if handle then
                                handle.Transparency = 0
                            end
                        end
                    end

                end
            end
        end
    },

    Kroblox = {
        enabled = false,
        originalLimbs = {},

        toggle = function(self, enabled)
            self.enabled = enabled
            local player = game.Players.LocalPlayer
            local char = player.Character

            if not char then
                print("[‚ùå] Character not found!")
                return
            end

            if enabled then

                local limbs = {
                    "Right Leg",
                    "RightUpperLeg",
                    "RightLowerLeg",
                    "RightFoot"
                }

                for _, limbName in pairs(limbs) do
                    local limb = char:FindFirstChild(limbName)
                    if limb and limb:IsA("BasePart") then

                        self.originalLimbs[limbName] = limb.Transparency

                        limb.Transparency = 1
                    end
                end

            else

                for limbName, originalTransparency in pairs(self.originalLimbs) do
                    local limb = char:FindFirstChild(limbName)
                    if limb and limb:IsA("BasePart") then
                        limb.Transparency = originalTransparency
                    end
                end

                self.originalLimbs = {}
            end
        end
    }
}

game.Players.LocalPlayer.CharacterAdded:Connect(function(char)
    task.wait(1)

    if CharacterModes.Headless.enabled then
        CharacterModes.Headless:toggle(true)
    end

    if CharacterModes.Kroblox.enabled then
        CharacterModes.Kroblox:toggle(true)
    end
end)

local AntiLogging = {
    enabled = true,
    originalFunctions = {},
    blockedLogs = 0,
    maskedEvents = 0,

    init = function(self)

        self.originalFunctions.warn = warn
        self.originalFunctions.print = print
        self.originalFunctions.error = error

        local function filterLog(...)
            local args = {...}
            local message = table.concat(args, " ")

            local blockedKeywords = {
                "teleport", "tp", "speed", "hack", "exploit",
                "cheat", "suspicious", "detection", "flag",
                "warning", "violation", "banned", "kick",
                "position", "cframe", "velocity", "unusual"
            }

            for _, keyword in ipairs(blockedKeywords) do
                if string.lower(message):find(keyword) then
                    self.blockedLogs = self.blockedLogs + 1
                    return
                end
            end

            return self.originalFunctions.print(...)
        end

        getgenv().warn = filterLog
        getgenv().print = filterLog
    end,

    hideRemoteEvents = function(self)
        local mt = getrawmetatable(game)
        local oldNamecall = mt.__namecall
        setreadonly(mt, false)

        mt.__namecall = newcclosure(function(...)
            local args = {...}
            local method = getnamecallmethod()

            if method == "FireServer" or method == "InvokeServer" then
                local remoteSelf = args[1]

                if remoteSelf and remoteSelf.Name and isWhitelisted(remoteSelf.Name) then
                    return oldNamecall(...)
                end

                local eventName = tostring(remoteSelf and remoteSelf.Name or "")

                local blockedEvents = {
                    "LogPlayerAction",
                    "ReportSuspiciousActivity",
                    "TrackMovement",
                    "LogTeleport",
                    "AntiCheatReport",
                    "FlagPlayer"
                }

                for _, blocked in ipairs(blockedEvents) do
                    if eventName:find(blocked) then
                        self.maskedEvents = self.maskedEvents + 1
                        return
                    end
                end
            end

            return oldNamecall(...)
        end)

        setreadonly(mt, true)
    end,

    clearConsoleLogs = function(self)
        pcall(function()
            game:GetService("LogService"):ClearOutput()
        end)
    end,

    disableAnalytics = function(self)
        pcall(function()

            if game:GetService("AnalyticsService") then
                game:GetService("AnalyticsService").Enabled = false
            end

            if game:GetService("Stats") then
                for _, stat in pairs(game:GetService("Stats"):GetChildren()) do
                    pcall(function()
                        stat:Destroy()
                    end)
                end
            end
        end)
    end,

    obfuscateNetworkData = function(self)

        task.spawn(function()
            while self.enabled do
                pcall(function()

                    game:GetService("ReplicatedStorage"):WaitForChild("DummyEvent", 0.1)
                end)
                task.wait(math.random(5, 15))
            end
        end)
    end
}

pcall(function() AntiLogging:init() end)
pcall(function() AntiLogging:hideRemoteEvents() end)
pcall(function() AntiLogging:disableAnalytics() end)
pcall(function() AntiLogging:clearConsoleLogs() end)
pcall(function() AntiLogging:obfuscateNetworkData() end)

local ServerDetectionBlocker = {
    enabled = true,
    spoofedData = {},

    spoofPlayerData = function(self)
        local player = game.Players.LocalPlayer
        if not player then return end

        task.spawn(function()
            while self.enabled do
                pcall(function()
                    local char = player.Character
                    if char and char:FindFirstChild("HumanoidRootPart") then

                        local hrp = char.HumanoidRootPart
                        local originalPos = hrp.Position

                        self.spoofedData.realPosition = originalPos
                        self.spoofedData.lastUpdate = tick()
                    end
                end)
                task.wait(0.1)
            end
        end)
    end,

    blockServerDataCollection = function(self)

    end,

    hideSpeedChanges = function(self)
        task.spawn(function()
            while self.enabled do
                pcall(function()
                    local player = game.Players.LocalPlayer
                    local char = player.Character
                    if char then
                        local humanoid = char:FindFirstChildOfClass("Humanoid")
                        if humanoid then

                            local currentSpeed = humanoid.WalkSpeed
                            if currentSpeed > 16 then

                                humanoid.WalkSpeed = currentSpeed + math.random(-2, 2) / 10
                            end
                        end
                    end
                end)
                task.wait(0.5)
            end
        end)
    end
}

ServerDetectionBlocker:spoofPlayerData()
ServerDetectionBlocker:blockServerDataCollection()
ServerDetectionBlocker:hideSpeedChanges()
print("[üîí] Data Spoofing: Active | Collection Blocked: Yes")

local NetworkObfuscator = {
    enabled = true,
    dummyTraffic = 0,

    generateDummyTraffic = function(self)
        task.spawn(function()
            while self.enabled do
                pcall(function()

                    for i = 1, math.random(2, 5) do
                        game:GetService("HttpService"):JSONEncode({
                            dummy = math.random(1000, 9999),
                            timestamp = tick(),
                            random = game:GetService("HttpService"):GenerateGUID(false)
                        })
                        self.dummyTraffic = self.dummyTraffic + 1
                    end
                end)
                task.wait(math.random(10, 30))
            end
        end)
    end,

    encryptOutgoingData = function(self)
        local mt = getrawmetatable(game)
        setreadonly(mt, false)

        local oldNamecall = mt.__namecall
        mt.__namecall = newcclosure(function(...)
            local args = {...}
            local method = getnamecallmethod()

            return oldNamecall(...)
        end)

        setreadonly(mt, true)
    end
}

NetworkObfuscator:generateDummyTraffic()
NetworkObfuscator:encryptOutgoingData()

local RuntimeIntegrity = {
    enabled = true,
    checksums = {},
    criticalFunctions = {},
    validationInterval = 0.5,
    failureCount = 0,
    maxFailures = 3,
    selfDestruct = false,

    generateChecksum = function(self, code)
        local hash = 0
        for i = 1, #code do
            hash = bit32.bxor(hash, string.byte(code, i))
            hash = bit32.lrotate(hash, 5)
            hash = bit32.bxor(hash, i * 31)
        end
        return hash
    end,

    registerFunction = function(self, name, func)
        if type(func) ~= "function" then return false end
        local info = debug.getinfo(func)
        if not info then return false end

        local funcStr = ""
        pcall(function()
            funcStr = string.dump(func)
        end)

        local realChecksum = self:generateChecksum(funcStr .. name .. tostring(tick()))

        self.criticalFunctions[name] = {
            func = func,
            checksum = realChecksum,
            originalDump = funcStr,
            lastCheck = tick(),
            callCount = 0,
            integrity = true
        }
        return true
    end,

    validateFunctions = function(self)
        if not self.enabled then return true end

        for name, data in pairs(self.criticalFunctions) do

            if not data.func or type(data.func) ~= "function" then
                self.failureCount = self.failureCount + 1
                data.integrity = false
                warn("[INTEGRITY] Function corruption detected: " .. name)

                if self.failureCount >= self.maxFailures then
                    self:triggerProtection()
                    return false
                end
            else

                local currentDump = ""
                pcall(function()
                    currentDump = string.dump(data.func)
                end)

                local currentChecksum = self:generateChecksum(currentDump .. name .. tostring(data.lastCheck))

                if data.originalDump ~= "" and currentDump ~= data.originalDump then
                    self.failureCount = self.failureCount + 1
                    data.integrity = false
                    warn("[INTEGRITY] Function modified: " .. name .. " | Checksum mismatch!")

                    if self.failureCount >= self.maxFailures then
                        self:triggerProtection()
                        return false
                    end
                end
            end
            data.lastCheck = tick()
        end
        return true
    end,

    triggerProtection = function(self)
        self.selfDestruct = true
        self.enabled = false

        warn("[INTEGRITY] ‚ö†Ô∏è CRITICAL: Maximum integrity failures reached!")
        warn("[INTEGRITY] üõë Script Protection Activated - Execution Halted")

        for name, data in pairs(self.criticalFunctions) do
            data.func = nil
            data.integrity = false
        end

        error("[SECURITY] Script terminated due to integrity violation")
    end,

    startMonitoring = function(self)
        task.spawn(function()
            while self.enabled and not self.selfDestruct do
                self:validateFunctions()
                task.wait(self.validationInterval)
            end
        end)
    end
}

local AntiTamper = {
    enabled = true,
    memoryPatterns = {},
    protectedValues = {},
    lastScan = tick(),
    scanInterval = 0.3,
    tamperAttempts = 0,
    locked = false,

    protectValue = function(self, key, value)
        local encryptionKey = math.random(1000, 9999)
        local encrypted = bit32.bxor(value, encryptionKey)

        local hash1 = bit32.bxor(encrypted, tick())
        local hash2 = bit32.lrotate(encrypted, encryptionKey % 31)
        local hash3 = bit32.bxor(hash1, hash2)

        local checksum = bit32.bxor(encrypted, bit32.bxor(hash1, hash2))

        self.protectedValues[key] = {
            encrypted = encrypted,
            encryptionKey = encryptionKey,
            hash = hash3,
            checksum = checksum,
            lastAccess = tick(),
            accessCount = 0,
            tampered = false,
            originalValue = value
        }
        return true
    end,

    getValue = function(self, key)
        local data = self.protectedValues[key]
        if not data then
            self.tamperAttempts = self.tamperAttempts + 1
            warn("[ANTI-TAMPER] Invalid key access attempt: " .. tostring(key))
            return nil
        end

        local expectedChecksum = bit32.bxor(data.encrypted,
            bit32.bxor(bit32.bxor(data.encrypted, tick()),
            bit32.lrotate(data.encrypted, (data.encryptionKey or 0) % 31)))

        if data.tampered then
            self.tamperAttempts = self.tamperAttempts + 1
            warn("[ANTI-TAMPER] Tampered value access blocked: " .. tostring(key))
            return nil
        end

        if data.accessCount > 100 then
            data.tampered = true
            self.tamperAttempts = self.tamperAttempts + 1
            warn("[ANTI-TAMPER] Suspicious access pattern detected: " .. tostring(key))
            return nil
        end

        if tick() - data.lastAccess < 0.001 then
            data.tampered = true
            self.tamperAttempts = self.tamperAttempts + 1
            warn("[ANTI-TAMPER] Rapid access detected (possible automation): " .. tostring(key))
            return nil
        end

        data.accessCount = data.accessCount + 1
        data.lastAccess = tick()

        return bit32.bxor(data.encrypted, data.encryptionKey or 0)
    end,

    detectTampering = function(self)
        if not self.enabled then return false end

        local tamperedFound = false

        for key, data in pairs(self.protectedValues) do

            if data.tampered then
                tamperedFound = true
                self.tamperAttempts = self.tamperAttempts + 1
                warn("[ANTI-TAMPER] ‚ö†Ô∏è Tampering detected on: " .. key)
            end

            if data.encrypted and data.encryptionKey then
                local testDecrypt = bit32.bxor(data.encrypted, data.encryptionKey)
                if testDecrypt ~= data.originalValue then
                    data.tampered = true
                    tamperedFound = true
                    self.tamperAttempts = self.tamperAttempts + 1
                    warn("[ANTI-TAMPER] ‚ö†Ô∏è Encryption corruption detected: " .. key)
                end
            end

            if data.checksum then
                local expectedChecksum = bit32.bxor(data.encrypted,
                    bit32.bxor(
                        bit32.bxor(data.encrypted, data.lastAccess or tick()),
                        bit32.lrotate(data.encrypted, (data.encryptionKey or 0) % 31)
                    ))

                if math.abs(data.checksum - expectedChecksum) > 1000 then
                    data.tampered = true
                    tamperedFound = true
                    self.tamperAttempts = self.tamperAttempts + 1
                    warn("[ANTI-TAMPER] ‚ö†Ô∏è Checksum mismatch detected: " .. key)
                end
            end

            if data.accessCount > 50 and (tick() - data.lastAccess) < 1 then
                data.tampered = true
                tamperedFound = true
                warn("[ANTI-TAMPER] ‚ö†Ô∏è Suspicious access pattern: " .. key)
            end
        end

        if self.tamperAttempts >= 5 then
            self:lockScript()
            return true
        end

        return tamperedFound
    end,

    lockScript = function(self)
        self.locked = true
        self.enabled = false

        warn("[ANTI-TAMPER] üîí CRITICAL: Script locked due to tampering attempts")
        warn("[ANTI-TAMPER] üõë All protected values have been cleared")

        for key, data in pairs(self.protectedValues) do
            data.encrypted = nil
            data.encryptionKey = nil
            data.originalValue = nil
            data.tampered = true
        end

        self.enabled = false

        error("[SECURITY] Script terminated due to tampering detection")
    end,

    startScanning = function(self)
        task.spawn(function()
            while self.enabled and not self.locked do
                self:detectTampering()
                task.wait(self.scanInterval)
            end
        end)
    end
}

local EnvironmentValidator = {
    enabled = true,
    blacklistedProcesses = {
        "synapse", "exploit", "cheat", "hack", "script", "executor",
        "injector", "debug", "memory", "scanner", "monitor", "hook"
    },
    suspiciousPatterns = {
        "anti", "detect", "check", "scan", "admin", "moderator",
        "security", "ban", "kick", "report", "log"
    },
    validationPassed = false,
    environmentScore = 100,
    riskLevel = "LOW",

    validateEnvironment = function(self)
        if not self.enabled then
            self.validationPassed = true
            return true
        end

        local safe = true
        local score = 100
        local threats = {}

        local success1 = pcall(function()
            for _, service in ipairs(game:GetChildren()) do
                local name = tostring(service):lower()

                for _, pattern in ipairs(self.blacklistedProcesses) do
                    if name:find(pattern, 1, true) then
                        score = score - 20
                        table.insert(threats, {type = "blacklisted_service", name = name, pattern = pattern})
                        warn("[ENV] ‚ö†Ô∏è Blacklisted process detected: " .. name)
                    end
                end

                for _, pattern in ipairs(self.suspiciousPatterns) do
                    if name:find(pattern, 1, true) then
                        score = score - 10
                        table.insert(threats, {type = "suspicious_pattern", name = name, pattern = pattern})
                    end
                end
            end
        end)

        if not success1 then
            score = score - 30
            warn("[ENV] ‚ö†Ô∏è Service scan blocked - possible protection")
        end

        local success2 = pcall(function()
            local objectCount = 0
            for _, obj in ipairs(workspace:GetDescendants()) do
                objectCount = objectCount + 1
                local name = tostring(obj.Name):lower()

                for _, pattern in ipairs(self.suspiciousPatterns) do
                    if name:find(pattern, 1, true) then
                        score = score - 3
                        table.insert(threats, {type = "suspicious_object", name = name})
                    end
                end

                for _, pattern in ipairs(self.blacklistedProcesses) do
                    if name:find(pattern, 1, true) then
                        score = score - 15
                        table.insert(threats, {type = "blacklisted_object", name = name})
                        warn("[ENV] ‚ö†Ô∏è Blacklisted object in workspace: " .. name)
                    end
                end

                if objectCount > 5000 then break end
            end
        end)

        if not success2 then
            score = score - 25
            warn("[ENV] ‚ö†Ô∏è Workspace scan blocked - possible protection")
        end

        local success3 = pcall(function()
            local Players = game:GetService("Players")
            if Players then
                for _, player in ipairs(Players:GetPlayers()) do
                    local name = tostring(player.Name):lower()
                    for _, pattern in ipairs(self.blacklistedProcesses) do
                        if name:find(pattern, 1, true) then
                            score = score - 10
                            warn("[ENV] ‚ö†Ô∏è Suspicious player name: " .. player.Name)
                        end
                    end
                end
            end
        end)

        local success4 = pcall(function()
            local RS = game:GetService("ReplicatedStorage")
            if RS then
                for _, obj in ipairs(RS:GetDescendants()) do
                    local name = tostring(obj.Name):lower()
                    for _, pattern in ipairs(self.blacklistedProcesses) do
                        if name:find(pattern, 1, true) then
                            score = score - 12
                            warn("[ENV] ‚ö†Ô∏è Blacklisted in ReplicatedStorage: " .. name)
                        end
                    end
                end
            end
        end)

        self.environmentScore = math.max(0, score)
        self.validationPassed = safe and score >= 60

        if score < 40 then
            self.riskLevel = "CRITICAL"
            safe = false
        elseif score < 60 then
            self.riskLevel = "HIGH"
            safe = false
        elseif score < 80 then
            self.riskLevel = "MEDIUM"
        else
            self.riskLevel = "LOW"
        end

        if #threats > 0 then
            warn(string.format("[ENV] Found %d threats | Score: %d | Risk: %s",
                #threats, score, self.riskLevel))
        end

        return self.validationPassed
    end,

    isEnvironmentSafe = function(self)
        return self.validationPassed and self.environmentScore >= 60
    end
}

local BehaviorMonitor = {
    enabled = true,
    actions = {},
    patterns = {},
    anomalyThreshold = 10,
    anomalyCount = 0,
    monitoring = true,
    alertLevel = 0,

    logAction = function(self, actionType, details)
        if not self.enabled then return end

        local action = {
            type = actionType,
            details = details or {},
            timestamp = tick(),
            suspicious = false
        }

        table.insert(self.actions, action)

        if #self.actions > 1000 then
            table.remove(self.actions, 1)
        end

        self:analyzePattern(action)
    end,

    analyzePattern = function(self, action)
        if not self.enabled then return end

        local recentActions = {}
        local currentTime = tick()

        for i = #self.actions, math.max(1, #self.actions - 50), -1 do
            local act = self.actions[i]
            if currentTime - act.timestamp <= 5 then
                table.insert(recentActions, act)
            end
        end

        if #recentActions >= 20 then
            self.anomalyCount = self.anomalyCount + 2
            action.suspicious = true
            self.alertLevel = self.alertLevel + 2
            warn("[BEHAVIOR] ‚ö†Ô∏è High action rate: " .. #recentActions .. " actions in 5s")
        end

        local sameTypeCount = 0
        for _, act in ipairs(recentActions) do
            if act.type == action.type then
                sameTypeCount = sameTypeCount + 1
            end
        end

        if sameTypeCount > 10 then
            self.anomalyCount = self.anomalyCount + 1
            action.suspicious = true
            self.alertLevel = self.alertLevel + 3
            warn("[BEHAVIOR] ‚ö†Ô∏è Repetitive pattern: " .. action.type .. " (" .. sameTypeCount .. "x)")
        end

        if #self.actions >= 3 then
            local last3 = {
                self.actions[#self.actions - 2],
                self.actions[#self.actions - 1],
                action
            }

            local timeDiff1 = last3[2].timestamp - last3[1].timestamp
            local timeDiff2 = last3[3].timestamp - last3[2].timestamp

            if math.abs(timeDiff1 - timeDiff2) < 0.01 and timeDiff1 > 0 then
                self.anomalyCount = self.anomalyCount + 3
                action.suspicious = true
                self.alertLevel = self.alertLevel + 4
                warn("[BEHAVIOR] ‚ö†Ô∏è Automated timing pattern detected")
            end
        end

        local patternKey = action.type
        if not self.patterns[patternKey] then
            self.patterns[patternKey] = {count = 0, suspicious = 0, lastTime = 0}
        end

        self.patterns[patternKey].count = self.patterns[patternKey].count + 1
        self.patterns[patternKey].lastTime = currentTime

        if action.suspicious then
            self.patterns[patternKey].suspicious = self.patterns[patternKey].suspicious + 1
        end

        if self.anomalyCount >= self.anomalyThreshold then
            self:triggerAlert()
        end
    end,

    triggerAlert = function(self)
        self.alertLevel = math.min(10, self.alertLevel + 2)
        warn("[BEHAVIOR] üö® SECURITY ALERT - Level: " .. self.alertLevel)
        warn("[BEHAVIOR] Anomaly count: " .. self.anomalyCount)

        if self.anomalyCount >= self.anomalyThreshold * 2 then
            warn("[BEHAVIOR] üõë CRITICAL: Stopping script due to suspicious behavior")
            self.monitoring = false
            self.enabled = false
            error("[SECURITY] Script terminated - Suspicious behavior detected")
        end
    end,

    reset = function(self)
        self.anomalyCount = 0
        self.alertLevel = 0
    end
}

local RASP = {
    enabled = true,
    protectionLayers = {},
    activeThreats = {},
    defenseMode = "ACTIVE",
    threatLevel = 0,

    registerLayer = function(self, layerName, protectionFunc)
        self.protectionLayers[layerName] = {
            name = layerName,
            func = protectionFunc,
            active = true,
            callCount = 0,
            blockCount = 0,
            lastActivation = 0
        }
    end,

    protect = function(self, context)
        if not self.enabled then return true end

        local blocked = false
        local blockReasons = {}

        for name, layer in pairs(self.protectionLayers) do
            if layer.active and type(layer.func) == "function" then
                local success, result = pcall(layer.func, context)
                layer.callCount = layer.callCount + 1

                if not success then
                    layer.blockCount = layer.blockCount + 1
                    layer.lastActivation = tick()
                    blocked = true
                    table.insert(blockReasons, {layer = name, reason = "execution_failed"})
                    self:recordThreat(name, "CRITICAL")
                    warn("[RASP] ‚ö†Ô∏è Layer failed: " .. name)
                elseif not result then
                    layer.blockCount = layer.blockCount + 1
                    layer.lastActivation = tick()
                    blocked = true
                    table.insert(blockReasons, {layer = name, reason = "validation_failed"})
                    self:recordThreat(name, "HIGH")
                    warn("[RASP] ‚ö†Ô∏è Validation failed in: " .. name)
                end
            end
        end

        if blocked then
            self.threatLevel = self.threatLevel + #blockReasons

            if self.threatLevel > 20 then
                warn("[RASP] üö® CRITICAL THREAT LEVEL: " .. self.threatLevel)
                self:activateDefenseMode("LOCKDOWN")
            elseif self.threatLevel > 10 then
                self:activateDefenseMode("HIGH_ALERT")
            end
        end

        return not blocked
    end,

    activateDefenseMode = function(self, mode)
        self.defenseMode = mode
        warn("[RASP] Defense mode changed to: " .. mode)

        if mode == "LOCKDOWN" then
            warn("[RASP] üîí LOCKDOWN MODE ACTIVATED")
            self.enabled = false
            error("[SECURITY] RASP Lockdown - Script terminated")
        end
    end,

    recordThreat = function(self, source, severity)
        severity = severity or "MEDIUM"

        local threat = {
            source = source,
            timestamp = tick(),
            severity = severity,
            stackTrace = debug.traceback("", 2),
            count = 1
        }

        local found = false
        for i, existingThreat in ipairs(self.activeThreats) do
            if existingThreat.source == source and
               (tick() - existingThreat.timestamp) < 60 then
                existingThreat.count = existingThreat.count + 1
                existingThreat.timestamp = tick()
                found = true

                if existingThreat.count > 5 then
                    existingThreat.severity = "CRITICAL"
                    warn("[RASP] ‚ö†Ô∏è Threat escalated: " .. source .. " (count: " .. existingThreat.count .. ")")
                end
                break
            end
        end

        if not found then
            table.insert(self.activeThreats, threat)
        end

        local severityWeight = {CRITICAL = 5, HIGH = 3, MEDIUM = 2, LOW = 1}
        self.threatLevel = self.threatLevel + (severityWeight[severity] or 1)

        if #self.activeThreats > 100 then
            table.remove(self.activeThreats, 1)
        end

        warn(string.format("[RASP] Threat recorded: %s | Severity: %s | Total Level: %d",
            source, severity, self.threatLevel))
    end,

    getStatus = function(self)
        return {
            enabled = self.enabled,
            defenseMode = self.defenseMode,
            threatLevel = self.threatLevel,
            activeLayers = #self.protectionLayers,
            activeThreats = #self.activeThreats
        }
    end
}

local AccessControl = {
    enabled = true,
    roles = {},
    permissions = {},
    currentRole = "USER",
    accessLog = {},
    deniedAttempts = 0,
    maxDeniedAttempts = 10,

    createRole = function(self, roleName, permissions)
        self.roles[roleName] = {
            name = roleName,
            permissions = permissions or {},
            created = tick(),
            active = true
        }
    end,

    grantPermission = function(self, roleName, permission)
        if not self.roles[roleName] then return false end

        if not self.roles[roleName].permissions then
            self.roles[roleName].permissions = {}
        end

        table.insert(self.roles[roleName].permissions, permission)
        return true
    end,

    hasPermission = function(self, permission)
        if not self.enabled then return true end

        local role = self.roles[self.currentRole]
        if not role then
            self.deniedAttempts = self.deniedAttempts + 1
            self:logAccess(permission, false)
            warn("[ACCESS] ‚ö†Ô∏è Invalid role: " .. tostring(self.currentRole))
            return false
        end

        if not role.active then
            self.deniedAttempts = self.deniedAttempts + 1
            self:logAccess(permission, false)
            warn("[ACCESS] ‚ö†Ô∏è Inactive role: " .. role.name)

            if self.deniedAttempts >= self.maxDeniedAttempts then
                self:lockAccess()
            end
            return false
        end

        local hasAccess = false
        if role.permissions then
            for _, perm in ipairs(role.permissions) do
                if perm == permission or perm == "*" then
                    hasAccess = true
                    break
                end

                if perm:sub(-1) == "*" then
                    local prefix = perm:sub(1, -2)
                    if permission:sub(1, #prefix) == prefix then
                        hasAccess = true
                        break
                    end
                end
            end
        end

        self:logAccess(permission, hasAccess)

        if not hasAccess then
            self.deniedAttempts = self.deniedAttempts + 1
            warn(string.format("[ACCESS] ‚ö†Ô∏è Permission denied: %s for role %s (attempt %d/%d)",
                permission, role.name, self.deniedAttempts, self.maxDeniedAttempts))

            if self.deniedAttempts >= self.maxDeniedAttempts then
                self:lockAccess()
            end
        end

        return hasAccess
    end,

    logAccess = function(self, permission, granted)
        table.insert(self.accessLog, {
            permission = permission,
            granted = granted,
            role = self.currentRole,
            timestamp = tick()
        })

        if #self.accessLog > 500 then
            table.remove(self.accessLog, 1)
        end
    end,

    lockAccess = function(self)
        warn("[ACCESS CONTROL] üîí CRITICAL: Too many denied attempts")
        warn("[ACCESS CONTROL] üõë Access locked - All permissions revoked")

        self.currentRole = "LOCKED"
        self.enabled = false

        for roleName, role in pairs(self.roles) do
            role.active = false
            role.permissions = {}
        end

        error("[SECURITY] Access Control terminated - Too many denied attempts")
    end,

    initialize = function(self)
        self:createRole("ADMIN", {"*"})
        self:createRole("USER", {"teleport", "read", "execute"})
        self:createRole("GUEST", {"read"})
        self:createRole("LOCKED", {})
        self.currentRole = "USER"
    end
}

local LicenseManager = {
    enabled = true,
    validKeys = {},
    currentKey = nil,
    keyStatus = "UNVERIFIED",
    expirationTime = 0,
    hwid = "",
    authenticated = false,

    generateHWID = function(self)
        local Players = game:GetService("Players")
        local player = Players.LocalPlayer

        if not player then
            self.hwid = tostring(math.random(100000000, 999999999))
            return self.hwid
        end

        local userId = player.UserId or 0
        local userName = player.Name or "Unknown"
        local accountAge = player.AccountAge or 0

        local combined = string.format("%d_%s_%d_%d",
            userId, userName, accountAge, tick())

        local hash = 0
        for i = 1, #combined do
            hash = bit32.bxor(hash, string.byte(combined, i))
            hash = bit32.lrotate(hash, 7)
        end

        self.hwid = string.format("%X", hash)
        return self.hwid
    end,

    generateLicenseKey = function(self, duration)
        local key = string.format("OXYO-%X-%X-%X",
            math.random(0x10000, 0xFFFFF),
            math.random(0x10000, 0xFFFFF),
            math.random(0x10000, 0xFFFFF)
        )

        self.validKeys[key] = {
            created = tick(),
            expiration = tick() + (duration or 86400),
            hwid = self.hwid,
            uses = 0,
            maxUses = 1,
            active = true
        }

        return key
    end,

    validateKey = function(self, key)
        if not self.enabled then
            self.authenticated = true
            self.keyStatus = "BYPASSED"
            warn("[LICENSE] ‚ö†Ô∏è License validation bypassed")
            return true
        end

        if not key or key == "" then
            self.keyStatus = "INVALID"
            warn("[LICENSE] ‚ùå Invalid key format")
            return false
        end

        if not key:match("^OXYO%-%x+%-%x+%-%x+$") then
            self.keyStatus = "INVALID_FORMAT"
            warn("[LICENSE] ‚ùå Key format validation failed")
            return false
        end

        local keyData = self.validKeys[key]
        if not keyData then
            self.keyStatus = "NOT_FOUND"
            warn("[LICENSE] ‚ùå Key not found in database")
            return false
        end

        if not keyData.active then
            self.keyStatus = "DEACTIVATED"
            warn("[LICENSE] ‚ùå Key has been deactivated")
            return false
        end

        local currentTime = tick()
        if keyData.expiration < currentTime then
            self.keyStatus = "EXPIRED"
            keyData.active = false
            warn(string.format("[LICENSE] ‚ùå Key expired (expired at: %.0f, current: %.0f)",
                keyData.expiration, currentTime))
            return false
        end

        if keyData.hwid ~= "" and keyData.hwid ~= self.hwid then
            self.keyStatus = "HWID_MISMATCH"
            warn(string.format("[LICENSE] ‚ùå HWID mismatch (expected: %s, got: %s)",
                keyData.hwid, self.hwid))
            return false
        end

        if keyData.uses >= keyData.maxUses then
            self.keyStatus = "MAX_USES"
            warn(string.format("[LICENSE] ‚ùå Max uses reached (%d/%d)",
                keyData.uses, keyData.maxUses))
            return false
        end

        keyData.uses = keyData.uses + 1
        keyData.hwid = self.hwid
        keyData.lastUsed = currentTime

        self.currentKey = key
        self.authenticated = true
        self.keyStatus = "VALID"
        self.expirationTime = keyData.expiration

        local remainingTime = keyData.expiration - currentTime
        warn(string.format("[LICENSE] ‚úÖ Key validated successfully (uses: %d/%d, expires in: %.0fs)",
            keyData.uses, keyData.maxUses, remainingTime))

        return true
    end,

    isAuthenticated = function(self)
        if not self.enabled then return true end

        if not self.authenticated then
            warn("[LICENSE] ‚ö†Ô∏è Not authenticated")
            return false
        end

        local currentTime = tick()
        if self.expirationTime > 0 and currentTime >= self.expirationTime then
            self.authenticated = false
            self.keyStatus = "EXPIRED"
            warn("[LICENSE] ‚ùå Session expired")
            return false
        end

        if self.currentKey then
            local keyData = self.validKeys[self.currentKey]

            if not keyData then
                self.authenticated = false
                self.keyStatus = "KEY_REMOVED"
                warn("[LICENSE] ‚ùå Current key was removed")
                return false
            end

            if not keyData.active then
                self.authenticated = false
                self.keyStatus = "KEY_DEACTIVATED"
                warn("[LICENSE] ‚ùå Current key was deactivated")
                return false
            end

            if keyData.expiration < currentTime then
                self.authenticated = false
                self.keyStatus = "EXPIRED"
                keyData.active = false
                warn("[LICENSE] ‚ùå Current key expired")
                return false
            end
        end

        return true
    end,

    initialize = function(self)
        self:generateHWID()

        local testKey = self:generateLicenseKey(86400 * 365)
        self:validateKey(testKey)

        print("[LICENSE] Generated Test Key: " .. testKey)
        print("[LICENSE] HWID: " .. self.hwid)
    end
}

local ServerValidator = {
    enabled = true,
    serverEndpoint = "",
    lastSync = 0,
    syncInterval = 30,
    validationAttempts = 0,
    maxAttempts = 5,
    serverStatus = "UNKNOWN",

    sendToServer = function(self, data)
        if not self.enabled or self.serverEndpoint == "" then
            return true
        end

        self.validationAttempts = self.validationAttempts + 1

        local success = math.random() > 0.1

        if success then
            self.serverStatus = "CONNECTED"
            self.lastSync = tick()
            return true
        else
            self.serverStatus = "ERROR"
            return false
        end
    end,

    validateWithServer = function(self, dataToValidate)
        if not self.enabled then return true end

        local data = {
            action = "validate",
            timestamp = tick(),
            data = dataToValidate
        }

        return self:sendToServer(data)
    end,

    startSync = function(self)
        task.spawn(function()
            while self.enabled do
                self:sendToServer({action = "heartbeat", timestamp = tick()})
                task.wait(self.syncInterval)
            end
        end)
    end
}

local IntegrityAttestation = {
    enabled = true,
    attestations = {},
    criticalChecksums = {},
    lastAttestation = 0,
    attestationInterval = 1,
    failedAttestations = 0,
    maxFailures = 5,

    createAttestation = function(self, component, value)
        local checksum = bit32.bxor(
            bit32.lrotate(value or math.random(1000000, 9999999), 13),
            tick()
        )

        self.attestations[component] = {
            checksum = checksum,
            timestamp = tick(),
            verified = true,
            attempts = 0
        }

        self.criticalChecksums[component] = checksum
        return checksum
    end,

    verifyAttestation = function(self, component)
        if not self.enabled then return true end

        local attestation = self.attestations[component]
        if not attestation then
            return false
        end

        attestation.attempts = attestation.attempts + 1

        local expectedChecksum = self.criticalChecksums[component]
        if not expectedChecksum then
            return false
        end

        local isValid = attestation.checksum ~= nil and attestation.verified

        if not isValid then
            self.failedAttestations = self.failedAttestations + 1
            attestation.verified = false

            if self.failedAttestations >= self.maxFailures then
                warn("[ATTESTATION] Critical integrity failure detected")
                return false
            end
        end

        self.lastAttestation = tick()
        return isValid
    end,

    startMonitoring = function(self)
        task.spawn(function()
            while self.enabled do
                for component, _ in pairs(self.attestations) do
                    self:verifyAttestation(component)
                end
                task.wait(self.attestationInterval)
            end
        end)
    end,

    initialize = function(self)
        self:createAttestation("core", 12345678)
        self:createAttestation("teleport", 87654321)
        self:createAttestation("protection", 11223344)
        self:createAttestation("security", 99887766)
    end
}

local ZeroTrustModel = {
    enabled = true,
    trustScore = 0,
    verificationLayers = {},
    executionAllowed = false,
    trustThreshold = 80,

    addVerificationLayer = function(self, layerName, verifyFunc)
        self.verificationLayers[layerName] = {
            name = layerName,
            verify = verifyFunc,
            weight = 10,
            passed = false,
            lastCheck = 0
        }
    end,

    calculateTrustScore = function(self)
        if not self.enabled then
            self.executionAllowed = true
            return 100
        end

        local score = 0
        local totalWeight = 0

        for name, layer in pairs(self.verificationLayers) do
            totalWeight = totalWeight + layer.weight

            if type(layer.verify) == "function" then
                local success, result = pcall(layer.verify)
                if success and result then
                    score = score + layer.weight
                    layer.passed = true
                else
                    layer.passed = false
                end
                layer.lastCheck = tick()
            end
        end

        self.trustScore = totalWeight > 0 and (score / totalWeight) * 100 or 0
        self.executionAllowed = self.trustScore >= self.trustThreshold

        return self.trustScore
    end,

    canExecute = function(self)
        self:calculateTrustScore()
        return self.executionAllowed
    end,

    initialize = function(self)

        self:addVerificationLayer("license", function()
            return LicenseManager:isAuthenticated()
        end)

        self:addVerificationLayer("environment", function()
            return EnvironmentValidator:isEnvironmentSafe()
        end)

        self:addVerificationLayer("integrity", function()
            return RuntimeIntegrity.failureCount < RuntimeIntegrity.maxFailures
        end)

        self:addVerificationLayer("tamper", function()
            return not AntiTamper.locked
        end)

        self:addVerificationLayer("access", function()
            return AccessControl.currentRole ~= "LOCKED"
        end)
    end
}

local function InitializeAllProtections()

    local initSuccess = true
    local failureReasons = {}

    local licenseInit = pcall(function()
        LicenseManager:initialize()
    end)

    if licenseInit then
    else
        table.insert(failureReasons, "License initialization failed")
        initSuccess = false
        warn("‚ùå License Manager: FAILED")
    end

    local accessInit = pcall(function()
        AccessControl:initialize()
    end)

    if accessInit then
    else
        table.insert(failureReasons, "Access Control initialization failed")
        initSuccess = false
        warn("‚ùå Access Control: FAILED")
    end

    local attestInit = pcall(function()
        IntegrityAttestation:initialize()
    end)

    if attestInit then
    else
        table.insert(failureReasons, "Integrity Attestation initialization failed")
        warn("‚ùå Integrity Attestation: FAILED")
    end

    local zeroTrustInit = pcall(function()
        ZeroTrustModel:initialize()
    end)

    if zeroTrustInit then
    else
        table.insert(failureReasons, "Zero-Trust initialization failed")
        initSuccess = false
        warn("‚ùå Zero-Trust Model: FAILED")
    end

    local envSafe = false
    local envInit = pcall(function()
        envSafe = EnvironmentValidator:validateEnvironment()
    end)

    if envInit and envSafe then
    else
        print("‚ö†Ô∏è Environment Validation: RISKY (Score: " .. EnvironmentValidator.environmentScore .. ")")

        if EnvironmentValidator.riskLevel == "CRITICAL" or EnvironmentValidator.riskLevel == "HIGH" then
            table.insert(failureReasons, "Environment risk level too high: " .. EnvironmentValidator.riskLevel)
            warn("‚ùå Environment: UNSAFE - Risk Level: " .. EnvironmentValidator.riskLevel)
        end
    end

    local integrityMonitor = pcall(function()
        RuntimeIntegrity:startMonitoring()
    end)

    if integrityMonitor then
    else
        warn("‚ùå Runtime Integrity: MONITORING FAILED")
    end

    local tamperScan = pcall(function()
        AntiTamper:startScanning()
    end)

    if tamperScan then
    else
        warn("‚ùå Anti-Tamper: SCANNING FAILED")
    end

    local attestMonitor = pcall(function()
        IntegrityAttestation:startMonitoring()
    end)

    if attestMonitor then
    else
        warn("‚ùå Attestation: MONITORING FAILED")
    end

    local serverSync = pcall(function()
        ServerValidator:startSync()
    end)

    if serverSync then
    else
        warn("‚ùå Server Validation: SYNCING FAILED")
    end

    local trustScore = 0
    local canExecute = false

    local finalCheck = pcall(function()
        trustScore = ZeroTrustModel:calculateTrustScore()
        canExecute = ZeroTrustModel:canExecute()
    end)

    if not finalCheck then
        table.insert(failureReasons, "Final verification failed")
        initSuccess = false
    else
        print("[SECURITY] Execution: " .. (canExecute and "ALLOWED ‚úÖ" or "BLOCKED ‚ùå"))

        if trustScore < 60 then
            table.insert(failureReasons, "Trust score too low: " .. math.floor(trustScore) .. "%")
            canExecute = false
        end
    end

    if not initSuccess or not canExecute then
        warn("[SECURITY] üõë INITIALIZATION FAILED")
        warn("[SECURITY] Failure reasons:")
        for i, reason in ipairs(failureReasons) do
            warn(string.format("  %d. %s", i, reason))
        end
        warn("[SECURITY] Script execution blocked for security reasons")
        return false
    end

    if RuntimeIntegrity.selfDestruct then
        warn("[SECURITY] üõë Runtime Integrity in self-destruct mode")
        return false
    end

    if AntiTamper.locked then
        warn("[SECURITY] üõë Anti-Tamper system locked")
        return false
    end

    if not LicenseManager.authenticated then
        warn("[SECURITY] üõë License not authenticated")
        return false
    end

    return true
end

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")
local TweenService = game:GetService("TweenService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local LocalPlayer = Players.LocalPlayer
local Camera = Workspace.CurrentCamera

BehaviorMonitor:logAction("service_access", {service = "Players"})
BehaviorMonitor:logAction("service_access", {service = "Workspace"})

local SafeWrapper = {
    protectedFunctions = {},
    errorCount = 0,
    maxErrors = 10,
    errorLog = {},
    protect = function(self, funcName, func, fallback)

        RuntimeIntegrity:registerFunction(funcName, func)

        self.protectedFunctions[funcName] = {
            original = func,
            fallback = fallback or function() end,
            callCount = 0,
            errorCount = 0
        }
        return function(...)

            if not ZeroTrustModel:canExecute() then
                warn("[SAFE WRAPPER] Execution blocked by Zero-Trust model")
                return fallback and fallback(...) or nil
            end

            local protected = self.protectedFunctions[funcName]
            if not protected then return end

            BehaviorMonitor:logAction("function_call", {name = funcName})

            protected.callCount = protected.callCount + 1
            if not protected.original or type(protected.original) ~= "function" then
                protected.errorCount = protected.errorCount + 1
                self:logError(funcName, "Function is nil or not a function")
                return protected.fallback(...)
            end
            local success, result1, result2, result3 = pcall(protected.original, ...)
            if success then
                return result1, result2, result3
            else
                protected.errorCount = protected.errorCount + 1
                self:logError(funcName, tostring(result1))
                return protected.fallback(...)
            end
        end
    end,
    logError = function(self, funcName, errorMsg)
        self.errorCount = self.errorCount + 1
        table.insert(self.errorLog, {
            func = funcName,
            error = errorMsg,
            time = tick()
        })
        if #self.errorLog > 50 then
            table.remove(self.errorLog, 1)
        end
        if self.errorCount <= self.maxErrors then
            warn("[SafeWrapper] Error in " .. funcName .. ": " .. errorMsg)
        end

        BehaviorMonitor:logAction("error", {func = funcName, error = errorMsg})
    end,
    isValid = function(self, func)
        return func ~= nil and type(func) == "function"
    end,
    safeCall = function(self, func, ...)
        if not self:isValid(func) then
            return nil
        end
        local success, result1, result2, result3 = pcall(func, ...)
        if success then
            return result1, result2, result3
        else
            return nil
        end
    end
}

local function safeFunctionCall(func, ...)
    return SafeWrapper:safeCall(func, ...)
end

local function safeCall(fn, ...)
    local ok, a, b, c = pcall(fn, ...)
    if not ok then return nil end
    return a, b, c
end

local function clamp(val, lo, hi)
    if type(val) ~= "number" then return lo end
    if val < lo then return lo end
    if val > hi then return hi end
    return val
end

local function randomFloat(min, max)
    return min + (math.random() * (max - min))
end

local function isMobileDevice()
    return UserInputService.TouchEnabled and not UserInputService.KeyboardEnabled
end

local function GetScreenPoint()
    if isMobileDevice() then
        local vp = Camera and Camera.ViewportSize or Vector2.new(1280, 720)
        return Vector2.new(vp.X / 2, vp.Y / 2)
    else
        local ok, pos = pcall(function() return UserInputService:GetMouseLocation() end)
        if ok and pos then return pos end
        local vp = Camera and Camera.ViewportSize or Vector2.new(1280, 720)
        return Vector2.new(vp.X / 2, vp.Y / 2)
    end
end

local ServerSpoofing = {
    enabled = false,
    fakeCFrame = nil,
    lastRealCFrame = nil,
    isSpoofing = false,
    updateRate = 0.1,
    lastUpdate = 0,
    totalSpoofs = 0,
    packetsBlocked = 0,
    originalFunctions = {},
    initialize = function(self)

        if not AccessControl:hasPermission("teleport") then
            warn("[SERVER SPOOFING] Permission denied")
            return false
        end

        local char = LocalPlayer.Character
        if not char then return false end
        local hrp = char:FindFirstChild("HumanoidRootPart")
        if not hrp then return false end
        self.fakeCFrame = hrp.CFrame
        self.lastRealCFrame = hrp.CFrame
        pcall(function()
            self.originalFunctions.getCFrame = hrp.GetPropertyChangedSignal
            self.originalFunctions.setIndex = hrp.__index
        end)

        AntiTamper:protectValue("spoofing_enabled", 1)

        return true
    end,
    allowedRemotes = {

        "switchteam", "switch_team", "changeteam", "change_team",
        "setteam",    "set_team",    "teamswitch",  "teamchange",
        "selectteam", "chooseteam",  "jointeam",     "team",

        "shoot", "fire", "damage", "hit", "bullet", "reloadgun",
        "weapon", "gun", "attack", "combat", "equipgun", "unequipgun",
        "trigger", "aim", "reload", "melee", "stab", "punch",

        "animation", "sound", "effect", "particle", "play",
        "chat", "message", "ui", "menu", "notify",
        "pickup", "drop", "use", "interact", "click", "tool",

        "spawn", "respawn", "requestspawn",
        "buy", "purchase", "shop", "sell", "trade",
    },
    isRemoteAllowed = function(self, remoteName)
        if not remoteName then return true end
        local lowerName = remoteName:lower()
        for _, allowed in ipairs(self.allowedRemotes) do
            if lowerName:find(allowed) then
                return true
            end
        end
        return false
    end,
    blockPositionUpdates = function(self)
        if not self.enabled then return end

        BehaviorMonitor:logAction("hook_attempt", {target = "remotes"})

        local oldFireServer = nil
        pcall(function()
            oldFireServer = hookmetamethod(game, "__namecall", function(...)
                local method = getnamecallmethod()
                local self_obj = ({...})[1]
                if method == "FireServer" or method == "InvokeServer" then
                    if self_obj and (self_obj:IsA("RemoteEvent") or self_obj:IsA("RemoteFunction")) then
                        local name = self_obj.Name

                        BehaviorMonitor:logAction("remote_call", {name = name, method = method})

                        if ServerSpoofing:isRemoteAllowed(name) then
                            return oldFireServer(...)
                        end
                        local lowerName = name:lower()
                        if lowerName:find("position") or lowerName:find("move") or
                           lowerName:find("cframe") or lowerName:find("velocity") or
                           lowerName:find("sync") or lowerName:find("physics") then
                            ServerSpoofing.packetsBlocked = ServerSpoofing.packetsBlocked + 1
                            return
                        end
                        return oldFireServer(...)
                    end
                end
                return oldFireServer(...)
            end)
        end)
    end,
    sendFakePosition = function(self)
        if not self.enabled or not self.isSpoofing then return end
        local now = tick()
        if now - self.lastUpdate < self.updateRate then return end
        self.lastUpdate = now
        pcall(function()
            local char = LocalPlayer.Character
            if not char then return end
            local hrp = char:FindFirstChild("HumanoidRootPart")
            if not hrp then return end
            if math.random(1, 100) <= 15 then
                local microMove = Vector3.new(
                    math.random(-5, 5) / 1000,
                    0,
                    math.random(-5, 5) / 1000
                )
                self.fakeCFrame = self.fakeCFrame + microMove
            end
            self.totalSpoofs = self.totalSpoofs + 1
        end)
    end,
    startSpoofing = function(self)
        if not self.enabled then return false end
        if not self:initialize() then
            return false
        end
        self.isSpoofing = true
        self:blockPositionUpdates()
        task.spawn(function()
            while self.isSpoofing do
                pcall(function()
                    self:sendFakePosition()
                end)
                task.wait(self.updateRate)
            end
        end)
        return true
    end,
    stopSpoofing = function(self)
        self.isSpoofing = false
    end,
    setFakePosition = function(self, cf)
        self.fakeCFrame = cf
    end,
    getFakePosition = function(self)
        return self.fakeCFrame
    end
}

local QuantumProtection = {
    enabled = true,
    shiftPosition = function(self, cf)
        if not self.enabled then return cf end
        local phase = tick() % 1
        local offset = Vector3.new(
            math.sin(phase * math.pi * 2) * 0.001,
            math.cos(phase * math.pi * 3) * 0.001,
            math.sin(phase * math.pi * 5) * 0.001
        )
        return cf + offset
    end
}

local MemoryEncryption = {
    enabled = true,
    key = math.random(1000000, 9999999),
    encrypt = function(self, value)
        if not self.enabled then return value end
        return bit32.bxor(value, self.key)
    end,
    decrypt = function(self, value)
        if not self.enabled then return value end
        return bit32.bxor(value, self.key)
    end
}

RASP:registerLayer("quantum", function(context)
    return QuantumProtection.enabled
end)

RASP:registerLayer("memory", function(context)
    return MemoryEncryption.enabled
end)

RASP:registerLayer("spoofing", function(context)
    return not ServerSpoofing.isSpoofing or ServerSpoofing.enabled
end)

local function ProtectedTeleport(targetPosition)

    if not ZeroTrustModel:canExecute() then
        warn("[TELEPORT] Blocked by Zero-Trust model")
        return false
    end

    if not AccessControl:hasPermission("teleport") then
        warn("[TELEPORT] Permission denied")
        return false
    end

    if not LicenseManager:isAuthenticated() then
        warn("[TELEPORT] License verification failed")
        return false
    end

    BehaviorMonitor:logAction("teleport", {position = tostring(targetPosition)})

    if not RASP:protect({action = "teleport", position = targetPosition}) then
        warn("[TELEPORT] RASP protection triggered")
        return false
    end

    if not IntegrityAttestation:verifyAttestation("teleport") then
        warn("[TELEPORT] Integrity attestation failed")
        return false
    end

    pcall(function()
        local char = LocalPlayer.Character
        if not char then return end
        local hrp = char:FindFirstChild("HumanoidRootPart")
        if not hrp then return end

        local protectedPosition = QuantumProtection:shiftPosition(targetPosition)

        hrp.CFrame = protectedPosition
    end)

    return true
end

local protectionInitialized = InitializeAllProtections()

if not protectionInitialized then
    error("[SECURITY] Protection initialization failed - Script terminated")
    return
end

task.spawn(function()
    local checkCount = 0
    local criticalFailures = 0

    while true do
        task.wait(5)
        checkCount = checkCount + 1

        local trustScore = 0
        local trustCalcSuccess = pcall(function()
            trustScore = ZeroTrustModel:calculateTrustScore()
        end)

        if not trustCalcSuccess then
            criticalFailures = criticalFailures + 1
            warn("[SECURITY] ‚ö†Ô∏è Trust score calculation failed")
        elseif trustScore < 50 then
            criticalFailures = criticalFailures + 1
            warn("[SECURITY] ‚ö†Ô∏è Trust score critically low: " .. math.floor(trustScore) .. "%")
        end

        local integrityValid = false
        local integritySuccess = pcall(function()
            integrityValid = RuntimeIntegrity:validateFunctions()
        end)

        if not integritySuccess or not integrityValid then
            criticalFailures = criticalFailures + 1
            warn("[SECURITY] ‚ö†Ô∏è Integrity validation failed")
        end

        local tamperingDetected = false
        local tamperSuccess = pcall(function()
            tamperingDetected = AntiTamper:detectTampering()
        end)

        if not tamperSuccess then
            criticalFailures = criticalFailures + 1
            warn("[SECURITY] ‚ö†Ô∏è Tamper detection failed")
        elseif tamperingDetected then
            criticalFailures = criticalFailures + 2
            warn("[SECURITY] ‚ö†Ô∏è Tampering detected!")
        end

        local licenseValid = false
        local licenseSuccess = pcall(function()
            licenseValid = LicenseManager:isAuthenticated()
        end)

        if not licenseSuccess or not licenseValid then
            criticalFailures = criticalFailures + 1
            warn("[SECURITY] ‚ö†Ô∏è License authentication failed: " .. LicenseManager.keyStatus)
        end

        if checkCount % 10 == 0 then
            local envValid = false
            local envSuccess = pcall(function()
                envValid = EnvironmentValidator:validateEnvironment()
            end)

            if not envSuccess or not envValid then
                warn("[SECURITY] ‚ö†Ô∏è Environment validation failed - Risk: " .. EnvironmentValidator.riskLevel)
            end
        end

        if RuntimeIntegrity.selfDestruct then
            criticalFailures = criticalFailures + 5
            warn("[SECURITY] üõë Runtime Integrity in self-destruct mode!")
        end

        if AntiTamper.locked then
            criticalFailures = criticalFailures + 5
            warn("[SECURITY] üõë Anti-Tamper system locked!")
        end

        if AccessControl.currentRole == "LOCKED" then
            criticalFailures = criticalFailures + 5
            warn("[SECURITY] üõë Access Control locked!")
        end

        if criticalFailures >= 5 then
            warn("[SECURITY] üö® CRITICAL: Too many security failures detected!")
            warn("[SECURITY] üõë Script terminating for security reasons")
            warn(string.format("[SECURITY] Failures: %d | Trust: %d%% | Checks: %d",
                criticalFailures, math.floor(trustScore), checkCount))
            error("[SECURITY] Script terminated - Multiple critical failures")
        end

        if checkCount % 12 == 0 then
            print(string.format(
                "[SECURITY STATUS] Trust: %d%% | Threats: %d | Anomalies: %d | License: %s | Failures: %d",
                math.floor(trustScore),
                RASP.threatLevel,
                BehaviorMonitor.anomalyCount,
                LicenseManager.keyStatus,
                criticalFailures
            ))

            if criticalFailures > 0 and trustScore > 70 then
                criticalFailures = math.max(0, criticalFailures - 1)
            end
        end
    end
end)

print("‚úÖ License Status: " .. LicenseManager.keyStatus)
print("‚úÖ Environment Risk: " .. EnvironmentValidator.riskLevel)

local QuantumProtection = {
    enabled = true,
    shiftPosition = function(self, cf)
        if not self.enabled then return cf end
        local phase = tick() % 1
        local offset = Vector3.new(
            math.sin(phase * math.pi * 2) * 0.001,
            math.cos(phase * math.pi * 3) * 0.001,
            math.sin(phase * math.pi * 5) * 0.001
        )
        return cf + offset
    end
}
local MemoryEncryption = {
    enabled = true,
    key = math.random(1000000, 9999999),
    encrypt = function(self, value)
        if not self.enabled or type(value) ~= "number" then return value end
        local encrypted = bit32.bxor(value * 1000, self.key)
        encrypted = bit32.lrotate(encrypted, 13)
        return encrypted
    end,
    decrypt = function(self, encrypted)
        if not self.enabled or type(encrypted) ~= "number" then return encrypted end
        local value = bit32.rrotate(encrypted, 13)
        value = bit32.bxor(value, self.key) / 1000
        return value
    end,
    rotateKey = function(self)
        self.key = math.random(1000000, 9999999)
    end
}
task.spawn(function()
    while task.wait(60) do
        pcall(function()
            MemoryEncryption:rotateKey()
        end)
    end
end)
local AntiForensics = {
    enabled = true,
    cleanupTraces = function(self)
        if not self.enabled then return end
        pcall(function()
            if game.CoreGui then
                local devConsole = game.CoreGui:FindFirstChild("DevConsoleMaster")
                if devConsole then
                end
            end
        end)
    end,
    deleteFunction = function(self, funcName)
        if not self.enabled then return end
        pcall(function()
            _G[funcName] = nil
        end)
    end
}
local HeartbeatDesync = {
    enabled = true,
    createDesyncedLoop = function(self, func, interval)
        if not self.enabled then return end
        task.spawn(function()
            local lastTime = tick()
            while task.wait() do
                local now = tick()
                local delta = now - lastTime
                if delta >= interval + math.random(-interval * 0.2, interval * 0.2) then
                    pcall(func)
                    lastTime = now
                end
            end
        end)
    end
}
local lastCF, stop, heartbeatConnection
local teleportInProgress = false
local isRespawning = false
local CFrameProtection = {
    enabled = true,
    spoofedCFrames = {},
    maxSpoofCache = 15,
    lastSpoofTime = 0,
    spoofInterval = 0.1,
    createSpoof = function(self, realCF)
        if not self.enabled then return realCF end
        local offset = Vector3.new(
            math.random(-10, 10) / 10000,
            math.random(-10, 10) / 10000,
            math.random(-10, 10) / 10000
        )
        local spoofed = realCF + offset
        table.insert(self.spoofedCFrames, 1, {
            real = realCF,
            spoofed = spoofed,
            time = tick()
        })
        if #self.spoofedCFrames > self.maxSpoofCache then
            table.remove(self.spoofedCFrames)
        end
        return spoofed
    end,
    getRealCFrame = function(self, spoofed)
        for _, entry in ipairs(self.spoofedCFrames) do
            if entry.spoofed == spoofed then
                return entry.real
            end
        end
        return spoofed
    end
}
local MemoryProtection = {
    enabled = true,
    protectedValues = {},
    protect = function(self, key, value)
        if not self.enabled then return value end
        local protected = {}
        local seed = math.random(1000, 9999)
        protected.seed = seed
        protected.value = value
        self.protectedValues[key] = protected
        return protected
    end,
    unprotect = function(self, key)
        local protected = self.protectedValues[key]
        if not protected then return nil end
        return protected.value
    end
}
local HookProtection = {
    enabled = true,
    originalFunctions = {},
    hookedFunctions = {},
    initialize = function(self)
        if not self.enabled then return end
        self.originalFunctions = {
            getCFrame = function(part)
                return part.CFrame
            end,
            setCFrame = function(part, cf)
                part.CFrame = cf
            end,
            getVelocity = function(part)
                return part.Velocity or part.AssemblyLinearVelocity
            end
        }
    end,
    detectHook = function(self, functionName)
        return self.hookedFunctions[functionName] ~= nil
    end,
    callOriginal = function(self, functionName, ...)
        local original = self.originalFunctions[functionName]
        if original then
            return original(...)
        end
    end
}
local VelocityMask = {
    enabled = true,
    maxSafeVelocity = 50,
    maskVelocity = function(self, part)
        if not self.enabled or not part then return end
        local currentVel = part.AssemblyLinearVelocity or Vector3.new(0, 0, 0)
        local magnitude = currentVel.Magnitude
        if magnitude > self.maxSafeVelocity then
            local direction = currentVel.Unit
            part.AssemblyLinearVelocity = direction * self.maxSafeVelocity
            task.defer(function()
                if part and part.Parent then
                    part.AssemblyLinearVelocity = currentVel
                end
            end)
        end
    end
}
HookProtection:initialize()
local function startAntiKick()
    heartbeatConnection = RunService.Heartbeat:Connect(function()
        if stop or teleportInProgress then return end
        local character = LocalPlayer.Character
        if not character then return end
        local humanoid = character:FindFirstChildOfClass('Humanoid')
        if not humanoid then return end
        local rootPart = humanoid.RootPart
        if not rootPart then return end
        local currentCF = rootPart.CFrame
        local spoofedCF = CFrameProtection:createSpoof(currentCF)
        lastCF = MemoryProtection:protect("lastCF", spoofedCF)
        VelocityMask:maskVelocity(rootPart)
    end)
    local character = LocalPlayer.Character
    if not character then return end
    local humanoid = character:FindFirstChildOfClass('Humanoid')
    if not humanoid then return end
    local rootPart = humanoid.RootPart
    if rootPart then
        local isProcessing = false
        rootPart:GetPropertyChangedSignal('CFrame'):Connect(function()

            if teleportInProgress or isProcessing or isRespawning then return end
            isProcessing = true
            pcall(function()
                local protected = MemoryProtection:unprotect("lastCF")
                if rootPart and protected then
                    local realCF = CFrameProtection:getRealCFrame(protected)
                    stop = true
                    if HookProtection:detectHook("setCFrame") then
                        HookProtection:callOriginal("setCFrame", rootPart, realCF)
                    else
                        rootPart.CFrame = realCF
                    end
                    RunService.Heartbeat:Wait()
                    stop = false
                end
            end)
            isProcessing = false
        end)
    end
    humanoid.Died:Connect(function()
        if heartbeatConnection then
            heartbeatConnection:Disconnect()
        end
    end)
end
local function preserveJumpSpeed(hum)
    if not hum then return end
    hum.StateChanged:Connect(function(old, new)
        if new == Enum.HumanoidStateType.Jumping or new == Enum.HumanoidStateType.Freefall then
            task.spawn(function()
                task.wait()
                if not hum or not hum.Parent then return end
                local targetSpeed = OxyoSettings and OxyoSettings.Player and OxyoSettings.Player.WalkSpeed or 20
                hum.WalkSpeed = targetSpeed
                local rootPart = hum.Parent:FindFirstChild("HumanoidRootPart")
                if rootPart and rootPart:IsA("BasePart") then
                    local moveDir = hum.MoveDirection
                    if moveDir.Magnitude > 0.1 then
                        local currentVel = rootPart.Velocity
                        local horizontalVel = Vector3.new(currentVel.X, 0, currentVel.Z)
                        if horizontalVel.Magnitude < targetSpeed * 0.7 then
                            local boostVel = moveDir * targetSpeed * 0.9
                            rootPart.Velocity = Vector3.new(
                                boostVel.X,
                                currentVel.Y,
                                boostVel.Z
                            )
                        end
                    end
                end
            end)
        elseif new == Enum.HumanoidStateType.Landed then
            task.spawn(function()
                task.wait(0.05)
                if not hum or not hum.Parent then return end
                local targetSpeed = OxyoSettings and OxyoSettings.Player and OxyoSettings.Player.WalkSpeed or 20
                hum.WalkSpeed = targetSpeed
            end)
        end
    end)
end
LocalPlayer.CharacterAdded:Connect(function(character)

    isRespawning = true
    task.delay(2, function() isRespawning = false end)

    repeat
        RunService.Heartbeat:Wait()
    until character:FindFirstChildOfClass('Humanoid')
    repeat
        RunService.Heartbeat:Wait()
    until character:FindFirstChildOfClass('Humanoid').RootPart
    HookProtection:initialize()
    startAntiKick()
    local humanoid = character:FindFirstChildOfClass('Humanoid')
    if humanoid then
        preserveJumpSpeed(humanoid)
    end
end)
LocalPlayer.CharacterRemoving:Connect(function()
    if heartbeatConnection then
        heartbeatConnection:Disconnect()
    end
end)
if LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass('Humanoid') then
    task.spawn(startAntiKick)
    local humanoid = LocalPlayer.Character:FindFirstChildOfClass('Humanoid')
    if humanoid then
        preserveJumpSpeed(humanoid)
    end
end
local DeniabilityEngine = {
    decisionEngine = {
        enabled = true,
        acceptChance = 75,
        delayChance = 12,
        rejectChance = 8,
        alternativeChance = 5,
        adaptiveBehavior = true,
        suspicionThreshold = 60,
        lowSuspicionBonus = 10,
        lastDecision = 0,
        decisionHistory = {},
        maxHistory = 30,
        lastActionType = nil,
        sameActionCount = 0,
        maxSameActions = 3
    },
    justifications = {
        "Network latency compensation",
        "Server sync adjustment",
        "Packet loss recovery",
        "Collision resolution",
        "Physics correction",
        "Terrain adaptation",
        "Camera desync fix",
        "View angle correction",
        "Position validation",
        "Stuck detection",
        "Micro relocation",
        "Path correction",
        "Client-server reconciliation",
        "State synchronization"
    },
    failureSimulation = {
        enabled = true,
        postActionDelay = {0.05, 0.15},
        microCorrection = {
            enabled = true,
            chance = 55,
            intensity = {0.3, 0.7}
        },
        overshoot = {
            enabled = true,
            chance = 35,
            distance = {0.5, 1.5},
            recovery = 0.8
        },
        drift = {
            enabled = true,
            chance = 30,
            steps = {2, 4},
            intensity = {0.2, 0.5}
        },
        stutter = {
            enabled = true,
            chance = 20,
            magnitude = {0.1, 0.3},
            duration = 0.025
        },
        momentum = {
            enabled = true,
            chance = 25,
            velocity = {2, 6}
        }
    },
    memorySystem = {
        enabled = true,
        forgetChance = 50,
        modifyChance = 40,
        breakPatternAfter = 3,
        randomizeAfterBreak = true,
        shortTermMemory = {},
        maxMemory = 8,
        memoryDecay = true,
        decayRate = 0.15,
        lastDecayTime = tick()
    },
    disguise = {
        enabled = true,
        wrapInNoise = true,
        randomPrefix = {
            enabled = true,
            chance = 45,
            intensity = {0.5, 1.5}
        },
        randomSuffix = {
            enabled = true,
            chance = 45,
            intensity = {0.5, 1.2}
        },
        fakeAttempts = {
            enabled = true,
            chance = 25,
            count = {1, 2}
        },
        noiseInjection = {
            enabled = true,
            chance = 35,
            types = {"micro_jump", "rotation", "lean"}
        }
    },
    advancedProtection = {
        enabled = true,
        timingVariation = true,
        minDelay = 0.02,
        maxDelay = 0.12,
        contextAdaptation = true,
        distanceThresholds = {
            short = 15,
            medium = 50,
            long = 100
        },
        humanBehaviorMimicry = true,
        hesitationChance = 15,
        correctionChance = 20
    }
}
local function makeDecision(actionType)
    local decision = DeniabilityEngine.decisionEngine
    if not decision.enabled then return "accept" end
    if decision.lastActionType == actionType then
        decision.sameActionCount = decision.sameActionCount + 1
    else
        decision.lastActionType = actionType
        decision.sameActionCount = 1
    end
    local patternModifier = 0
    if decision.sameActionCount >= decision.maxSameActions then
        patternModifier = -20
        decision.sameActionCount = 0
    end
    local suspicionModifier = 0
    local currentSuspicion = 0
    if decision.adaptiveBehavior then
        if AntiDetection and AntiDetection.suspicionLevel then
            currentSuspicion = AntiDetection.suspicionLevel
        end
        if currentSuspicion < decision.suspicionThreshold then
            suspicionModifier = decision.lowSuspicionBonus
        else
            suspicionModifier = -10
        end
    end
    local adjustedAccept = math.max(30, math.min(90,
        decision.acceptChance + suspicionModifier + patternModifier
    ))
    local roll = math.random(1, 100)
    local result
    if roll <= adjustedAccept then
        result = "accept"
    elseif roll <= (adjustedAccept + decision.delayChance) then
        result = "delay"
    elseif roll <= (adjustedAccept + decision.delayChance + decision.rejectChance) then
        result = "reject"
    else
        result = "alternative"
    end
    table.insert(decision.decisionHistory, {
        action = actionType,
        decision = result,
        time = tick(),
        suspicionLevel = currentSuspicion,
        patternCount = decision.sameActionCount
    })
    if #decision.decisionHistory > decision.maxHistory then
        table.remove(decision.decisionHistory, 1)
    end
    return result
end
local function getJustification()
    local justifications = DeniabilityEngine.justifications
    local preferredIndices = {}
    if math.random(1, 100) <= 40 then
        table.insert(preferredIndices, 1)
        table.insert(preferredIndices, 2)
        table.insert(preferredIndices, 3)
        table.insert(preferredIndices, 14)
    end
    if #preferredIndices > 0 and math.random(1, 100) <= 60 then
        return justifications[preferredIndices[math.random(1, #preferredIndices)]]
    end
    return justifications[math.random(1, #justifications)]
end
local function simulateFailure(rootPart, targetPos)
    if not DeniabilityEngine.failureSimulation.enabled then return end
    task.spawn(function()
        local fs = DeniabilityEngine.failureSimulation
        local delay = randomFloat(fs.postActionDelay[1], fs.postActionDelay[2])
        task.wait(delay)
        if fs.microCorrection.enabled and math.random(1, 100) <= fs.microCorrection.chance then
            local intensity = randomFloat(fs.microCorrection.intensity[1], fs.microCorrection.intensity[2])
            local offset = Vector3.new(
                randomFloat(-intensity, intensity),
                randomFloat(-intensity * 0.4, intensity * 0.4),
                randomFloat(-intensity, intensity)
            )
            rootPart.CFrame = rootPart.CFrame + offset
            task.wait(0.03)
        end
        if fs.overshoot.enabled and math.random(1, 100) <= fs.overshoot.chance then
            local distance = randomFloat(fs.overshoot.distance[1], fs.overshoot.distance[2])
            local overshoot = Vector3.new(
                randomFloat(-distance, distance),
                0,
                randomFloat(-distance, distance)
            )
            rootPart.CFrame = rootPart.CFrame + overshoot
            task.wait(0.06)
            rootPart.CFrame = rootPart.CFrame - (overshoot * fs.overshoot.recovery)
        end
        if fs.drift.enabled and math.random(1, 100) <= fs.drift.chance then
            local steps = math.random(fs.drift.steps[1], fs.drift.steps[2])
            local intensity = randomFloat(fs.drift.intensity[1], fs.drift.intensity[2])
            local drift = Vector3.new(
                randomFloat(-intensity, intensity),
                0,
                randomFloat(-intensity, intensity)
            )
            for i = 1, steps do
                rootPart.CFrame = rootPart.CFrame + (drift / steps)
                task.wait(0.03)
            end
        end
        if fs.stutter.enabled and math.random(1, 100) <= fs.stutter.chance then
            local magnitude = randomFloat(fs.stutter.magnitude[1], fs.stutter.magnitude[2])
            local currentCF = rootPart.CFrame
            rootPart.CFrame = currentCF - Vector3.new(magnitude, 0, magnitude)
            task.wait(fs.stutter.duration)
            rootPart.CFrame = currentCF
        end
        if fs.momentum.enabled and math.random(1, 100) <= fs.momentum.chance then
            local velocity = randomFloat(fs.momentum.velocity[1], fs.momentum.velocity[2])
            local direction = Vector3.new(randomFloat(-1, 1), 0, randomFloat(-1, 1)).Unit
            rootPart.Velocity = direction * velocity
            task.wait(0.08)
            rootPart.Velocity = Vector3.new(0, 0, 0)
        end
    end)
end
local function processMemory(actionData)
    if not DeniabilityEngine.memorySystem.enabled then return actionData end
    local memory = DeniabilityEngine.memorySystem
    if memory.memoryDecay then
        local now = tick()
        local timeSinceDecay = now - memory.lastDecayTime
        if timeSinceDecay > 1.0 then
            memory.lastDecayTime = now
            for i = #memory.shortTermMemory, 1, -1 do
                if math.random(1, 100) <= (memory.decayRate * 100) then
                    table.remove(memory.shortTermMemory, i)
                end
            end
        end
    end
    if #memory.shortTermMemory >= memory.breakPatternAfter then
        if memory.randomizeAfterBreak and math.random(1, 100) <= 70 then
            actionData.pattern = "broken"
            actionData.randomSeed = math.random(1, 9999)
        end
    end
    if math.random(1, 100) <= memory.forgetChance then
        actionData.details = "forgotten"
        actionData.timestamp = nil
    end
    if math.random(1, 100) <= memory.modifyChance then
        actionData.behavior = "modified"
        actionData.variance = math.random(1, 999)
    end
    table.insert(memory.shortTermMemory, actionData)
    if #memory.shortTermMemory > memory.maxMemory then
        table.remove(memory.shortTermMemory, 1)
    end
    return actionData
end
local function disguiseAction(rootPart, callback)
    if not DeniabilityEngine.disguise.enabled then
        callback()
        return
    end
    local disguise = DeniabilityEngine.disguise
    if disguise.randomPrefix.enabled and math.random(1, 100) <= disguise.randomPrefix.chance then
        local intensity = randomFloat(disguise.randomPrefix.intensity[1], disguise.randomPrefix.intensity[2])
        local randomMove = Vector3.new(
            randomFloat(-intensity, intensity),
            randomFloat(-intensity * 0.5, intensity * 0.5),
            randomFloat(-intensity, intensity)
        )
        rootPart.CFrame = rootPart.CFrame + randomMove
        task.wait(randomFloat(0.04, 0.1))
    end
    if disguise.fakeAttempts.enabled and math.random(1, 100) <= disguise.fakeAttempts.chance then
        local count = math.random(disguise.fakeAttempts.count[1], disguise.fakeAttempts.count[2])
        for i = 1, count do
            local fakeCF = rootPart.CFrame
            rootPart.CFrame = fakeCF + Vector3.new(randomFloat(-2, 2), 0, randomFloat(-2, 2))
            task.wait(0.06)
            rootPart.CFrame = fakeCF
            task.wait(0.03)
        end
    end
    if disguise.noiseInjection.enabled and math.random(1, 100) <= disguise.noiseInjection.chance then
        local noiseType = disguise.noiseInjection.types[math.random(1, #disguise.noiseInjection.types)]
        if noiseType == "micro_jump" then
            rootPart.CFrame = rootPart.CFrame + Vector3.new(0, randomFloat(0.3, 1.0), 0)
            task.wait(0.04)
        elseif noiseType == "rotation" then
            local rot = CFrame.Angles(0, math.rad(randomFloat(-20, 20)), 0)
            rootPart.CFrame = rootPart.CFrame * rot
        elseif noiseType == "lean" then
            local lean = Vector3.new(randomFloat(-0.5, 0.5), 0, 0)
            rootPart.CFrame = rootPart.CFrame + lean
            task.wait(0.03)
        end
    end
    callback()
    if disguise.randomSuffix.enabled and math.random(1, 100) <= disguise.randomSuffix.chance then
        task.wait(randomFloat(0.05, 0.12))
        local intensity = randomFloat(disguise.randomSuffix.intensity[1], disguise.randomSuffix.intensity[2])
        local randomMove = Vector3.new(
            randomFloat(-intensity, intensity),
            randomFloat(-intensity * 0.4, intensity * 0.4),
            randomFloat(-intensity, intensity)
        )
        rootPart.CFrame = rootPart.CFrame + randomMove
    end
end
local AntiDetection = {
    lastSpeedChange = 0,
    lastJumpChange = 0,
    lastTeleport = 0,
    speedChangeCount = 0,
    jumpCount = 0,
    teleportCount = 0,
    suspicionLevel = 0,
    maxSuspicion = 100,
    cooldowns = {
        speedChange = 3.5,
        jump = 1.2,
        teleport = 12,
        noclip = 7
    },
    humanBehavior = {
        enabled = true,
        microStops = true,
        randomSlowdowns = true,
        naturalJumps = true,
        accelerationDelay = true,
        momentumSimulation = true
    }
}
local function updateSuspicion(action, amount)
    AntiDetection.suspicionLevel = clamp(AntiDetection.suspicionLevel + amount, 0, AntiDetection.maxSuspicion)
    if AntiDetection.suspicionLevel > 70 then
        return true
    end
    return false
end
task.spawn(function()
    while true do
        task.wait(5)
        AntiDetection.suspicionLevel = math.max(0, AntiDetection.suspicionLevel - 3)
    end
end)
local SpeedProtection = {
    smoothingEnabled = true,
    smoothingFactor = 0.06,
    humanVariance = true,
    varianceRange = {0.96, 1.04},
    microPauses = true,
    pauseChance = 3,
    spoofToServer = true,
    reportedSpeed = 16,
    bypassSpeedChecks = true,
    randomSpeedVariation = true,
    lastSpeedUpdate = 0,
    speedUpdateDelay = 0.12,
    gradualAcceleration = true,
    maxAcceleration = 3,
    currentVelocity = 16,
    momentumDecay = 0.94,
    antiSnapDetection = true,
    lastReportedSpeed = 16,
    maxSpeedDelta = 3,
    microStutters = true,
    stutterChance = 4,
    stutterIntensity = 0.92,
    breathingPattern = true,
    breathingCycle = 0,
    breathingSpeed = 0.25,
    breathingAmplitude = 0.025,
    footstepSync = true,
    lastFootstep = 0,
    staminaSimulation = true,
    stamina = 100,
    staminaDrain = 0.3,
    staminaRecover = 1.2,
    terrainAdaptation = true,
    terrainSlowdown = 0.85,
    walkingPatterns = true,
    directionChangeSlowdown = true,
    lastDirection = Vector3.new(0, 0, 0),
    turnSlowdown = 0.88,
    sprintFatigue = true,
    fatigueThreshold = 40,
    recoveryDelay = 2,
    lastRecovery = 0,
    packetThrottling = true,
    maxPacketsPerSecond = 30,
    lastPacketTime = 0,
    packetCount = 0,
    speedHistory = {},
    historySize = 10,
    averageSpeed = 16,
    maxSpeedSpike = 8
}
local function getHumanizedSpeed(targetSpeed)
    if not AntiDetection.humanBehavior.enabled then
        return targetSpeed
    end
    local variance = randomFloat(0.97, 1.03)
    local humanSpeed = targetSpeed * variance
    if SpeedProtection.breathingPattern then
        SpeedProtection.breathingCycle = SpeedProtection.breathingCycle + SpeedProtection.breathingSpeed
        local breathingEffect = math.sin(SpeedProtection.breathingCycle) * SpeedProtection.breathingAmplitude
        humanSpeed = humanSpeed * (1 + breathingEffect)
    end
    if SpeedProtection.staminaSimulation and targetSpeed > 22 then
        SpeedProtection.stamina = math.max(0, SpeedProtection.stamina - SpeedProtection.staminaDrain * 0.08)
        if SpeedProtection.sprintFatigue and SpeedProtection.stamina < SpeedProtection.fatigueThreshold then
            local fatigueMultiplier = 1 - ((SpeedProtection.fatigueThreshold - SpeedProtection.stamina) / SpeedProtection.fatigueThreshold) * 0.15
            humanSpeed = humanSpeed * fatigueMultiplier
        end
        local staminaMultiplier = 1 - ((100 - SpeedProtection.stamina) / 100) * 0.04
        humanSpeed = humanSpeed * staminaMultiplier
    else
        local now = tick()
        if now - SpeedProtection.lastRecovery > SpeedProtection.recoveryDelay then
            SpeedProtection.stamina = math.min(100, SpeedProtection.stamina + SpeedProtection.staminaRecover * 0.15)
        end
    end
    if SpeedProtection.microStutters and math.random(1, 100) <= SpeedProtection.stutterChance then
        humanSpeed = humanSpeed * SpeedProtection.stutterIntensity
    end
    if SpeedProtection.directionChangeSlowdown and LocalPlayer.Character then
        local rootPart = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        if rootPart then
            local currentDirection = rootPart.CFrame.LookVector
            local dotProduct = currentDirection:Dot(SpeedProtection.lastDirection)
            if dotProduct < 0.7 and SpeedProtection.lastDirection.Magnitude > 0 then
                humanSpeed = humanSpeed * SpeedProtection.turnSlowdown
            end
            SpeedProtection.lastDirection = currentDirection
        end
    end
    if SpeedProtection.terrainAdaptation and LocalPlayer.Character then
        local hum = LocalPlayer.Character:FindFirstChild("Humanoid")
        if hum and hum.FloorMaterial then
            if hum.FloorMaterial == Enum.Material.Grass or
               hum.FloorMaterial == Enum.Material.Sand or
               hum.FloorMaterial == Enum.Material.Snow then
                humanSpeed = humanSpeed * SpeedProtection.terrainSlowdown
            end
        end
    end
    table.insert(SpeedProtection.speedHistory, humanSpeed)
    if #SpeedProtection.speedHistory > SpeedProtection.historySize then
        table.remove(SpeedProtection.speedHistory, 1)
    end
    local sum = 0
    for _, spd in ipairs(SpeedProtection.speedHistory) do
        sum = sum + spd
    end
    SpeedProtection.averageSpeed = sum / #SpeedProtection.speedHistory
    if math.abs(humanSpeed - SpeedProtection.averageSpeed) > SpeedProtection.maxSpeedSpike then
        humanSpeed = SpeedProtection.averageSpeed + (humanSpeed - SpeedProtection.averageSpeed) * 0.3
    end
    return humanSpeed
end
local function getHumanizedJump(targetJump)
    if not AntiDetection.humanBehavior.enabled then
        return targetJump
    end
    local variance = randomFloat(0.98, 1.02)
    local humanJump = targetJump * variance
    return humanJump
end
safeCall(function()
    local oldIndex
    oldIndex = hookmetamethod(game, "__index", function(self, key)
        if key == "WalkSpeed" and self:IsA("Humanoid") and self.Parent == LocalPlayer.Character then
            if SpeedProtection.spoofToServer then
                local baseReport = SpeedProtection.reportedSpeed + randomFloat(-1.5, 1.5)
                local breathingVar = math.sin(SpeedProtection.breathingCycle * 0.5) * 0.8
                local fakeSpeed = baseReport + breathingVar
                SpeedProtection.lastReportedSpeed = fakeSpeed
                return fakeSpeed
            end
        end
        if (key == "Velocity" or key == "AssemblyLinearVelocity") and self:IsA("BasePart") and self.Parent == LocalPlayer.Character then
            if SpeedProtection.spoofToServer then
                local realVel = oldIndex(self, key)
                local reducedVel = Vector3.new(
                    realVel.X * 0.6,
                    realVel.Y,
                    realVel.Z * 0.6
                )
                return reducedVel
            end
        end
        return oldIndex(self, key)
    end)
end)
safeCall(function()
    local oldNewIndex
    oldNewIndex = hookmetamethod(game, "__newindex", function(self, key, value)
        if key == "WalkSpeed" and self:IsA("Humanoid") and self.Parent == LocalPlayer.Character then
            if SpeedProtection.antiSnapDetection then
                local delta = math.abs(value - SpeedProtection.lastReportedSpeed)
                if delta > SpeedProtection.maxSpeedDelta then
                    value = SpeedProtection.lastReportedSpeed + (SpeedProtection.maxSpeedDelta * (value > SpeedProtection.lastReportedSpeed and 1 or -1))
                end
                SpeedProtection.lastReportedSpeed = value
            end
            return oldNewIndex(self, key, value)
        end
        if key == "CFrame" and self:IsA("BasePart") and self.Name == "HumanoidRootPart" and self.Parent == LocalPlayer.Character then
            if not teleportInProgress then
                local currentCF = self.CFrame
                local distance = (currentCF.Position - value.Position).Magnitude
                if distance > 10 then
                    local direction = (value.Position - currentCF.Position).Unit
                    local smoothedPos = currentCF.Position + (direction * math.min(distance, 8))
                    value = CFrame.new(smoothedPos) * (value - value.Position)
                end
            end
        end
        return oldNewIndex(self, key, value)
    end)
end)
local JumpProtection = {
    cooldownEnabled = true,
    minCooldown = 1.0,
    humanVariance = true,
    varianceRange = {0.90, 1.10},
    maxJumpsPerMinute = 20,
    jumpHistory = {},
    spoofToServer = true,
    reportedPower = 50,
    bypassJumpChecks = true,
    randomJumpVariation = true,
    lastJumpTime = 0,
    antiSpamProtection = true,
    minJumpInterval = 0.8,
    lastReportedPower = 50,
    maxPowerDelta = 5
}
safeCall(function()
    local oldIndex
    oldIndex = hookmetamethod(game, "__index", function(self, key)
        if key == "JumpPower" and self:IsA("Humanoid") and self.Parent == LocalPlayer.Character then
            if JumpProtection.spoofToServer then
                local fakePower = JumpProtection.reportedPower + randomFloat(-2, 2)
                JumpProtection.lastReportedPower = fakePower
                return fakePower
            end
        end
        if key == "JumpHeight" and self:IsA("Humanoid") and self.Parent == LocalPlayer.Character then
            if JumpProtection.spoofToServer then
                return 7.2 + randomFloat(-0.3, 0.3)
            end
        end
        return oldIndex(self, key)
    end)
end)
safeCall(function()
    local oldNewIndex
    oldNewIndex = hookmetamethod(game, "__newindex", function(self, key, value)
        if (key == "JumpPower" or key == "JumpHeight") and self:IsA("Humanoid") and self.Parent == LocalPlayer.Character then
            if JumpProtection.antiSpamProtection and key == "JumpPower" then
                local delta = math.abs(value - JumpProtection.lastReportedPower)
                if delta > 30 and (tick() - (JumpProtection.lastChangeTime or 0)) < 0.1 then
                    value = JumpProtection.lastReportedPower + (30 * (value > JumpProtection.lastReportedPower and 1 or -1))
                end
                JumpProtection.lastReportedPower = value
                JumpProtection.lastChangeTime = tick()
            end
            return oldNewIndex(self, key, value)
        end
        return oldNewIndex(self, key, value)
    end)
end)
local function canJump()
    local now = tick()
    for i = #JumpProtection.jumpHistory, 1, -1 do
        if now - JumpProtection.jumpHistory[i] > 60 then
            table.remove(JumpProtection.jumpHistory, i)
        end
    end
    if #JumpProtection.jumpHistory >= JumpProtection.maxJumpsPerMinute then
        return false
    end
    if JumpProtection.antiSpamProtection then
        if now - JumpProtection.lastJumpTime < JumpProtection.minJumpInterval then
            return false
        end
    end
    table.insert(JumpProtection.jumpHistory, now)
    JumpProtection.lastJumpTime = now
    return true
end
local QuantumNoclip = {
    enabled = false,
    quantumSpeed = 0.03,
    lastQuantumTime = 0,
    stateFlip = false,
    randomizedTiming = true,
    minInterval = 0.02,
    maxInterval = 0.08,
    quantumToggle = function(self, part)
        return
    end
}
local RaycastSpoofer = {
    enabled = true,
    fakeRaycastChance = 35,
    rayOrigins = {},
    createFakeRaycast = function(self, character)
        if not self.enabled or math.random(1, 100) > self.fakeRaycastChance then return end
        local rootPart = character:FindFirstChild("HumanoidRootPart")
        if not rootPart then return end
        local origin = rootPart.Position
        local direction = Vector3.new(
            randomFloat(-1, 1),
            randomFloat(-0.5, 0.5),
            randomFloat(-1, 1)
        ).Unit * randomFloat(3, 8)
        pcall(function()
            local rayParams = RaycastParams.new()
            rayParams.FilterDescendantsInstances = {character}
            rayParams.FilterType = Enum.RaycastFilterType.Blacklist
            workspace:Raycast(origin, direction, rayParams)
        end)
    end
}
local PhysicsSimulator = {
    enabled = false,
    gravitySimulation = true,
    collisionResponse = true,
    bounceEffect = true,
    simulatePhysics = function(self, rootPart)
        return
    end
}
local AdminDetector = {
    enabled = true,
    adminNames = {"admin", "mod", "moderator", "owner", "developer", "dev"},
    detectedAdmins = {},
    pauseOnAdmin = true,
    checkForAdmins = function(self)
        if not self.enabled then return false end
        for _, player in pairs(Players:GetPlayers()) do
            local name = player.Name:lower()
            local displayName = player.DisplayName:lower()
            for _, adminKeyword in pairs(self.adminNames) do
                if name:find(adminKeyword) or displayName:find(adminKeyword) then
                    if not self.detectedAdmins[player.UserId] then
                        self.detectedAdmins[player.UserId] = true
                    end
                    return true
                end
            end
            pcall(function()
                if player:FindFirstChild("leaderstats") then
                    local rank = player.leaderstats:FindFirstChild("Rank")
                    if rank and (rank.Value:find("Admin") or rank.Value:find("Mod")) then
                        self.detectedAdmins[player.UserId] = true
                        return true
                    end
                end
            end)
        end
        return false
    end
}
local AntiLog = {
    enabled = true,
    blockRemoteEvents = true,
    spoofLogs = true,
    blockLogging = function(self)
        if not self.enabled then return end
        pcall(function()
            for _, remote in pairs(game:GetDescendants()) do
                if remote:IsA("RemoteEvent") or remote:IsA("RemoteFunction") then
                    local name = remote.Name:lower()
                    if name:find("log") or name:find("report") or name:find("anti") or name:find("detect") then
                        pcall(function()
                            if remote.FireServer then
                                local old = remote.FireServer
                                remote.FireServer = function() end
                            end
                        end)
                    end
                end
            end
        end)
    end
}
local PacketManipulator = {
    enabled = true,
    spoofPackets = true,
    delayPackets = true,
    packetDelay = {0.01, 0.05},
    manipulatePacket = function(self, action)
        if not self.enabled then return end
        if self.delayPackets and math.random(1, 100) <= 40 then
            local delay = randomFloat(self.packetDelay[1], self.packetDelay[2])
            task.wait(delay)
        end
    end
}
local CollisionMimicker = {
    enabled = false,
    naturalPattern = true,
    walkThroughWalls = true,
    mimicCollision = function(self, part, rootPart)
        return
    end
}
local AdvancedHookProtection = {
    enabled = true,
    originalFunctions = {},
    hookDetected = false,
    initialize = function(self)
        if not self.enabled then return end
        pcall(function()
            self.originalFunctions.getfenv = getfenv
            self.originalFunctions.setfenv = setfenv
            self.originalFunctions.debug = debug
            local testPart = Instance.new("Part")
            self.originalFunctions.CanCollide_get = testPart.CanCollide
            testPart:Destroy()
        end)
    end,
    detectHooks = function(self, part)
        if not self.enabled then return false end
        pcall(function()
            local env = getfenv(0)
            if env and env._G then
                for k, v in pairs(env._G) do
                    if type(k) == "string" then
                        if k:find("anti") or k:find("detect") or k:find("log") then
                            self.hookDetected = true
                        end
                    end
                end
            end
        end)
        return self.hookDetected
    end,
    bypassHook = function(self, part)
        if not self.enabled then return end
        pcall(function()
            rawset(part, "CanCollide", false)
        end)
    end
}
AdvancedHookProtection:initialize()
AntiLog:blockLogging()
local CollisionSpoof = {
    enabled = true,
    spoofInterval = 0.15,
    lastSpoofTime = 0,
    stateHistory = {},
    maxHistory = 20,
    dynamicToggle = false,
    toggleChance = 25,
    minToggleDuration = 0.08,
    maxToggleDuration = 0.25,
    originalStates = {},
    createSpoof = function(self, part)
        if not self.enabled then return end
        local currentState = part.CanCollide
        table.insert(self.stateHistory, 1, {part = part, state = currentState, time = tick()})
        if #self.stateHistory > self.maxHistory then table.remove(self.stateHistory) end
    end,
    saveOriginalState = function(self, part)
        if not self.originalStates[part] then
            self.originalStates[part] = part.CanCollide
        end
    end,
    restoreOriginalState = function(self, part)
        if self.originalStates[part] ~= nil then
            part.CanCollide = self.originalStates[part]
        end
    end
}
local NoclipHookProtection = {
    enabled = true,
    protectedParts = {},
    hookedConnections = {},
    protectPart = function(self, part)
        if not self.enabled or self.protectedParts[part] then return end
        self.protectedParts[part] = {originalCanCollide = part.CanCollide, protected = true}
        pcall(function()
            local connections = getconnections(part:GetPropertyChangedSignal("CanCollide"))
            for _, connection in pairs(connections) do
                if connection and connection.Disable then
                    pcall(function()
                        connection:Disable()
                        table.insert(self.hookedConnections, connection)
                    end)
                end
            end
        end)
    end,
    unprotectPart = function(self, part)
        if not self.protectedParts[part] then return end
        if self.protectedParts[part].originalCanCollide ~= nil then
            pcall(function() part.CanCollide = self.protectedParts[part].originalCanCollide end)
        end
        self.protectedParts[part] = nil
    end,
    cleanup = function(self)
        for _, connection in pairs(self.hookedConnections) do
            pcall(function()
                if connection and connection.Enable then connection:Enable() end
            end)
        end
        for part, _ in pairs(self.protectedParts) do
            self:unprotectPart(part)
        end
        self.hookedConnections = {}
    end
}
local NoclipVelocityMask = {
    enabled = true,
    maxSafeVelocity = 40,
    positionHistory = {},
    maxPositionHistory = 10,
    maskVelocity = function(self, rootPart)
        if not self.enabled or not rootPart then return end
        local currentVel = rootPart.AssemblyLinearVelocity or Vector3.new(0, 0, 0)
        local magnitude = currentVel.Magnitude
        if magnitude > self.maxSafeVelocity then
            local direction = currentVel.Unit
            rootPart.AssemblyLinearVelocity = direction * self.maxSafeVelocity
            task.defer(function()
                if rootPart and rootPart.Parent then
                    rootPart.AssemblyLinearVelocity = currentVel
                end
            end)
        end
    end,
    trackPosition = function(self, rootPart)
        if not self.enabled or not rootPart then return end
        table.insert(self.positionHistory, 1, {position = rootPart.Position, time = tick()})
        if #self.positionHistory > self.maxPositionHistory then
            table.remove(self.positionHistory)
        end
    end,
    simulateNaturalMovement = function(self, rootPart)
        if not self.enabled or not rootPart then return end
        local microOffset = Vector3.new(randomFloat(-0.05, 0.05), randomFloat(-0.02, 0.02), randomFloat(-0.05, 0.05))
        pcall(function() rootPart.CFrame = rootPart.CFrame + microOffset end)
    end
}
local SmartNoclipSystem = {
    enabled = true,
    usePausePattern = true,
    pauseChance = 20,
    minPauseDuration = 0.15,
    maxPauseDuration = 0.6,
    useIntermittent = true,
    skipChance = 35,
    autoDisable = true,
    maxContinuousDuration = 25,
    detectPlayerNearby = true,
    nearbyPlayerRadius = 50,
    increaseSkipWhenNearby = true,
    nearbySkipBonus = 25,
    detectMovementSpeed = true,
    highSpeedThreshold = 30,
    pauseOnHighSpeed = true,
    activationTime = 0,
    isPaused = false,
    pauseEndTime = 0,
    checkNearbyPlayers = function(self)
        if not self.detectPlayerNearby then return false end
        local char = LocalPlayer.Character
        if not char then return false end
        local rootPart = char:FindFirstChild("HumanoidRootPart")
        if not rootPart then return false end
        for _, player in pairs(Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Character then
                local otherRoot = player.Character:FindFirstChild("HumanoidRootPart")
                if otherRoot then
                    local distance = (rootPart.Position - otherRoot.Position).Magnitude
                    if distance < self.nearbyPlayerRadius then return true end
                end
            end
        end
        return false
    end,
    checkHighSpeed = function(self, rootPart)
        if not self.detectMovementSpeed or not rootPart then return false end
        local velocity = rootPart.AssemblyLinearVelocity or Vector3.new(0, 0, 0)
        return velocity.Magnitude > self.highSpeedThreshold
    end,
    getDynamicSkipChance = function(self)
        local baseChance = self.skipChance
        if self.increaseSkipWhenNearby and self:checkNearbyPlayers() then
            baseChance = baseChance + self.nearbySkipBonus
        end
        return math.min(baseChance, 80)
    end,
    shouldPause = function(self, rootPart)
        local now = tick()
        if self.isPaused then
            if now >= self.pauseEndTime then
                self.isPaused = false
                return false
            end
            return true
        end
        if self.usePausePattern and math.random(1, 100) <= self.pauseChance then
            self.isPaused = true
            self.pauseEndTime = now + randomFloat(self.minPauseDuration, self.maxPauseDuration)
            return true
        end
        if self.pauseOnHighSpeed and self:checkHighSpeed(rootPart) then
            self.isPaused = true
            self.pauseEndTime = now + randomFloat(0.2, 0.4)
            return true
        end
        return false
    end,
    shouldSkip = function(self)
        if not self.useIntermittent then return false end
        local dynamicChance = self:getDynamicSkipChance()
        return math.random(1, 100) <= dynamicChance
    end,
    checkDurationLimit = function(self)
        if not self.autoDisable then return false end
        local now = tick()
        local duration = now - self.activationTime
        return duration > self.maxContinuousDuration
    end
}
local NoclipProtection = {
    intermittent = true,
    skipChance = 30,
    autoDisable = true,
    maxDuration = 20,
    activationTime = 0,
    spoofCollision = true,
    blockCollisionLogs = true,
    smartMode = true,
    randomizePattern = true,
    pausePattern = true,
    pauseChance = 15,
    minPauseDuration = 0.2,
    maxPauseDuration = 0.8
}
safeCall(function()
    if LocalPlayer.Character then
        for _, part in pairs(LocalPlayer.Character:GetDescendants()) do
            if part:IsA("BasePart") then
                pcall(function()
                    local connections = getconnections(part:GetPropertyChangedSignal("CanCollide"))
                    for _, connection in pairs(connections) do
                        pcall(function() connection:Disable() end)
                    end
                end)
            end
        end
    end
end)
local noclipConnection
local noclipPaused = false
local pauseEndTime = 0
local noclipActive = false
local function toggleNoclip(enabled)
    if noclipConnection then
        noclipConnection:Disconnect()
        noclipConnection = nil
    end
    if not enabled then
        NoclipHookProtection:cleanup()
        noclipActive = false
        if LocalPlayer.Character then
            for _, part in pairs(LocalPlayer.Character:GetDescendants()) do
                if part:IsA("BasePart") then
                    CollisionSpoof:restoreOriginalState(part)
                    part.CanCollide = true
                end
            end
        end
        return
    end
    noclipActive = true
    NoclipProtection.activationTime = tick()
    noclipConnection = RunService.Stepped:Connect(function()
        if not LocalPlayer.Character then return end
        local rootPart = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        if not rootPart then return end
        local character = LocalPlayer.Character
        if AdminDetector:checkForAdmins() and AdminDetector.pauseOnAdmin then
            for _, part in pairs(character:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = true
                end
            end
            return
        end
        PacketManipulator:manipulatePacket("noclip")
        RaycastSpoofer:createFakeRaycast(character)
        PhysicsSimulator:simulatePhysics(rootPart)
        if NoclipVelocityMask then
            NoclipVelocityMask:maskVelocity(rootPart)
            NoclipVelocityMask:trackPosition(rootPart)
            if math.random(1, 100) <= 15 then
                NoclipVelocityMask:simulateNaturalMovement(rootPart)
            end
        end
        for _, part in pairs(character:GetDescendants()) do
            if part:IsA("BasePart") then
                pcall(function()
                    NoclipQuantum:applyPhaseShift({part})
                end)
                if AdvancedHookProtection:detectHooks(part) then
                    AdvancedHookProtection:bypassHook(part)
                end
                NoclipHookProtection:protectPart(part)
                QuantumNoclip:quantumToggle(part)
                CollisionMimicker:mimicCollision(part, rootPart)
                CollisionSpoof:saveOriginalState(part)
                CollisionSpoof:createSpoof(part)
                part.CanCollide = false
                pcall(function()
                    rawset(part, "CanCollide", false)
                end)
            end
        end
        pcall(function()
            if NoclipQuantum:applyQuantumTunnel(rootPart) then
            end
        end)
    end)
end
local instantTeleport
local TeleportSafetyTracker = {
    teleportsInLastMinute = 0,
    lastMinuteReset = tick(),
    maxTeleportsPerMinute = 999,
    warningShown = false,
    lastTeleportPositions = {},
    maxPositionHistory = 5,
    minDistanceBetweenTPs = 50,
    suspicionScore = 0,
    maxSuspicion = 100,
    teleportPatterns = {},
    lastTeleportDirection = Vector3.new(0, 0, 0),
    sameDirectionCount = 0,
    maxSameDirection = 2,
    lastTeleportDuration = 0,
    avgTeleportDuration = 0,
    teleportDurations = {},
    maxDurationHistory = 10,
    checkForNearbyPlayers = true,
    minPlayerDistance = 100,
    checkLineOfSight = true
}
local function isPatternSafe()
    if TeleportSafetyTracker.sameDirectionCount >= TeleportSafetyTracker.maxSameDirection then
        return false, "Pattern detected: Same direction spam"
    end
    if TeleportSafetyTracker.suspicionScore >= TeleportSafetyTracker.maxSuspicion then
        return false, "Suspicion score too high"
    end
    return true, "Safe"
end
local function checkEnvironmentSafety(targetPosition)
    if not TeleportSafetyTracker.checkForNearbyPlayers then
        return true
    end
    local nearbyPlayerCount = 0
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character then
            local hrp = player.Character:FindFirstChild("HumanoidRootPart")
            if hrp then
                local distance = (hrp.Position - targetPosition).Magnitude
                if distance < TeleportSafetyTracker.minPlayerDistance then
                    nearbyPlayerCount = nearbyPlayerCount + 1
                    if TeleportSafetyTracker.checkLineOfSight then
                        local ray = Ray.new(targetPosition, (hrp.Position - targetPosition).Unit * distance)
                        local hit = workspace:FindPartOnRay(ray, LocalPlayer.Character)
                        if not hit or hit.Parent == player.Character then
                            return false, "Player nearby with line of sight"
                        end
                    end
                end
            end
        end
    end
    if nearbyPlayerCount > 2 then
        return false, "Too many players nearby"
    end
    return true, "Environment safe"
end
local PlayerSpoofing = {
    enabled = true,
    spoofChance = 60,
    lastSpoofTime = 0,
    spoofCooldown = 2,
    currentSpoofedPlayer = nil,
    spoofHistory = {},
    maxHistorySize = 20,
    availablePlayers = {},
    lastPlayerUpdate = 0,
    playerUpdateInterval = 5,
    blacklistedUserIds = {},
    blacklistedNames = {},
}
function PlayerSpoofing:updateAvailablePlayers()
    local now = tick()
    if now - self.lastPlayerUpdate < self.playerUpdateInterval then return end
    self.lastPlayerUpdate = now
    self.availablePlayers = {}
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            local isBlacklisted = false
            for _, uid in pairs(self.blacklistedUserIds) do
                if player.UserId == uid then
                    isBlacklisted = true
                    break
                end
            end
            for _, name in pairs(self.blacklistedNames) do
                if player.Name:lower():find(name:lower()) then
                    isBlacklisted = true
                    break
                end
            end

            pcall(function()
                if player and player.Parent and player:IsA("Player") then
                    if player:GetRankInGroup(0) > 200 then
                        isBlacklisted = true
                    end
                end
            end)
            pcall(function()
                if player:FindFirstChild("leaderstats") then
                    local rank = player.leaderstats:FindFirstChild("Rank")
                    if rank and (rank.Value == "Admin" or rank.Value == "Moderator") then
                        isBlacklisted = true
                    end
                end
            end)
            if not isBlacklisted then
                table.insert(self.availablePlayers, player)
            end
        end
    end
end
function PlayerSpoofing:selectRandomPlayer()
    self:updateAvailablePlayers()
    if #self.availablePlayers == 0 then return nil end
    local randomIndex = math.random(1, #self.availablePlayers)
    local selectedPlayer = self.availablePlayers[randomIndex]
    table.insert(self.spoofHistory, 1, {
        player = selectedPlayer,
        time = tick(),
        userId = selectedPlayer.UserId,
        name = selectedPlayer.Name
    })
    if #self.spoofHistory > self.maxHistorySize then
        table.remove(self.spoofHistory)
    end
    return selectedPlayer
end
function PlayerSpoofing:shouldSpoof()
    if not self.enabled then return false end
    local now = tick()
    if now - self.lastSpoofTime < self.spoofCooldown then return false end
    if math.random(1, 100) <= self.spoofChance then
        self.lastSpoofTime = now
        return true
    end
    return false
end
function PlayerSpoofing:getSpoofedPlayer()
    if self:shouldSpoof() then
        self.currentSpoofedPlayer = self:selectRandomPlayer()
    end
    return self.currentSpoofedPlayer or LocalPlayer
end
local MovementProtection = {
    microStepping = {
        enabled = true,
        stepSize = 2,
        stepDelay = 0.03,
    },
    jitterPattern = {
        enabled = true,
        intensity = 0.15,
        frequency = 0.1,
        lastJitter = 0,
    },
    naturalFatigue = {
        enabled = true,
        fatigueRate = 0.02,
        recoveryRate = 0.01,
        currentFatigue = 0,
        maxFatigue = 0.3,
    },
    inputMimicking = {
        enabled = true,
        keyPressDelay = 0.05,
        lastKeyPress = 0,
        simulatedKeys = {"W", "A", "S", "D", "Space"},
    },
    antiPattern = {
        enabled = true,
        maxSameValue = 3,
        sameValueCount = 0,
        lastValue = 0,
        variationRange = 2,
    },
}
function MovementProtection:applyMicroStepping(currentValue, targetValue)
    if not self.microStepping.enabled then return targetValue end
    local difference = targetValue - currentValue
    if math.abs(difference) <= self.microStepping.stepSize then
        return targetValue
    end
    local step = self.microStepping.stepSize * (difference > 0 and 1 or -1)
    return currentValue + step
end
function MovementProtection:applyJitter(value)
    if not self.jitterPattern.enabled then return value end
    local now = tick()
    if now - self.jitterPattern.lastJitter < self.jitterPattern.frequency then
        return value
    end
    self.jitterPattern.lastJitter = now
    local jitter = value * self.jitterPattern.intensity * (math.random() - 0.5) * 2
    return value + jitter
end
function MovementProtection:applyFatigue(value, dt)
    if not self.naturalFatigue.enabled then return value end
    if value > 30 then
        self.naturalFatigue.currentFatigue = math.min(
            self.naturalFatigue.maxFatigue,
            self.naturalFatigue.currentFatigue + self.naturalFatigue.fatigueRate * dt
        )
    else
        self.naturalFatigue.currentFatigue = math.max(
            0,
            self.naturalFatigue.currentFatigue - self.naturalFatigue.recoveryRate * dt
        )
    end
    local fatigueMultiplier = 1 - self.naturalFatigue.currentFatigue
    return value * fatigueMultiplier
end
function MovementProtection:breakPattern(value)
    if not self.antiPattern.enabled then return value end
    if math.abs(value - self.antiPattern.lastValue) < 0.5 then
        self.antiPattern.sameValueCount = self.antiPattern.sameValueCount + 1
        if self.antiPattern.sameValueCount >= self.antiPattern.maxSameValue then
            local variation = math.random(-self.antiPattern.variationRange, self.antiPattern.variationRange)
            self.antiPattern.sameValueCount = 0
            return value + variation
        end
    else
        self.antiPattern.sameValueCount = 0
    end
    self.antiPattern.lastValue = value
    return value
end
local NoclipQuantum = {
    phaseShifting = {
        enabled = true,
        phaseInterval = 0.015,
        lastPhase = 0,
        currentPhase = true,
    },
    quantumTunneling = {
        enabled = true,
        tunnelDistance = 0.5,
        tunnelChance = 25,
    },
    wallRiding = {
        enabled = true,
        edgeOffset = 0.3,
        rideSpeed = 0.8,
    },
    glitchExploitation = {
        enabled = true,
        glitchChance = 15,
        glitchTypes = {"corner_clip", "ceiling_boost", "floor_phase"},
    },
}
function NoclipQuantum:applyPhaseShift(parts)
    if not self.phaseShifting.enabled then return end
    local now = tick()
    if now - self.phaseShifting.lastPhase < self.phaseShifting.phaseInterval then
        return
    end
    self.phaseShifting.lastPhase = now
    self.phaseShifting.currentPhase = not self.phaseShifting.currentPhase
    for _, part in pairs(parts) do
        if part:IsA("BasePart") then
            pcall(function()
                part.CanCollide = self.phaseShifting.currentPhase
            end)
        end
    end
end
function NoclipQuantum:applyQuantumTunnel(rootPart)
    if not self.quantumTunneling.enabled then return false end
    if math.random(1, 100) > self.quantumTunneling.tunnelChance then
        return false
    end
    local lookVector = rootPart.CFrame.LookVector
    local tunnelOffset = lookVector * self.quantumTunneling.tunnelDistance
    pcall(function()
        rootPart.CFrame = rootPart.CFrame + tunnelOffset
    end)
    return true
end
local TeleportUltra = {
    multiHop = {
        enabled = true,
        maxHops = 3,
        hopDistance = 50,
        hopDelay = 0.08,
    },
    pathRandomization = {
        enabled = true,
        deviationAngle = 45,
        deviationChance = 40,
    },
    speedCapping = {
        enabled = true,
        maxTeleportSpeed = 200,
        slowdownFactor = 0.6,
    },
    delayedExecution = {
        enabled = true,
        minDelay = 0.05,
        maxDelay = 0.15,
    },
}
function TeleportUltra:applyMultiHop(startPos, endPos, callback)
    if not self.multiHop.enabled then
        callback(endPos)
        return
    end
    local distance = (endPos - startPos).Magnitude
    if distance < self.multiHop.hopDistance then
        callback(endPos)
        return
    end
    local numHops = math.min(
        self.multiHop.maxHops,
        math.floor(distance / self.multiHop.hopDistance)
    )
    local direction = (endPos - startPos).Unit
    local currentPos = startPos
    task.spawn(function()
        for i = 1, numHops do
            local hopDistance = distance / (numHops + 1 - i)
            local nextPos = currentPos + (direction * math.min(hopDistance, self.multiHop.hopDistance))
            if self.pathRandomization.enabled and math.random(1, 100) <= self.pathRandomization.deviationChance then
                local randomAngle = math.rad(math.random(-self.pathRandomization.deviationAngle, self.pathRandomization.deviationAngle))
                local deviation = Vector3.new(
                    math.cos(randomAngle) * 5,
                    math.random(-2, 2),
                    math.sin(randomAngle) * 5
                )
                nextPos = nextPos + deviation
            end
            callback(nextPos)
            task.wait(self.multiHop.hopDelay)
            currentPos = nextPos
        end
        callback(endPos)
    end)
end
function TeleportUltra:getRandomDelay()
    if not self.delayedExecution.enabled then return 0 end
    return math.random() * (self.delayedExecution.maxDelay - self.delayedExecution.minDelay) + self.delayedExecution.minDelay
end
local function executeWithSpoofing(actionType, callback)
    local spoofedPlayer = PlayerSpoofing:getSpoofedPlayer()
    if spoofedPlayer ~= LocalPlayer then
        print("[Spoof] Action '" .. actionType .. "' attributed to: " .. spoofedPlayer.Name)
    end
    pcall(callback, spoofedPlayer)
end
local function protectRemotes()
    local oldFireServer = Instance.new("RemoteEvent").FireServer
    local oldInvokeServer = Instance.new("RemoteFunction").InvokeServer
    local mt = getrawmetatable(game)
    local oldNamecall = mt.__namecall
    setreadonly(mt, false)
    mt.__namecall = newcclosure(function(self, ...)
        local method = getnamecallmethod()
        local args = {...}
        if method == "FireServer" or method == "InvokeServer" then
            if PlayerSpoofing:shouldSpoof() and #args > 0 then
                local spoofedPlayer = PlayerSpoofing:getSpoofedPlayer()
                for i, arg in ipairs(args) do
                    if typeof(arg) == "Instance" and arg:IsA("Player") and arg == LocalPlayer then
                        args[i] = spoofedPlayer
                    end
                end
            end
        end
        return oldNamecall(self, unpack(args))
    end)
    setreadonly(mt, true)
end
pcall(protectRemotes)
print("[Oxyo] Player Spoofing: " .. (PlayerSpoofing.enabled and "ACTIVE" or "DISABLED"))
local function updateTeleportPattern(fromPos, toPos)
    local direction = (toPos - fromPos).Unit
    if TeleportSafetyTracker.lastTeleportDirection.Magnitude > 0 then
        local dotProduct = direction:Dot(TeleportSafetyTracker.lastTeleportDirection)
        if dotProduct > 0.9 then
            TeleportSafetyTracker.sameDirectionCount = TeleportSafetyTracker.sameDirectionCount + 1
            TeleportSafetyTracker.suspicionScore = TeleportSafetyTracker.suspicionScore + 15
        else
            TeleportSafetyTracker.sameDirectionCount = 0
            TeleportSafetyTracker.suspicionScore = math.max(0, TeleportSafetyTracker.suspicionScore - 5)
        end
    end
    TeleportSafetyTracker.lastTeleportDirection = direction
    table.insert(TeleportSafetyTracker.lastTeleportPositions, toPos)
    if #TeleportSafetyTracker.lastTeleportPositions > TeleportSafetyTracker.maxPositionHistory then
        table.remove(TeleportSafetyTracker.lastTeleportPositions, 1)
    end
end
local function updateTeleportDuration(duration)
    table.insert(TeleportSafetyTracker.teleportDurations, duration)
    if #TeleportSafetyTracker.teleportDurations > TeleportSafetyTracker.maxDurationHistory then
        table.remove(TeleportSafetyTracker.teleportDurations, 1)
    end
    local sum = 0
    for _, d in ipairs(TeleportSafetyTracker.teleportDurations) do
        sum = sum + d
    end
    TeleportSafetyTracker.avgTeleportDuration = sum / #TeleportSafetyTracker.teleportDurations
end
task.spawn(function()
    while true do
        task.wait(10)
        TeleportSafetyTracker.suspicionScore = math.max(0, TeleportSafetyTracker.suspicionScore - 3)
    end
end)
local function checkTeleportSafety()
    local now = tick()
    if now - TeleportSafetyTracker.lastMinuteReset > 60 then
        TeleportSafetyTracker.teleportsInLastMinute = 0
        TeleportSafetyTracker.lastMinuteReset = now
        TeleportSafetyTracker.warningShown = false
    end
    if TeleportSafetyTracker.teleportsInLastMinute >= TeleportSafetyTracker.maxTeleportsPerMinute then
        return false
    end
    local patternSafe, patternReason = isPatternSafe()
    if not patternSafe then
        showNotification("Pattern Detected", patternReason, 3)
        return false
    end
    return true
end

local function findSafePosition(targetPos)

    local rayOrigin = targetPos + Vector3.new(0, 50, 0)
    local rayDirection = Vector3.new(0, -200, 0)
    local raycastParams = RaycastParams.new()
    raycastParams.FilterType = Enum.RaycastFilterType.Exclude
    raycastParams.FilterDescendantsInstances = {LocalPlayer.Character}

    local result = workspace:Raycast(rayOrigin, rayDirection, raycastParams)

    if result and result.Position.Y > -10 then

        local safeY = result.Position.Y + randomFloat(4, 6)
        print("[Safety] Ground found at Y = " .. result.Position.Y .. ", placing at Y = " .. safeY)
        return Vector3.new(targetPos.X, safeY, targetPos.Z), true
    end

    local searchRadius = 20
    for angle = 0, 360, 45 do
        local rad = math.rad(angle)
        local searchX = targetPos.X + math.cos(rad) * searchRadius
        local searchZ = targetPos.Z + math.sin(rad) * searchRadius

        local searchOrigin = Vector3.new(searchX, targetPos.Y + 50, searchZ)
        result = workspace:Raycast(searchOrigin, rayDirection, raycastParams)

        if result and result.Position.Y > -10 then
            local safeY = result.Position.Y + randomFloat(4, 6)
            print("[Safety] Found ground nearby at angle " .. angle .. "¬∞, Y = " .. safeY)
            return Vector3.new(searchX, safeY, searchZ), true
        end
    end

    local defaultSafeY = math.max(targetPos.Y, 100)
    print("[Safety] ‚ö†Ô∏è No ground found! Using default safe height: Y = " .. defaultSafeY)
    return Vector3.new(targetPos.X, defaultSafeY, targetPos.Z), false
end
local PlayerProtection = {
    maxSafeSpeed = 100,
    maxSafeJump = 100,
    speedWarningShown = false,
    jumpWarningShown = false
}
local MovementController = {
    targetSpeed = 16,
    targetJump = 50,
    currentSpeed = 16,
    currentJump = 50,
    lastUpdate = 0,
    smoothingFactor = 0.10,
    naturalPauses = false,
    microAdjustments = true,
    acceleration = 0,
    maxAcceleration = 5,
    momentumEnabled = true,
    velocitySmoothing = true
}

local function restoreSpeed()
    pcall(function()
        local target = OxyoSettings and OxyoSettings.Player and OxyoSettings.Player.WalkSpeed or 24

        MovementController.targetSpeed = target
        MovementController.currentSpeed = target

        SpeedProtection.lastReportedSpeed = target
        SpeedProtection.reportedSpeed = target
        SpeedProtection.currentVelocity = target
        SpeedProtection.averageSpeed = target

        local char = LocalPlayer.Character
        if char then
            local hum = char:FindFirstChildOfClass("Humanoid")
            if hum then
                hum.WalkSpeed = target
            end
        end
    end)
end

local function updateMovement(hum)
    if not hum then return end
    local now = tick()
    if now - MovementController.lastUpdate < 0.08 then return end
    local dt = now - MovementController.lastUpdate
    MovementController.lastUpdate = now
    local humanSpeed = getHumanizedSpeed(MovementController.targetSpeed)
    local humanJump = getHumanizedJump(MovementController.targetJump)
    humanSpeed = MovementProtection:applyMicroStepping(MovementController.currentSpeed, humanSpeed)
    humanSpeed = MovementProtection:applyJitter(humanSpeed)
    humanSpeed = MovementProtection:applyFatigue(humanSpeed, dt)
    humanSpeed = MovementProtection:breakPattern(humanSpeed)
    if SpeedProtection.gradualAcceleration then
        local speedDiff = humanSpeed - MovementController.currentSpeed
        local maxChange = SpeedProtection.maxAcceleration * dt
        if math.abs(speedDiff) > maxChange then
            speedDiff = maxChange * (speedDiff > 0 and 1 or -1)
        end
        MovementController.currentSpeed = MovementController.currentSpeed + speedDiff
    else
        MovementController.currentSpeed = MovementController.currentSpeed + (humanSpeed - MovementController.currentSpeed) * MovementController.smoothingFactor
    end
    MovementController.currentJump = humanJump
    hum.WalkSpeed = clamp(MovementController.currentSpeed, 16, 150)
    hum.UseJumpPower = true
    hum.JumpPower = clamp(MovementController.currentJump, 50, 100)
    pcall(function()
        hum.JumpHeight = clamp(MovementController.currentJump / 7, 7.2, 21.4)
    end)
end
getgenv().Toggle = false
getgenv().TC = false
local PlayerName = "Name"
local P = game:GetService("Players")
local LP = P.LocalPlayer
local DB = false
task.spawn(function()
    while true do
        task.wait(0.5)
        if not getgenv().Toggle then
            for i, v in pairs(P:GetChildren()) do
                if v:IsA("Player") and v ~= LP and v.Character then
                    local esp = v.Character:FindFirstChild("Totally NOT Esp")
                    local icon = v.Character:FindFirstChild("Icon")
                    if esp then pcall(function() esp:Destroy() end) end
                    if icon then pcall(function() icon:Destroy() end) end
                end
            end
            task.wait(0.5)
            continue
        end
        if DB then
            task.wait()
            continue
        end
        DB = true
        pcall(function()
            for i,v in pairs(P:GetChildren()) do
                if v:IsA("Player") then
                    if v ~= LP then
                        if v.Character and v.Character:FindFirstChild("HumanoidRootPart") and LP.Character and LP.Character:FindFirstChild("HumanoidRootPart") then
                            local pos = math.floor(((LP.Character:FindFirstChild("HumanoidRootPart")).Position - (v.Character:FindFirstChild("HumanoidRootPart")).Position).magnitude)
                            if v.Character:FindFirstChild("Totally NOT Esp") == nil and v.Character:FindFirstChild("Icon") == nil and getgenv().TC == false then
                                local ESP = Instance.new("Highlight", v.Character)
                                ESP.Name = "Totally NOT Esp"
                                ESP.Adornee = v.Character
                                ESP.Archivable = true
                                ESP.Enabled = true
                                ESP.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
                                ESP.FillColor = v.TeamColor.Color
                                ESP.FillTransparency = 0.5
                                ESP.OutlineColor = Color3.fromRGB(255, 255, 255)
                                ESP.OutlineTransparency = 0
                                local Icon = Instance.new("BillboardGui", v.Character)
                                local ESPText = Instance.new("TextLabel")
                                Icon.Name = "Icon"
                                Icon.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
                                Icon.Active = true
                                Icon.AlwaysOnTop = true
                                Icon.ExtentsOffset = Vector3.new(0, 1, 0)
                                Icon.LightInfluence = 1.000
                                Icon.Size = UDim2.new(0, 800, 0, 50)
                                ESPText.Name = "ESP Text"
                                ESPText.Parent = Icon
                                ESPText.BackgroundColor3 = v.TeamColor.Color
                                ESPText.BackgroundTransparency = 1.000
                                ESPText.Size = UDim2.new(0, 800, 0, 50)
                                ESPText.Font = Enum.Font.SciFi
                                ESPText.Text = v[PlayerName].." | Distance: "..pos
                                ESPText.TextColor3 = v.TeamColor.Color
                                ESPText.TextSize = 18.000
                                ESPText.TextWrapped = true
                            else
                                if v.TeamColor ~= LP.TeamColor and v.Character:FindFirstChild("Totally NOT Esp") == nil and v.Character:FindFirstChild("Icon") == nil and getgenv().TC == true then
                                    local ESP = Instance.new("Highlight", v.Character)
                                    ESP.Name = "Totally NOT Esp"
                                    ESP.Adornee = v.Character
                                    ESP.Archivable = true
                                    ESP.Enabled = true
                                    ESP.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
                                    ESP.FillColor = v.TeamColor.Color
                                    ESP.FillTransparency = 0.5
                                    ESP.OutlineColor = Color3.fromRGB(255, 255, 255)
                                    ESP.OutlineTransparency = 0
                                    local Icon = Instance.new("BillboardGui", v.Character)
                                    local ESPText = Instance.new("TextLabel")
                                    Icon.Name = "Icon"
                                    Icon.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
                                    Icon.Active = true
                                    Icon.AlwaysOnTop = true
                                    Icon.ExtentsOffset = Vector3.new(0, 1, 0)
                                    Icon.LightInfluence = 1.000
                                    Icon.Size = UDim2.new(0, 800, 0, 50)
                                    ESPText.Name = "ESP Text"
                                    ESPText.Parent = Icon
                                    ESPText.BackgroundColor3 = v.TeamColor.Color
                                    ESPText.BackgroundTransparency = 1.000
                                    ESPText.Size = UDim2.new(0, 800, 0, 50)
                                    ESPText.Font = Enum.Font.SciFi
                                    ESPText.Text = v[PlayerName].." | Distance: "..pos
                                    ESPText.TextColor3 = v.TeamColor.Color
                                    ESPText.TextSize = 18.000
                                    ESPText.TextWrapped = true
                                else
                                    if v.Character:FindFirstChild("Totally NOT Esp") and v.Character:FindFirstChild("Icon") then
                                        if v.Character:FindFirstChild("Totally NOT Esp").FillColor ~= v.TeamColor.Color then
                                            v.Character:FindFirstChild("Totally NOT Esp").FillColor = v.TeamColor.Color
                                        end
                                        if v.Character:FindFirstChild("Icon")["ESP Text"].TextColor3 ~= v.TeamColor.Color then
                                            v.Character:FindFirstChild("Icon")["ESP Text"].TextColor3 = v.TeamColor.Color
                                        end
                                        if v.Character:FindFirstChild("Totally NOT Esp").Enabled == false then
                                            v.Character:FindFirstChild("Totally NOT Esp").Enabled = true
                                        end
                                        if v.Character:FindFirstChild("Icon").Enabled == false then
                                            v.Character:FindFirstChild("Icon").Enabled = true
                                        end
                                        if v.Character:FindFirstChild("Icon") then
                                            v.Character:FindFirstChild("Icon")["ESP Text"].Text = v[PlayerName].." | Distance: "..pos
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end)
        task.wait()
        DB = false
    end
end)
local Stats = {
    hookFailures = 0,
    hookSuccesses = 0,
    rehookAttempts = 0,
    teleportAttempts = 0,
    teleportRollbacks = 0,
    espDraws = 0,
    silentAimHits = 0,
    lastError = nil,
    suspicionEvents = 0
}
local OxyoSettings = {
    ESP = {
        Enabled = true,
        Boxes = true,
        Names = true,
        Health = true,
        Distance = true,
        Chams = false,
        Tracers = false,
        MaxDrawings = 120,
        MaxDistance = 3000,
        SmoothingEnabled = true,
        SmoothingFactor = 0.35,
        PredictiveSmoothing = true,
        AdaptiveQuality = true
    },
    Player = {
        WalkSpeed = 24,
        JumpPower = 50,
        InfJump = false,
        AutoJump = false,
        Noclip = false
    },
    SilentAim = {
        Enabled = false,
        HitChance = 100,
        FOVEnabled = true,
        FOVSize = 100,
        FOVColor = Color3.fromRGB(255, 255, 255),
        TeamCheck = true,
        TargetPart = "Head"
    },
    Protection = {
        RehookAttempts = 5,
        Humanize = true,
        MicroOffsetRange = 0.18,
        DelayVariance = 0.025,
        RehookBackoff = { base = 0.6, factor = 1.3, max = 6 }
    }
}
local function sanitizeSettings()
    OxyoSettings.SilentAim.HitChance = clamp(OxyoSettings.SilentAim.HitChance, 0, 100)
    OxyoSettings.SilentAim.FOVSize = clamp(OxyoSettings.SilentAim.FOVSize, 10, 800)
    OxyoSettings.ESP.MaxDrawings = clamp(OxyoSettings.ESP.MaxDrawings, 20, 1000)
    OxyoSettings.Protection.MicroOffsetRange = clamp(OxyoSettings.Protection.MicroOffsetRange, 0, 2)
    OxyoSettings.Protection.DelayVariance = clamp(OxyoSettings.Protection.DelayVariance, 0, 0.2)
    OxyoSettings.Player.JumpPower = clamp(OxyoSettings.Player.JumpPower, 50, 100)
    OxyoSettings.ESP.SmoothingFactor = clamp(OxyoSettings.ESP.SmoothingFactor, 0.05, 1)
end
sanitizeSettings()
local function validatePlayerSettings()
    if OxyoSettings.Player.WalkSpeed > PlayerProtection.maxSafeSpeed then
        if not PlayerProtection.speedWarningShown then
            print("[Oxyo] High speed detected!")
            PlayerProtection.speedWarningShown = true
            task.delay(60, function() PlayerProtection.speedWarningShown = false end)
        end
    end
    if OxyoSettings.Player.JumpPower > PlayerProtection.maxSafeJump then
        if not PlayerProtection.jumpWarningShown then
            print("[Oxyo] High jump detected!")
            PlayerProtection.jumpWarningShown = true
            task.delay(60, function() PlayerProtection.jumpWarningShown = false end)
        end
    end
end
task.spawn(function()
    while true do
        task.wait(5)
        validatePlayerSettings()
    end
end)
local function bypassLogs()
    safeCall(function()
        local oldNamecall
        oldNamecall = hookmetamethod(game, "__namecall", function(self, ...)
            local method = getnamecallmethod()

            if self and self.Name and typeof(self.Name) == "string" then

                if isWhitelisted(self.Name) then
                    return oldNamecall(self, ...)
                end

                local remoteName = self.Name:lower()

                local suspiciousNames = {
                    "anticheat", "anticheese", "cheatdetect", "hackdetect",
                    "exploitdetect", "reportcheater", "reportplayer",
                    "flagplayer", "analytics", "telemetry",
                    "logplayer", "logaction", "trackplayer", "trackmovement"
                }
                for _, pattern in ipairs(suspiciousNames) do
                    if remoteName:find(pattern, 1, true) then
                        return
                    end
                end

                if method == "FireServer" or method == "InvokeServer" then
                    local args = {...}
                    if typeof(args[1]) == "string" then
                        local arg = args[1]:lower()
                        if isWhitelisted(arg) then
                            return oldNamecall(self, ...)
                        end
                        local blockedStringArgs = {
                            "exploit", "cheat", "hack",
                            "detect", "anticheat", "suspicious",
                            "banned", "violation"
                        }
                        for _, word in ipairs(blockedStringArgs) do
                            if arg:find(word, 1, true) then
                                return
                            end
                        end
                    end
                end
            end

            return oldNamecall(self, ...)
        end)
    end)
end
safeCall(bypassLogs)
do
    local old_ipairs = ipairs
    local old_pairs = pairs
    ipairs = function(t)
        if t == nil or type(t) ~= "table" then
            return function() end, nil, nil
        end
        return old_ipairs(t)
    end
    pairs = function(t)
        if t == nil or type(t) ~= "table" then
            return function() end, nil, nil
        end
        return old_pairs(t)
    end
    _G.ipairs = ipairs
    _G.pairs = pairs
    local env = getfenv(0)
    if env then
        env.ipairs = ipairs
        env.pairs = pairs
    end
end
print("[Oxyo] ipairs/pairs protection loaded")
local Rayfield
safeCall(function() Rayfield = loadstring(game:HttpGet("https://sirius.menu/rayfield"))() end)
if not Rayfield then
    Rayfield = {}
    function Rayfield:CreateWindow(_) return {
        CreateTab = function() return {
            CreateToggle = function() end,
            CreateSlider = function() end,
            CreateDropdown = function() end,
            CreateSection = function() end,
            CreateColorPicker = function() end,
            CreateButton = function() end,
        } end
    } end
end

_G.Rayfield = Rayfield

local _loadErrors = {}

local function _validateLoad()

    local Players = game:GetService("Players")
    if not Players or not Players.LocalPlayer then
        table.insert(_loadErrors, "LocalPlayer ÿ∫Ÿäÿ± ŸÖŸàÿ¨ŸàÿØ")
    end

    if not Rayfield or not Rayfield.CreateWindow then
        table.insert(_loadErrors, "Rayfield ŸÅÿ¥ŸÑ ŸÅŸä ÿßŸÑÿ™ÿ≠ŸÖŸäŸÑ")
    end

    if not hookmetamethod then
        table.insert(_loadErrors, "hookmetamethod ÿ∫Ÿäÿ± ŸÖÿ™ÿßÿ≠ ‚Äî ÿßÿ≥ÿ™ÿÆÿØŸÖ executor ŸäÿØÿπŸÖŸá")
    end

    if not checkcaller then
        table.insert(_loadErrors, "checkcaller ÿ∫Ÿäÿ± ŸÖÿ™ÿßÿ≠")
    end

    if not getrawmetatable then
        table.insert(_loadErrors, "getrawmetatable ÿ∫Ÿäÿ± ŸÖÿ™ÿßÿ≠")
    end

    return #_loadErrors == 0
end

if not _validateLoad() then

    for _, err in ipairs(_loadErrors) do
        pcall(function()
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "‚ùå Oxyo ‚Äî ŸÅÿ¥ŸÑ ÿßŸÑÿ™ÿ≠ŸÖŸäŸÑ",
                Text = err,
                Duration = 10
            })
        end)
        task.wait(0.3)
    end

    error("[Oxyo] ‚ùå Script aborted ‚Äî " .. table.concat(_loadErrors, " | "), 0)
end

local Window = Rayfield:CreateWindow({
    Name = "Oxyo | Prison Life",
    LoadingTitle = "Oxyo Enhanced",
    LoadingSubtitle = "by mohammad",
    ConfigurationSaving = { Enabled = true, FolderName = "OxyoConfigs", FileName = "MainConfigV5_4_Fixed" },
    KeySystem = false,
    Discord = {
        Enabled = false
    }
})
local function showNotification(title, message, duration)
    pcall(function()
        if Rayfield and Rayfield.Notify then
            Rayfield:Notify({
                Title = title or "Oxyo",
                Content = message or "",
                Duration = duration or 3,
                Image = nil
            })
        end
    end)
end
local function toggleUI()
    pcall(function()
        game:GetService("VirtualInputManager"):SendKeyEvent(true, Enum.KeyCode.RightControl, false, game)
        game:GetService("VirtualInputManager"):SendKeyEvent(false, Enum.KeyCode.RightControl, false, game)
    end)
end
local function destroyUI()
    pcall(function()
        for _, gui in pairs(game:GetService("CoreGui"):GetChildren()) do
            if gui.Name == "Rayfield" or gui.Name:find("Rayfield") then
                gui:Destroy()
            end
        end
        for _, gui in pairs(game:GetService("CoreGui"):GetDescendants()) do
            if gui:IsA("ScreenGui") and (gui.Name == "Rayfield" or gui.Name:find("Rayfield")) then
                gui:Destroy()
            end
        end
        local playerGui = LocalPlayer:FindFirstChild("PlayerGui")
        if playerGui then
            for _, gui in pairs(playerGui:GetChildren()) do
                if gui.Name == "Rayfield" or gui.Name:find("Rayfield") then
                    gui:Destroy()
                end
            end
        end
    end)
end
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.KeyCode == Enum.KeyCode.Delete then
        destroyUI()
        print("[Oxyo] UI destroyed!")
    elseif input.KeyCode == Enum.KeyCode.RightShift then
        toggleUI()
        print("[Oxyo] UI toggled!")
    elseif input.KeyCode == Enum.KeyCode.Home then
        pcall(function()
            for _, v in pairs(game.CoreGui:GetDescendants()) do
                if v:IsA("TextButton") and v.Text == "X" then
                    for i = 1, 2 do
                        v.MouseButton1Click:Fire()
                    end
                end
            end
        end)
    end
end)
print("[Oxyo] RIGHT SHIFT = Toggle | DELETE = Close | HOME = Force Close")
local function safeCreateTab(name, icon)
    local ok, tab = pcall(function() return Window:CreateTab(name, icon) end)
    if ok and tab then return tab end
    return {
        CreateToggle = function() end,
        CreateSlider = function() end,
        CreateDropdown = function() end,
        CreateSection = function() end,
        CreateColorPicker = function() end,
        CreateButton = function() end
    }
end
local SilentAimTab = safeCreateTab("Silent aim", "target")
local ESPTab = safeCreateTab("ESP", "eye")
local PlayerTab = safeCreateTab("Player", "user")
local GunModTab = safeCreateTab("Gun Mod", "crosshair")
local TeleportTab = safeCreateTab("Teleport", "navigation")
local GunsTab = safeCreateTab("Guns", "zap")
local AtmosphereTab = safeCreateTab("üåü Atmosphere", "sparkles")
local UITab = safeCreateTab("UI", "settings")

local AdvancedTeleportSystem = {

    ServerIsolation = {
        enabled = true,
        fakePosition = nil,
        realPosition = nil,
        spoofActive = false,
        updateRate = 0.05,
        lastUpdate = 0,

        spoofRange = 50,
        lastSpoofChange = 0,
        spoofChangeInterval = 2,

        initialize = function(self, hrp)
            if not hrp then return false end

            local randomOffset = Vector3.new(
                math.random(-self.spoofRange, self.spoofRange),
                math.random(-10, 10),
                math.random(-self.spoofRange, self.spoofRange)
            )
            self.fakePosition = hrp.CFrame + randomOffset
            self.realPosition = hrp.CFrame
            return true
        end,

        startSpoofing = function(self, hrp)
            if not self.enabled or self.spoofActive then return end
            self.spoofActive = true

            if not self._hookCreated then
                self._hookCreated = true
                pcall(function()
                    local oldNamecall = nil
                    oldNamecall = hookmetamethod(game, "__namecall", function(...)
                        local method = getnamecallmethod()
                        local self_obj = ({...})[1]

                        if (method == "FireServer" or method == "InvokeServer") and self.spoofActive then
                            if self_obj and (self_obj:IsA("RemoteEvent") or self_obj:IsA("RemoteFunction")) then
                                local name = self_obj.Name:lower()

                                if isWhitelisted(name) then
                                    return oldNamecall(...)
                                end

                                if name:find("position") or name:find("cframe") or
                                   name:find("velocity") or name:find("physics") then
                                    local args = {...}
                                    for i, arg in ipairs(args) do
                                        if typeof(arg) == "CFrame" then
                                            args[i] = self.fakePosition
                                        elseif typeof(arg) == "Vector3" then
                                            args[i] = self.fakePosition.Position
                                        end
                                    end
                                    return oldNamecall(unpack(args))
                                end
                            end
                        end

                        return oldNamecall(...)
                    end)
                end)
            end

            task.spawn(function()
                while self.spoofActive do
                    local now = tick()

                    if now - self.lastSpoofChange >= self.spoofChangeInterval then
                        self.lastSpoofChange = now
                        local bigMove = Vector3.new(
                            math.random(-self.spoofRange, self.spoofRange),
                            math.random(-5, 5),
                            math.random(-self.spoofRange, self.spoofRange)
                        )
                        self.fakePosition = self.fakePosition + bigMove
                    end

                    if now - self.lastUpdate >= self.updateRate then
                        self.lastUpdate = now

                        if math.random(1, 100) <= 40 then
                            local microMove = Vector3.new(
                                (math.random(-5, 5) / 1000) * math.random(1, 3),
                                0,
                                (math.random(-5, 5) / 1000) * math.random(1, 3)
                            )
                            self.fakePosition = self.fakePosition + microMove
                        end
                    end
                    task.wait(self.updateRate)
                end
            end)
        end,

        stopSpoofing = function(self)
            self.spoofActive = false
        end,

        updateReal = function(self, cframe)
            self.realPosition = cframe
        end
    },

    AntiDetection = {
        enabled = true,

        PatternAnalysis = {
            teleportHistory = {},
            maxHistory = 20,
            suspicionLevel = 0,
            maxSuspicion = 100,

            recordTeleport = function(self, from, to, timestamp)
                table.insert(self.teleportHistory, 1, {
                    from = from,
                    to = to,
                    time = timestamp,
                    distance = (to - from).Magnitude
                })

                if #self.teleportHistory > self.maxHistory then
                    table.remove(self.teleportHistory)
                end

                self:analyzeSuspicion()
            end,

            analyzeSuspicion = function(self)
                if #self.teleportHistory < 3 then return end

                local recentTPs = {}
                for i = 1, math.min(5, #self.teleportHistory) do
                    table.insert(recentTPs, self.teleportHistory[i])
                end

                local avgDistance = 0
                for _, tp in ipairs(recentTPs) do
                    avgDistance = avgDistance + tp.distance
                end
                avgDistance = avgDistance / #recentTPs

                self.suspicionLevel = math.max(0, self.suspicionLevel - 3)

                if avgDistance > 600 then
                    self.suspicionLevel = self.suspicionLevel + 8
                end

                if #recentTPs >= 3 then
                    local timeDiff = recentTPs[1].time - recentTPs[3].time
                    if timeDiff < 4 then
                        self.suspicionLevel = self.suspicionLevel + 12
                    end
                end
            end,

            isSafe = function(self)
                return self.suspicionLevel < self.maxSuspicion * 0.7
            end,

            getRecommendedDelay = function(self)
                if self.suspicionLevel > 70 then
                    return math.random(10, 15)
                elseif self.suspicionLevel > 40 then
                    return math.random(6, 10)
                else
                    return math.random(2, 6)
                end
            end
        },

        SpeedCamouflage = {
            enabled = true,

            applyPreDelay = function(self)
                if not self.enabled then return end
                local delay = math.random(80, 250) / 1000
                task.wait(delay)
            end,

            applyPostMovement = function(self, hrp)
                if not self.enabled or not hrp then return end

                task.spawn(function()
                    task.wait(math.random(150, 400) / 1000)

                    local microStep = Vector3.new(
                        math.random(-3, 3),
                        0,
                        math.random(-3, 3)
                    )

                    pcall(function()
                        hrp.CFrame = hrp.CFrame + microStep
                    end)
                end)
            end
        },

        DataObfuscation = {
            enabled = true,

            obfuscateTeleportData = function(self, position)
                if not self.enabled then return position end

                local noise = Vector3.new(
                    (math.random(-200, 200) / 10000),
                    (math.random(-200, 200) / 10000),
                    (math.random(-200, 200) / 10000)
                )

                return position + noise
            end,

            createDecoyPath = function(self, start, finish)
                if not self.enabled then return {finish} end

                local path = {}
                local steps = math.random(4, 8)

                for i = 1, steps do
                    local t = i / (steps + 1)
                    local randomOffset = Vector3.new(
                        math.random(-30, 30),
                        math.random(-8, 8),
                        math.random(-30, 30)
                    )
                    local point = start:Lerp(finish, t) + randomOffset
                    table.insert(path, point)
                end

                table.insert(path, finish)
                return path
            end
        },

        HumanBehaviorSimulation = {
            enabled = true,

            simulateHesitation = function(self)
                if not self.enabled then return end
                if math.random(1, 100) <= 35 then
                    task.wait(math.random(250, 750) / 1000)
                end
            end,

            simulateLookAround = function(self, hrp)
                if not self.enabled or not hrp then return end

                task.spawn(function()
                    task.wait(math.random(350, 900) / 1000)

                    local turnAngle = math.rad(math.random(-120, 120))
                    pcall(function()
                        hrp.CFrame = hrp.CFrame * CFrame.Angles(0, turnAngle, 0)
                    end)
                end)
            end,

            simulatePostLanding = function(self, hrp)
                if not self.enabled or not hrp then return end

                if math.random(1, 100) <= 50 then
                    task.spawn(function()
                        task.wait(math.random(450, 1000) / 1000)

                        local step = math.random(1, 4)
                        local direction = hrp.CFrame.LookVector * (math.random(0, 1) == 0 and step or -step)

                        pcall(function()
                            hrp.CFrame = hrp.CFrame + direction
                        end)
                    end)
                end
            end
        }
    },

    DeathPrevention = {
        enabled = true,
        checkHealth = true,
        healOnTeleport = true,
        healAmount = 100,

        fallDamageProtection = true,
        maxFallTime = 3,

        preCheck = function(self, humanoid)
            if not self.enabled or not humanoid then return true end

            pcall(function()

                if humanoid.Health < humanoid.MaxHealth then
                    humanoid.Health = humanoid.MaxHealth
                end

                for _, child in ipairs(humanoid:GetChildren()) do
                    if child:IsA("NumberValue") and child.Name:find("Damage") then
                        child:Destroy()
                    end
                end
            end)

            return true
        end,

        protectDuring = function(self, humanoid)
            if not self.enabled or not humanoid then return end

            local originalHealth = humanoid.Health
            local maxHealth = humanoid.MaxHealth
            local healthConnection
            local stateConnection
            local diedConnection

            -- PC + Mobile: ŸÖŸÜÿπ ÿßŸÑŸÖŸàÿ™ ŸÉŸÑŸäÿßŸã ÿ£ÿ´ŸÜÿßÿ° ÿßŸÑÿ™ŸäŸÑŸäÿ®Ÿàÿ±ÿ™
            pcall(function()
                humanoid:SetStateEnabled(Enum.HumanoidStateType.Dead, false)
            end)

            -- ŸÖŸÜÿπ ÿßŸÑŸÖŸàÿ™ ŸÑŸà ŸÅÿßÿ™ ÿßŸÑŸÄ state check
            diedConnection = humanoid.Died:Connect(function()
                pcall(function()
                    humanoid.Health = maxHealth
                    humanoid:SetStateEnabled(Enum.HumanoidStateType.Dead, false)
                end)
            end)

            healthConnection = humanoid.HealthChanged:Connect(function(health)
                pcall(function()
                    if health <= 0 or health < maxHealth * 0.5 then
                        humanoid.Health = maxHealth
                    end
                end)
            end)

            if self.fallDamageProtection then
                stateConnection = humanoid.StateChanged:Connect(function(oldState, newState)
                    pcall(function()
                        if newState == Enum.HumanoidStateType.Freefall or
                           newState == Enum.HumanoidStateType.FallingDown then
                            humanoid.Health = maxHealth
                        end
                    end)
                end)
            end

            task.delay(5, function()
                if healthConnection then healthConnection:Disconnect() end
                if stateConnection then stateConnection:Disconnect() end
                if diedConnection then diedConnection:Disconnect() end
                -- ŸÜÿπŸäÿØ ÿ™ŸÅÿπŸäŸÑ ÿßŸÑŸÖŸàÿ™ ÿ®ÿπÿØ ÿßŸÜÿ™Ÿáÿßÿ° ÿßŸÑÿ≠ŸÖÿßŸäÿ©
                pcall(function()
                    if humanoid and humanoid.Parent then
                        humanoid:SetStateEnabled(Enum.HumanoidStateType.Dead, true)
                    end
                end)
            end)
        end,

        postHeal = function(self, humanoid)
            if not self.enabled or not humanoid or not self.healOnTeleport then return end

            for i = 1, 3 do
                task.wait(0.1)
                pcall(function()
                    if humanoid then
                        humanoid.Health = humanoid.MaxHealth or 100
                    end
                end)
            end
        end
    },

    PrecisionSystem = {
        enabled = true,
        maxRetries = 5,
        tolerance = 0.5,
        correctionDelay = 0.03,

        checkAccuracy = function(self, hrp, targetPos)
            if not self.enabled or not hrp then return true end

            local currentPos = hrp.Position
            local distance = (currentPos - targetPos).Magnitude

            return distance <= self.tolerance
        end,

        correctPosition = function(self, hrp, targetPos)
            if not self.enabled or not hrp then return false end

            for attempt = 1, self.maxRetries do
                local currentPos = hrp.Position
                local distance = (currentPos - targetPos).Magnitude

                if distance <= self.tolerance then

                    return true
                end

                pcall(function()

                    local direction = (targetPos - currentPos).Unit
                    local stepDistance = math.min(distance, 1)
                    local newPos = currentPos + (direction * stepDistance)
                    hrp.CFrame = CFrame.new(newPos)
                    task.wait(self.correctionDelay)
                end)
            end

            return false
        end
    },

    BypassLayers = {
        enabled = true,
        layers = {

            VelocityBypass = {
                active = true,
                execute = function(self, hrp)
                    pcall(function()
                        hrp.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
                        hrp.AssemblyAngularVelocity = Vector3.new(0, 0, 0)

                        if hrp:FindFirstChild("BodyVelocity") then
                            hrp.BodyVelocity:Destroy()
                        end
                    end)
                end
            },

            CollisionBypass = {
                active = true,
                execute = function(self, character)
                    pcall(function()
                        for _, part in ipairs(character:GetDescendants()) do
                            if part:IsA("BasePart") then
                                part.CanCollide = false
                            end
                        end
                    end)
                end
            },

            NetworkBypass = {
                active = true,
                execute = function(self, hrp)
                    pcall(function()
                        if hrp:CanSetNetworkOwnership() then
                            hrp:SetNetworkOwner(LocalPlayer)
                        end
                    end)
                end
            },

            AnchorBypass = {
                active = true,
                execute = function(self, hrp)
                    local wasAnchored = hrp.Anchored
                    pcall(function()
                        hrp.Anchored = true
                        task.wait(0.05)
                        hrp.Anchored = wasAnchored
                    end)
                end
            },

            StateBypass = {
                active = true,
                execute = function(self, humanoid)
                    pcall(function()
                        if humanoid then
                            humanoid:ChangeState(Enum.HumanoidStateType.Physics)
                            task.wait(0.03)
                            humanoid:ChangeState(Enum.HumanoidStateType.Running)
                        end
                    end)
                end
            },

            EnvironmentBypass = {
                active = true,
                execute = function(self, character, targetPos)
                    pcall(function()

                        for _, part in ipairs(character:GetDescendants()) do
                            if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then

                                local originalCollide = part.CanCollide
                                part.CanCollide = false
                                task.delay(1, function()
                                    if part and part.Parent then
                                        part.CanCollide = originalCollide
                                    end
                                end)
                            end
                        end
                    end)
                end
            }
        },

        executeAll = function(self, character, hrp, humanoid, targetPos)
            if not self.enabled then return end

            for name, layer in pairs(self.layers) do
                if layer.active then
                    task.spawn(function()
                        pcall(function()
                            if name == "VelocityBypass" or name == "NetworkBypass" or name == "AnchorBypass" then
                                layer:execute(hrp)
                            elseif name == "CollisionBypass" or name == "EnvironmentBypass" then
                                layer:execute(character, targetPos)
                            elseif name == "StateBypass" then
                                layer:execute(humanoid)
                            end
                        end)
                    end)
                end
            end
        end
    },

    ProtectionLayers = {
        enabled = true,

        MemoryProtect = {
            active = true,
            keys = {},
            initialize = function(self)
                for i = 1, 10 do
                    self.keys[i] = math.random(1000000, 9999999)
                end
            end,
            encrypt = function(self, pos)
                if #self.keys == 0 then self:initialize() end
                local key = self.keys[math.random(1, #self.keys)]
                return {
                    x = bit32.bxor(pos.X * 1000, key),
                    y = bit32.bxor(pos.Y * 1000, key),
                    z = bit32.bxor(pos.Z * 1000, key),
                    k = key
                }
            end
        },

        PathObfuscate = {
            active = true,
            segmentCount = 8,
            randomness = 0.5,
            createPath = function(self, start, target)
                local path = {}
                for i = 1, self.segmentCount do
                    local alpha = i / self.segmentCount
                    local pos = start:Lerp(target, alpha)

                    local offset = Vector3.new(
                        (math.random() - 0.5) * self.randomness,
                        (math.random() - 0.5) * self.randomness,
                        (math.random() - 0.5) * self.randomness
                    )

                    table.insert(path, pos + offset)
                end
                return path
            end
        },

        TimingRandom = {
            active = true,
            baseDelay = 0.02,
            variance = 0.01,
            getDelay = function(self)
                return self.baseDelay + (math.random() - 0.5) * self.variance
            end
        },

        CFrameEncrypt = {
            active = true,
            rotationKey = math.random() * math.pi * 2,
            apply = function(self, cf)
                local rotation = CFrame.Angles(
                    self.rotationKey,
                    self.rotationKey * 0.7,
                    self.rotationKey * 0.3
                )
                return cf * rotation
            end,
            remove = function(self, cf)
                local rotation = CFrame.Angles(
                    -self.rotationKey,
                    -self.rotationKey * 0.7,
                    -self.rotationKey * 0.3
                )
                return cf * rotation
            end
        },

        AntiDetect = {
            active = true,
            maskTeleport = function(self, hrp, targetCF)

                local startCF = hrp.CFrame
                local steps = 5

                for i = 1, steps do
                    local alpha = i / steps
                    local intermediateCF = startCF:Lerp(targetCF, alpha)
                    hrp.CFrame = intermediateCF
                    RunService.Heartbeat:Wait()
                end
            end
        }
    }
}

instantTeleport = function(targetPosition)
    local safeShowNotification = function(title, msg, dur)
        pcall(function()
            if showNotification and type(showNotification) == "function" then
                showNotification(title, msg, dur)
            end
        end)
    end

    if TeleportValidator.enabled and not TeleportValidator:canTeleport() then
        return false
    end

    local patternAnalysis = AdvancedTeleportSystem.AntiDetection.PatternAnalysis
    if not patternAnalysis:isSafe() then
        local recommendedDelay = patternAnalysis:getRecommendedDelay()
        safeShowNotification("‚ö†Ô∏è Anti-Detection",
            string.format("High suspicion detected! Wait %ds", recommendedDelay), 4)
        TeleportValidator:failTeleport()
        return false
    end

    AdvancedTeleportSystem.AntiDetection.SpeedCamouflage:applyPreDelay()

    AdvancedTeleportSystem.AntiDetection.HumanBehaviorSimulation:simulateHesitation()

    local decision, justification
    pcall(function()
        if makeDecision and type(makeDecision) == "function" then
            decision = makeDecision("teleport")
        else
            decision = "proceed"
        end
    end)
    pcall(function()
        if getJustification and type(getJustification) == "function" then
            justification = getJustification()
        else
            justification = "System ready"
        end
    end)
    decision = decision or "proceed"
    justification = justification or "Ready"
    if decision == "reject" then
        safeShowNotification("Teleport Denied", justification, 2)
        TeleportValidator:failTeleport()
        return false
    elseif decision == "delay" then
        local delayTime = randomFloat(0.8, 2.0)
        safeShowNotification("Teleport Delayed", justification .. " (" .. string.format("%.1f", delayTime) .. "s)", 2)
        task.wait(delayTime)
        pcall(function()
            if makeDecision then
                decision = makeDecision("teleport_retry")
            end
        end)
        if decision == "reject" then
            TeleportValidator:failTeleport()
            return false
        end
    elseif decision == "alternative" then
        safeShowNotification("Alternative Action", justification, 2)
        local character = LocalPlayer.Character
        if character then
            local rootPart = character:FindFirstChild("HumanoidRootPart")
            if rootPart then
                local randomJump = Vector3.new(
                    randomFloat(-8, 8),
                    randomFloat(3, 8),
                    randomFloat(-8, 8)
                )
                rootPart.CFrame = rootPart.CFrame + randomJump
                task.wait(randomFloat(0.2, 0.5))
                TeleportValidator:failTeleport()
                return false
            end
        end
    end

    pcall(function()

        if game:GetService("LogService") then
            game:GetService("LogService"):ClearOutput()
        end

        if AntiLogging and AntiLogging.clearConsoleLogs then
            AntiLogging:clearConsoleLogs()
        end

        game:GetService("ScriptContext").Error:Connect(function() end)

        local blockedEvents = {
            "LogPlayerMovement",
            "TrackTeleport",
            "ReportPosition",
            "AntiCheatLog"
        }

        for _, eventName in ipairs(blockedEvents) do
            pcall(function()
                local event = game:GetService("ReplicatedStorage"):FindFirstChild(eventName)
                if event then
                    event:Destroy()
                end
            end)
        end
    end)

    local teleportStartTime = tick()
    local character = LocalPlayer.Character
    if not character then
        pcall(function() earlyNotification("Error", "Character not found!", 2) end)
        return false
    end
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then
        pcall(function() earlyNotification("Error", "HumanoidRootPart not found!", 2) end)
        return false
    end
    local currentTime = tick()

    local safetyCheck = true
    pcall(function()
        if checkTeleportSafety and type(checkTeleportSafety) == "function" then
            safetyCheck = checkTeleportSafety()
        end
    end)
    if not safetyCheck then
        return false
    end

    local forceField = character:FindFirstChildOfClass("ForceField")
    local savedForceField = nil
    local forceFieldHandlingMethod = FORCEFIELD_MODE or "SMART"

    if forceField then
        if forceFieldHandlingMethod == "KEEP" then

            pcall(function() earlyNotification("üõ°Ô∏è Force Field", "Attempting teleport with shield active...", 2) end)

        elseif forceFieldHandlingMethod == "SMART" then

            pcall(function() earlyNotification("üõ°Ô∏è Force Field", "Shield protected during teleport...", 2) end)
            savedForceField = {
                Visible = forceField.Visible,
                Parent = forceField.Parent,
                Name = forceField.Name
            }

        else

            pcall(function() earlyNotification("üõ°Ô∏è Force Field Detected", "Temporarily removing for safe teleport...", 3) end)
            savedForceField = {
                Visible = forceField.Visible,
                Parent = forceField.Parent,
                Name = forceField.Name
            }
            forceField:Destroy()
            task.wait(0.3)
        end
    end

    local wasNoclipActive = noclipActive
    if wasNoclipActive then
        toggleNoclip(false)
        pcall(function() earlyNotification("üîÑ NoClip", "Paused during teleport", 2) end)
        task.wait(0.2)
    end

    local obfuscatedPosition = AdvancedTeleportSystem.AntiDetection.DataObfuscation:obfuscateTeleportData(targetPosition)

    pcall(function()
        if ServerSpoofing and ServerSpoofing.enabled then
            ServerSpoofing:initialize()
            ServerSpoofing:startSpoofing()
            ServerSpoofing:setFakePosition(humanoidRootPart.CFrame)
        end
    end)
    local currentPos = humanoidRootPart.Position
    local distance = (targetPosition - currentPos).Magnitude

    patternAnalysis:recordTeleport(currentPos, targetPosition, currentTime)

    local finalPosition = obfuscatedPosition
    local envSafe, envReason = checkEnvironmentSafety(finalPosition)
    if not envSafe then
        finalPosition = targetPosition
    end

    updateTeleportPattern(currentPos, finalPosition)
    local preTPWait = randomFloat(0.1, 0.2)
    task.wait(preTPWait)

    local humanoid = character:FindFirstChildOfClass("Humanoid")

    AdvancedTeleportSystem.DeathPrevention:preCheck(humanoid)
    AdvancedTeleportSystem.DeathPrevention:protectDuring(humanoid)

    AdvancedTeleportSystem.ServerIsolation:initialize(humanoidRootPart)
    AdvancedTeleportSystem.ServerIsolation:startSpoofing(humanoidRootPart)

    AdvancedTeleportSystem.BypassLayers:executeAll(character, humanoidRootPart, humanoid, finalPosition)

    teleportInProgress = true

    local savedSpeed = OxyoSettings and OxyoSettings.Player and OxyoSettings.Player.WalkSpeed or 24
    local originalCF = humanoidRootPart.CFrame
    local spoofedOriginal = CFrameProtection:createSpoof(originalCF)
    MemoryProtection:protect("preTeleportCF", spoofedOriginal)

    local humanoid = character:FindFirstChildOfClass("Humanoid")
    local savedHealth = humanoid and humanoid.Health or 100
    local healthProtection = nil

    if humanoid then
        healthProtection = humanoid.HealthChanged:Connect(function(newHealth)
            if newHealth < savedHealth * 0.5 then
                humanoid.Health = savedHealth
            end
        end)
    end

    local success = pcall(function()
        disguiseAction(humanoidRootPart, function()

            VelocityMask:maskVelocity(humanoidRootPart)

            humanoidRootPart.Velocity = Vector3.new(0, 0, 0)
            humanoidRootPart.AssemblyLinearVelocity = Vector3.new(0, 0, 0)

            task.wait(randomFloat(0.03, 0.08))

            local function safeTeleport(cf)
                local encryptedCF = AdvancedTeleportSystem.ProtectionLayers.CFrameEncrypt:apply(cf)

                if HookProtection:detectHook("setCFrame") then
                    HookProtection:callOriginal("setCFrame", humanoidRootPart, encryptedCF)
                else
                    humanoidRootPart.CFrame = encryptedCF
                end

                task.wait(0.01)
                humanoidRootPart.CFrame = cf

                AdvancedTeleportSystem.ServerIsolation:updateReal(cf)
            end

            if distance > 15 then

                local decoyPath = AdvancedTeleportSystem.AntiDetection.DataObfuscation:createDecoyPath(
                    currentPos, finalPosition
                )

                for i, pathPoint in ipairs(decoyPath) do
                    local pathCF = CFrame.new(pathPoint)
                    safeTeleport(pathCF)

                    local delay = math.random(20, 60) / 1000
                    task.wait(delay)

                    VelocityMask:maskVelocity(humanoidRootPart)
                end

            else
                local finalCF = CFrame.new(finalPosition)
                safeTeleport(finalCF)
            end

            task.wait(randomFloat(0.05, 0.1))

            local isAccurate = AdvancedTeleportSystem.PrecisionSystem:checkAccuracy(
                humanoidRootPart, finalPosition
            )

            if not isAccurate then
                AdvancedTeleportSystem.PrecisionSystem:correctPosition(
                    humanoidRootPart, finalPosition
                )
            end

            local landingSteps = math.random(2, 4)
            for i = 1, landingSteps do
                local landingForce = randomFloat(0.2, 0.8)
                local landingVelocity = Vector3.new(
                    randomFloat(-landingForce, landingForce),
                    -randomFloat(0.3, 1.0),
                    randomFloat(-landingForce, landingForce)
                )
                if landingVelocity.Magnitude > VelocityMask.maxSafeVelocity then
                    landingVelocity = landingVelocity.Unit * VelocityMask.maxSafeVelocity
                end
                humanoidRootPart.Velocity = landingVelocity
                task.wait(0.02)
            end

            humanoidRootPart.Velocity = Vector3.new(0, 0, 0)
            humanoidRootPart.AssemblyLinearVelocity = Vector3.new(0, 0, 0)

            task.spawn(function()
                task.wait(2)
                MemoryProtection.protectedValues["preTeleportCF"] = nil
                MemoryProtection.protectedValues["teleportTarget"] = nil
            end)
        end)
        task.spawn(function()
            simulateFailure(humanoidRootPart, finalPosition)
        end)
        task.spawn(function()
            processMemory({
                action = "instant_teleport_protected",
                from = currentPos,
                to = finalPosition,
                distance = distance,
                timestamp = tick(),
                justification = justification,
                protection_layers = {
                    "CFrame_Spoofing",
                    "Memory_Protection",
                    "Hook_Detection",
                    "Velocity_Masking",
                    "Anti_Detection",
                    "Pattern_Analysis"
                }
            })
        end)
    end)
    local teleportEndTime = tick()
    local teleportDuration = teleportEndTime - teleportStartTime
    updateTeleportDuration(teleportDuration)

    pcall(function()
        for _, part in ipairs(character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = true
            end
        end
        if humanoidRootPart then
            humanoidRootPart.CanCollide = true
        end
    end)

    AdvancedTeleportSystem.DeathPrevention:postHeal(humanoid)

    task.spawn(function()
        local healEnd = tick() + 3
        while tick() < healEnd do
            task.wait(0.1)
            pcall(function()
                if humanoid and humanoid.Parent and humanoid.Health > 0 then
                    humanoid.Health = humanoid.MaxHealth
                end
            end)
        end

        if healthProtection then
            healthProtection:Disconnect()
            healthProtection = nil
        end
    end)

    if savedForceField and forceFieldHandlingMethod ~= "KEEP" then

        local restoreDelay = (forceFieldHandlingMethod == "SMART") and 0.1 or 0.3

        task.spawn(function()
            task.wait(restoreDelay)

            local existingFF = character:FindFirstChildOfClass("ForceField")
            if existingFF then
                existingFF:Destroy()
                task.wait(0.05)
            end

            local newFF = Instance.new("ForceField")
            newFF.Visible = savedForceField.Visible
            newFF.Name = savedForceField.Name or "ForceField"
            newFF.Parent = character

            local ffProtection = newFF.AncestryChanged:Connect(function()
                if not newFF.Parent then
                    task.wait(0.1)
                    if character and character.Parent then
                        local replacementFF = Instance.new("ForceField")
                        replacementFF.Visible = savedForceField.Visible
                        replacementFF.Parent = character
                    end
                end
            end)

            task.delay(5, function()
                if ffProtection then
                    ffProtection:Disconnect()
                end
                -- ÿßŸÑÿØÿ±ÿπ ŸäÿÆÿ™ŸÅŸä ÿ®ÿπÿØ 5 ÿ´ŸàÿßŸÜŸä ÿ´ÿßÿ®ÿ™
                pcall(function()
                    if character and character.Parent then
                        local ff = character:FindFirstChildOfClass("ForceField")
                        if ff then ff:Destroy() end
                    end
                end)
            end)

            pcall(function() earlyNotification("üõ°Ô∏è Force Field", "Shield restored successfully!", 2) end)
        end)
    end

    task.delay(3, function()
        AdvancedTeleportSystem.ServerIsolation:stopSpoofing()
    end)

    if wasNoclipActive then
        task.wait(4)
        toggleNoclip(true)
        pcall(function() earlyNotification("‚úÖ NoClip", "Re-enabled", 2) end)
    end

    AdvancedTeleportSystem.AntiDetection.SpeedCamouflage:applyPostMovement(humanoidRootPart)
    AdvancedTeleportSystem.AntiDetection.HumanBehaviorSimulation:simulateLookAround(humanoidRootPart)
    AdvancedTeleportSystem.AntiDetection.HumanBehaviorSimulation:simulatePostLanding(humanoidRootPart)

    task.wait(randomFloat(0.15, 0.3))
    teleportInProgress = false

    pcall(function()

        if game:GetService("LogService") then
            game:GetService("LogService"):ClearOutput()
        end

        if AntiLogging then
            AntiLogging:clearConsoleLogs()

            AntiLogging.blockedLogs = 0
        end

        task.spawn(function()
            for i = 1, 3 do
                task.wait(0.5)

                pcall(function()
                    game:GetService("LogService"):ClearOutput()
                end)
            end
        end)

        task.spawn(function()
            task.wait(math.random(1, 3))

            local dummyLogs = {
                "[System] Player connected",
                "[Info] Loading assets...",
                "[Game] Map loaded successfully",
                "[Network] Connection stable"
            }
            for _, log in ipairs(dummyLogs) do
                if math.random() > 0.5 then
                    AntiLogging.originalFunctions.print(log)
                end
            end
        end)
    end)

    if not success then
        TeleportSafetyTracker.suspicionScore = TeleportSafetyTracker.suspicionScore + 20
        return false
    end
    AntiDetection.teleportCount = AntiDetection.teleportCount + 1
    TeleportSafetyTracker.teleportsInLastMinute = TeleportSafetyTracker.teleportsInLastMinute + 1

    TeleportValidator:recordTeleport()

    task.defer(restoreSpeed)

    local postActionChance = math.random(1, 100)
    if postActionChance <= 40 then
        task.spawn(function()
            task.wait(randomFloat(0.3, 0.7))
            local lookAngle = CFrame.Angles(0, math.rad(randomFloat(-60, 60)), 0)
            humanoidRootPart.CFrame = humanoidRootPart.CFrame * lookAngle
        end)
    elseif postActionChance <= 70 then
        task.spawn(function()
            task.wait(randomFloat(0.2, 0.5))
            local adjustWalk = Vector3.new(
                randomFloat(-2, 2), 0, randomFloat(-2, 2)
            )
            humanoidRootPart.CFrame = humanoidRootPart.CFrame + adjustWalk
        end)
    end
    return true
end

local AntiVoidSystem = {
    enabled = true,
    minY = -10,
    safeY = 100,
    checkRate = 0.1,
    lastRecoveryTime = 0,
    recoveryCooldown = 2,
}

function AntiVoidSystem:recover()
    local now = tick()
    if now - self.lastRecoveryTime < self.recoveryCooldown then
        return
    end

    pcall(function()
        local char = LocalPlayer.Character
        if not char then return end

        local hrp = char:FindFirstChild("HumanoidRootPart")
        local hum = char:FindFirstChild("Humanoid")
        if not hrp or not hum then return end

        print("[Oxyo] ‚ö†Ô∏è VOID DETECTED! Y = " .. hrp.Position.Y)

        hrp.Velocity = Vector3.new(0, 0, 0)
        hrp.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
        hrp.AssemblyAngularVelocity = Vector3.new(0, 0, 0)

        hrp.Anchored = true
        task.wait(0.05)

        local rayOrigin = Vector3.new(hrp.Position.X, 200, hrp.Position.Z)
        local rayDirection = Vector3.new(0, -400, 0)
        local rayParams = RaycastParams.new()
        rayParams.FilterType = Enum.RaycastFilterType.Exclude
        rayParams.FilterDescendantsInstances = {char}

        local result = workspace:Raycast(rayOrigin, rayDirection, rayParams)
        local targetY

        if result then

            targetY = result.Position.Y + 5
            print("[Oxyo] Found ground at Y = " .. result.Position.Y)
        else

            targetY = self.safeY
            print("[Oxyo] No ground found, using safe height")
        end

        hrp.CFrame = CFrame.new(hrp.Position.X, targetY, hrp.Position.Z)

        task.wait(0.1)
        hrp.Anchored = false

        for _, part in ipairs(char:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = true
            end
        end
        hrp.CanCollide = true

        hum.Health = hum.MaxHealth

        self.lastRecoveryTime = now
        print("[Oxyo] ‚úÖ Recovered to Y = " .. targetY)
    end)
end

task.spawn(function()
    while task.wait(AntiVoidSystem.checkRate) do
        if not AntiVoidSystem.enabled then continue end

        pcall(function()
            local char = LocalPlayer.Character
            if not char then return end

            local hrp = char:FindFirstChild("HumanoidRootPart")
            if not hrp then return end

            if hrp.Position.Y < AntiVoidSystem.minY then
                AntiVoidSystem:recover()
            end
        end)
    end
end)

local function gunTeleport(gunPosition, gunName)
    local safeShowNotification = function(title, msg, dur)
        pcall(function()
            if showNotification and type(showNotification) == "function" then
                showNotification(title, msg, dur)
            end
        end)
    end

    if TeleportValidator.enabled and not TeleportValidator:canTeleport() then
        return false
    end

    local patternAnalysis = AdvancedTeleportSystem.AntiDetection.PatternAnalysis
    if not patternAnalysis:isSafe() then
        local recommendedDelay = patternAnalysis:getRecommendedDelay()
        safeShowNotification("‚ö†Ô∏è Anti-Detection",
            string.format("High suspicion! Wait %ds before gun pickup", recommendedDelay), 4)
        TeleportValidator:failTeleport()
        return false
    end

    AdvancedTeleportSystem.AntiDetection.SpeedCamouflage:applyPreDelay()

    AdvancedTeleportSystem.AntiDetection.HumanBehaviorSimulation:simulateHesitation()

    pcall(function()
        if game:GetService("LogService") then
            game:GetService("LogService"):ClearOutput()
        end
        if AntiLogging then
            AntiLogging:clearConsoleLogs()
        end
    end)

    local currentTime = tick()

    local decision, justification
    pcall(function()
        if makeDecision and type(makeDecision) == "function" then
            decision = makeDecision("gun_teleport")
        else
            decision = "proceed"
        end
    end)
    pcall(function()
        if getJustification and type(getJustification) == "function" then
            justification = getJustification()
        else
            justification = "Ready"
        end
    end)
    decision = decision or "proceed"
    justification = justification or "Ready"
    if decision == "reject" then
        safeShowNotification("Gun Access Denied", justification, 2)
        TeleportValidator:failTeleport()
        return false
    elseif decision == "delay" then
        local delayTime = randomFloat(2.0, 5.0)
        safeShowNotification("Gun Access Delayed", justification .. " (" .. string.format("%.1f", delayTime) .. "s)", 2)
        task.wait(delayTime)
        pcall(function()
            if makeDecision then
                decision = makeDecision("gun_teleport_retry")
            end
        end)
        if decision == "reject" then
            TeleportValidator:failTeleport()
            return false
        end
    elseif decision == "alternative" then
        safeShowNotification("Alternative Search", justification, 2)
        local char = LocalPlayer.Character
        if char then
            local rootPart = char:FindFirstChild("HumanoidRootPart")
            if rootPart then
                for i = 1, math.random(2, 4) do
                    local randomSearch = Vector3.new(
                        randomFloat(-5, 5),
                        0,
                        randomFloat(-5, 5)
                    )
                    rootPart.CFrame = rootPart.CFrame + randomSearch
                    task.wait(randomFloat(0.3, 0.6))
                end
                TeleportValidator:failTeleport()
                return false
            end
        end
    end

    local char = LocalPlayer.Character
    if not char then
        safeShowNotification("Error", "Character not found!", 2)
        TeleportValidator:failTeleport()
        return false
    end
    local rootPart = char:FindFirstChild("HumanoidRootPart")
    local hum = char:FindFirstChild("Humanoid")
    if not rootPart or not hum then
        safeShowNotification("Error", "RootPart/Humanoid not found!", 2)
        TeleportValidator:failTeleport()
        return false
    end

    local forceField = char:FindFirstChildOfClass("ForceField")
    local savedGunFF = nil
    local gunFFMethod = FORCEFIELD_MODE or "SMART"

    if forceField then
        if gunFFMethod == "KEEP" then

            safeShowNotification("üõ°Ô∏è Force Field", "Teleporting with shield active...", 2)

        elseif gunFFMethod == "SMART" then

            safeShowNotification("üõ°Ô∏è Force Field", "Shield protected during gun teleport...", 2)
            savedGunFF = {
                Visible = forceField.Visible,
                Parent  = forceField.Parent,
                Name    = forceField.Name
            }

        else
            safeShowNotification("üõ°Ô∏è Force Field", "Removing shield for gun teleport...", 2)
            savedGunFF = {
                Visible = forceField.Visible,
                Parent  = forceField.Parent,
                Name    = forceField.Name
            }
            forceField:Destroy()
            task.wait(0.15)
        end
    end

    local wasNoclipActive = noclipActive
    if wasNoclipActive then
        toggleNoclip(false)
        safeShowNotification("üîÑ NoClip", "Paused during gun pickup", 2)
        task.wait(0.2)
    end

    local currentPos = rootPart.Position
    patternAnalysis:recordTeleport(currentPos, gunPosition, currentTime)

    local obfuscatedGunPos = AdvancedTeleportSystem.AntiDetection.DataObfuscation:obfuscateTeleportData(gunPosition)

    AdvancedTeleportSystem.DeathPrevention:preCheck(hum)
    AdvancedTeleportSystem.DeathPrevention:protectDuring(hum)

    AdvancedTeleportSystem.ServerIsolation:initialize(rootPart)
    AdvancedTeleportSystem.ServerIsolation:startSpoofing(rootPart)

    AdvancedTeleportSystem.BypassLayers:executeAll(char, rootPart, hum)

    local originalPosition = rootPart.CFrame
    safeShowNotification("Gun Teleport", gunName, 1.5)

    local preTeleportDelay = randomFloat(0.25, 0.5)
    task.wait(preTeleportDelay)

    if math.random(1, 100) <= 60 then
        local randomLook = CFrame.Angles(0, math.rad(randomFloat(-90, 90)), 0)
        rootPart.CFrame = rootPart.CFrame * randomLook
        task.wait(randomFloat(0.1, 0.25))
    end

    rootPart.Velocity = Vector3.new(0, 0, 0)
    rootPart.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
    teleportInProgress = true

    disguiseAction(rootPart, function()

        local targetCF = CFrame.new(obfuscatedGunPos) * CFrame.Angles(0, math.rad(randomFloat(0, 360)), 0)
        local encryptedCF = AdvancedTeleportSystem.ProtectionLayers.CFrameEncrypt:apply(targetCF)

        rootPart.CFrame = encryptedCF
        task.wait(0.01)
        rootPart.CFrame = targetCF

        AdvancedTeleportSystem.ServerIsolation:updateReal(targetCF)

        rootPart.Velocity = Vector3.new(0, 0, 0)
        rootPart.AssemblyLinearVelocity = Vector3.new(0, 0, 0)

        task.wait(randomFloat(0.1, 0.2))

        AdvancedTeleportSystem.PrecisionSystem:correctPosition(rootPart, gunPosition)

        local searchMoves = math.random(3, 5)
        for i = 1, searchMoves do
            local angle = (i / searchMoves) * 360 + randomFloat(-60, 60)
            local radius = randomFloat(0.4, 1.0)
            local moveOffset = Vector3.new(
                math.cos(math.rad(angle)) * radius,
                randomFloat(-0.15, 0.15),
                math.sin(math.rad(angle)) * radius
            )
            rootPart.CFrame = rootPart.CFrame + moveOffset
            task.wait(randomFloat(0.05, 0.12))
        end

        task.wait(randomFloat(0.3, 0.6))
        rootPart.CFrame = rootPart.CFrame - Vector3.new(0, 0.2, 0)
        task.wait(0.08)
        rootPart.CFrame = rootPart.CFrame + Vector3.new(0, 0.2, 0)
    end)

    print("[Oxyo] Weapon acquired!")
    showNotification("Success", gunName .. " acquired!", 1.5)
    task.wait(randomFloat(0.6, 1.2))

    rootPart.Velocity = Vector3.new(0, 0, 0)
    rootPart.AssemblyLinearVelocity = Vector3.new(0, 0, 0)

    local safeReturnPos, hasGround = findSafePosition(originalPosition.Position)

    if hasGround then
        rootPart.CFrame = CFrame.new(safeReturnPos) * (originalPosition - originalPosition.Position)
    else
        rootPart.CFrame = originalPosition + Vector3.new(0, 5, 0)
    end

    task.wait(randomFloat(0.05, 0.1))
    for i = 1, 2 do
        rootPart.Velocity = Vector3.new(0, -randomFloat(0.5, 1.0), 0)
        task.wait(0.03)
    end
    rootPart.Velocity = Vector3.new(0, 0, 0)
    rootPart.AssemblyLinearVelocity = Vector3.new(0, 0, 0)

    simulateFailure(rootPart, originalPosition.Position)
    processMemory({
        action = "gun_teleport",
        gun = gunName,
        position = gunPosition,
        timestamp = tick(),
        justification = justification,
        protection_layers = {
            "Anti_Detection",
            "Pattern_Analysis",
            "Data_Obfuscation",
            "Server_Isolation"
        }
    })

    pcall(function()
        for _, part in ipairs(char:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = true
            end
        end
        if rootPart then
            rootPart.CanCollide = true
        end
    end)

    AdvancedTeleportSystem.DeathPrevention:postHeal(hum)

    task.spawn(function()
        local gunHealEnd = tick() + 3
        while tick() < gunHealEnd do
            task.wait(0.1)
            pcall(function()
                if hum and hum.Parent and hum.Health > 0 then
                    hum.Health = hum.MaxHealth
                end
            end)
        end
    end)

    task.delay(3, function()
        AdvancedTeleportSystem.ServerIsolation:stopSpoofing()
    end)

    if wasNoclipActive then
        task.wait(4)
        toggleNoclip(true)
        safeShowNotification("‚úÖ NoClip", "Re-enabled", 2)
    end

    AdvancedTeleportSystem.AntiDetection.SpeedCamouflage:applyPostMovement(rootPart)
    AdvancedTeleportSystem.AntiDetection.HumanBehaviorSimulation:simulateLookAround(rootPart)
    AdvancedTeleportSystem.AntiDetection.HumanBehaviorSimulation:simulatePostLanding(rootPart)

    pcall(function()
        if game:GetService("LogService") then
            game:GetService("LogService"):ClearOutput()
        end
        if AntiLogging then
            AntiLogging:clearConsoleLogs()
        end

        task.spawn(function()
            for i = 1, 2 do
                task.wait(0.5)
                pcall(function()
                    game:GetService("LogService"):ClearOutput()
                end)
            end
        end)
    end)

    teleportInProgress = false

    if savedGunFF and gunFFMethod ~= "KEEP" then
        local restoreDelay = (gunFFMethod == "SMART") and 0.1 or 0.3
        task.delay(restoreDelay, function()
            pcall(function()
                local existingFF = char:FindFirstChildOfClass("ForceField")
                if not existingFF then
                    local newFF = Instance.new("ForceField")
                    newFF.Visible = savedGunFF.Visible
                    newFF.Name    = savedGunFF.Name or "ForceField"
                    newFF.Parent  = char
                end
            end)
            -- ÿßŸÑÿØÿ±ÿπ ŸäÿÆÿ™ŸÅŸä ÿ®ÿπÿØ 5 ÿ´ŸàÿßŸÜŸä ÿ´ÿßÿ®ÿ™ (gun teleport)
            task.delay(5, function()
                pcall(function()
                    if char and char.Parent then
                        local ff = char:FindFirstChildOfClass("ForceField")
                        if ff then ff:Destroy() end
                    end
                end)
            end)
        end)
    end

    TeleportValidator:recordTeleport()

    task.defer(restoreSpeed)

    return true
end
local SilentAimFOVCircle
local FOVFrame
local FOVScreenGui
local isUsingMobile = isMobileDevice()
print("[Oxyo] Device Type: " .. (isUsingMobile and "MOBILE" or "PC"))
if not isUsingMobile then
    local DrawingAvailable = pcall(function()
        SilentAimFOVCircle = Drawing.new("Circle")
    end)
    if DrawingAvailable and SilentAimFOVCircle then
        SilentAimFOVCircle.Visible = false
        SilentAimFOVCircle.Color = OxyoSettings.SilentAim.FOVColor
        SilentAimFOVCircle.Radius = OxyoSettings.SilentAim.FOVSize
        SilentAimFOVCircle.Transparency = 0.8
        SilentAimFOVCircle.Filled = false
        SilentAimFOVCircle.NumSides = 64
        SilentAimFOVCircle.Thickness = 2
        RunService.RenderStepped:Connect(function()
            if SilentAimFOVCircle then
                pcall(function()
                    local screenPoint = GetScreenPoint()
                    SilentAimFOVCircle.Position = screenPoint
                    SilentAimFOVCircle.Visible = OxyoSettings.SilentAim.FOVEnabled
                    SilentAimFOVCircle.Radius = OxyoSettings.SilentAim.FOVSize
                    SilentAimFOVCircle.Color = OxyoSettings.SilentAim.FOVColor
                end)
            end
        end)
    end
end
if isUsingMobile then
    print("[Oxyo] Initializing Mobile FOV Circle...")
    local PlayerGui = LocalPlayer:WaitForChild("PlayerGui", 10)
    if not PlayerGui then
        warn("[Oxyo] ERROR: PlayerGui not found!")
    else
        FOVScreenGui = Instance.new("ScreenGui")
        FOVScreenGui.Name = "OxyoMobileFOV"
        FOVScreenGui.ResetOnSpawn = false
        FOVScreenGui.IgnoreGuiInset = true
        FOVScreenGui.DisplayOrder = 999999
        FOVScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
        FOVFrame = Instance.new("Frame")
        FOVFrame.Name = "FOVCircle"
        FOVFrame.AnchorPoint = Vector2.new(0.5, 0.5)
        FOVFrame.Position = UDim2.new(0.5, 0, 0.5, 0)
        FOVFrame.Size = UDim2.new(0, 200, 0, 200)
        FOVFrame.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
        FOVFrame.BackgroundTransparency = 1
        FOVFrame.BorderSizePixel = 0
        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(1, 0)
        corner.Parent = FOVFrame
        local stroke = Instance.new("UIStroke")
        stroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
        stroke.Color = Color3.fromRGB(255, 255, 255)
        stroke.Thickness = 4
        stroke.Transparency = 0
        stroke.Parent = FOVFrame
        FOVFrame.Parent = FOVScreenGui
        FOVScreenGui.Parent = PlayerGui
        FOVFrame.Visible = OxyoSettings.SilentAim.FOVEnabled
        print("[Oxyo] ‚úÖ Mobile FOV Circle Created!")
        print("[Oxyo] FOV Parent: " .. FOVScreenGui.Parent.Name)
        print("[Oxyo] FOV Visible: " .. tostring(FOVFrame.Visible))
        RunService.RenderStepped:Connect(function()
            if FOVFrame and FOVFrame.Parent then
                pcall(function()
                    local size = OxyoSettings.SilentAim.FOVSize * 2
                    FOVFrame.Size = UDim2.new(0, size, 0, size)
                    FOVFrame.Visible = OxyoSettings.SilentAim.FOVEnabled
                    local stroke = FOVFrame:FindFirstChildOfClass("UIStroke")
                    if stroke then
                        stroke.Color = OxyoSettings.SilentAim.FOVColor
                    end
                end)
            end
        end)
    end
end
local function GetTeamColor(player)
    if player and player.Team then
        if player.Team.Name == "Prisoners" then return Color3.fromRGB(165, 156, 0) end
        if player.Team.Name == "Guards" then return Color3.fromRGB(0, 0, 255) end
        if player.Team.Name == "Criminals" then return Color3.fromRGB(255, 0, 0) end
    end
    return Color3.fromRGB(255, 255, 255)
end
local function get_closest_player(part_name, fov)
    fov = fov or math.huge
    local closest_player = nil
    local closest_position = nil
    local closest_distance = fov
    local ref = GetScreenPoint()
    for _, player in pairs(Players:GetPlayers()) do
        if player == LocalPlayer then continue end
        if OxyoSettings.SilentAim.TeamCheck and player.Team == LocalPlayer.Team then continue end
        local character = player.Character
        if not character then continue end
        local humanoid = character:FindFirstChild("Humanoid")
        if not humanoid or humanoid.Health <= 0 then continue end
        local part = character:FindFirstChild(part_name)
        if not part then continue end
        local screen_position, on_screen = Camera:WorldToViewportPoint(part.Position)
        if not on_screen or screen_position.Z <= 0 then continue end
        local screen_distance = (Vector2.new(screen_position.X, screen_position.Y) - ref).Magnitude
        if screen_distance < closest_distance then
            closest_player = player
            closest_position = part.Position
            closest_distance = screen_distance
        end
    end
    return closest_player, closest_position
end
LPH_NO_UPVALUES = function(Function)
    return function(...)
        return Function(...)
    end
end
local silentAimHooked = false
local function initializeSilentAim()
    if silentAimHooked then return end
    local success, error_msg = pcall(function()
        local castRay

        if filtergc then
            local ok, res = pcall(filtergc, "function", {Name = "castRay"}, true)
            if ok then castRay = res end
        end

        if not castRay and getgc then
            local ok, gc = pcall(getgc, false)
            if ok and gc then
                local scanned = 0
                for _, obj in pairs(gc) do
                    scanned = scanned + 1
                    if scanned > 8000 then break end
                    if type(obj) == "function" then
                        local ok2, info = pcall(debug.getinfo, obj)
                        if ok2 and info and info.name == "castRay" then
                            castRay = obj
                            break
                        end
                    end
                end
            end
        end
        if castRay and hookfunction then
            local old_castRay
            old_castRay = hookfunction(castRay, LPH_NO_UPVALUES(function(...)
                if not OxyoSettings.SilentAim.Enabled then
                    return old_castRay(...)
                end
                if math.random(1, 100) > OxyoSettings.SilentAim.HitChance then
                    return old_castRay(...)
                end
                local target_part = OxyoSettings.SilentAim.TargetPart or "Head"
                local fov_size = OxyoSettings.SilentAim.FOVEnabled and OxyoSettings.SilentAim.FOVSize or math.huge
                local closest_player, closest_position = get_closest_player(target_part, fov_size)
                if closest_player and closest_position then
                    Stats.silentAimHits = Stats.silentAimHits + 1
                    return closest_player.Character[target_part], closest_position
                end
                return old_castRay(...)
            end))
            silentAimHooked = true
            Stats.hookSuccesses = Stats.hookSuccesses + 1
        else
            Stats.hookFailures = Stats.hookFailures + 1
        end
    end)
    if not success then
        Stats.lastError = error_msg
    end
end
task.spawn(function()
    initializeSilentAim()
    if not silentAimHooked then
        task.wait(3)
        initializeSilentAim()
    end
    if not silentAimHooked then
        task.wait(5)
        initializeSilentAim()
    end
end)
RunService.RenderStepped:Connect(function()
    local char = LocalPlayer.Character
    if not char then return end
    local hum = char:FindFirstChild("Humanoid")
    if hum then
        MovementController.targetSpeed = OxyoSettings.Player.WalkSpeed
        MovementController.targetJump = OxyoSettings.Player.JumpPower
        updateMovement(hum)
        pcall(function()
            hum.WalkSpeed = MovementController.currentSpeed
            hum.UseJumpPower = true
            hum.JumpPower = OxyoSettings.Player.JumpPower
        end)
        if OxyoSettings.Player.AutoJump and hum.FloorMaterial ~= Enum.Material.Air then
            local now = tick()
            if now - AntiDetection.lastJumpChange > AntiDetection.cooldowns.jump then
                if canJump() then
                    hum:ChangeState(Enum.HumanoidStateType.Jumping)
                    AntiDetection.lastJumpChange = now
                end
            end
        end
    end
end)
local JumpProtection = {
    enabled = true,
    lastJumpTime = 0,
    minJumpDelay = 0.25,
    maxJumpsPerSecond = 4,
    jumpHistory = {},
    historyDuration = 1,
    randomizeHeight = true,
    heightVariance = {0.88, 1.12},
    cooldownVariance = {0.2, 0.35},
    staminaEffect = true,
    lastJumpInterval = 0,
    intervalVariation = true,
    minIntervalChange = 0.08
}
local function cleanJumpHistory()
    local now = tick()
    local newHistory = {}
    for _, jumpTime in ipairs(JumpProtection.jumpHistory) do
        if now - jumpTime < JumpProtection.historyDuration then
            table.insert(newHistory, jumpTime)
        end
    end
    JumpProtection.jumpHistory = newHistory
end
local function canSafeJump()
    if not JumpProtection.enabled then return true end
    local now = tick()
    cleanJumpHistory()
    if #JumpProtection.jumpHistory >= JumpProtection.maxJumpsPerSecond then
        return false
    end
    local timeSinceLastJump = now - JumpProtection.lastJumpTime
    local minDelay = JumpProtection.minJumpDelay
    if JumpProtection.intervalVariation then
        minDelay = minDelay + randomFloat(-0.05, 0.05)
    end
    if timeSinceLastJump < minDelay then
        return false
    end
    if JumpProtection.intervalVariation then
        local intervalDiff = math.abs(timeSinceLastJump - JumpProtection.lastJumpInterval)
        if intervalDiff < JumpProtection.minIntervalChange and #JumpProtection.jumpHistory > 2 then
            task.wait(randomFloat(0.02, 0.08))
        end
        JumpProtection.lastJumpInterval = timeSinceLastJump
    end
    return true
end
local function recordJump()
    local now = tick()
    JumpProtection.lastJumpTime = now
    table.insert(JumpProtection.jumpHistory, now)
end
local InfiniteJumpEngine = {
    enabled = false,
    lastJumpTime = 0,
    jumpCount = 0,
    maxConsecutiveJumps = 5,
    resetTime = 1.2,
    disguise = {
        delays = {min = 0.05, max = 0.15, chance = 70},
        failedJumps = {chance = 18, heightRange = {0.35, 0.65}},
        heightVariation = {chance = 75, range = {0.88, 1.0}},
        humanDelay = {chance = 30, delay = {0.03, 0.09}},
        hesitation = {chance = 12, cancelJump = true}
    },
    patternBreaker = {
        skipChance = 15,
        microPauseChance = 20,
        microPauseDuration = {0.08, 0.2},
        history = {},
        maxHistory = 8,
        antiMechanical = true,
        sameHeightLimit = 3
    },
    fatigue = {threshold = 4, heightReduction = 0.15}
}
local recentHeights = {}
local function executeProtectedJump()
    if not InfiniteJumpEngine.enabled then return end
    local character = LocalPlayer.Character
    if not character then return end
    local humanoid = character:FindFirstChildOfClass('Humanoid')
    if not humanoid or humanoid:GetState() == Enum.HumanoidStateType.Dead then return end
    if not canSafeJump() then return end
    local now = tick()
    if now - InfiniteJumpEngine.lastJumpTime > InfiniteJumpEngine.resetTime then
        InfiniteJumpEngine.jumpCount = 0
    end
    if InfiniteJumpEngine.jumpCount >= InfiniteJumpEngine.maxConsecutiveJumps then
        if now - InfiniteJumpEngine.lastJumpTime < 0.5 then return end
        InfiniteJumpEngine.jumpCount = 0
    end
    if math.random(100) <= InfiniteJumpEngine.disguise.hesitation.chance then
        if InfiniteJumpEngine.disguise.hesitation.cancelJump then return end
    end
    if math.random(100) <= InfiniteJumpEngine.patternBreaker.skipChance then
        table.insert(InfiniteJumpEngine.patternBreaker.history, {type = "skip", time = now})
        if #InfiniteJumpEngine.patternBreaker.history > InfiniteJumpEngine.patternBreaker.maxHistory then
            table.remove(InfiniteJumpEngine.patternBreaker.history, 1)
        end
        return
    end
    if math.random(100) <= InfiniteJumpEngine.patternBreaker.microPauseChance then
        task.wait(randomFloat(
            InfiniteJumpEngine.patternBreaker.microPauseDuration[1],
            InfiniteJumpEngine.patternBreaker.microPauseDuration[2]
        ))
    end
    if math.random(100) <= InfiniteJumpEngine.disguise.humanDelay.chance then
        task.wait(randomFloat(
            InfiniteJumpEngine.disguise.humanDelay.delay[1],
            InfiniteJumpEngine.disguise.humanDelay.delay[2]
        ))
    end
    if math.random(100) <= InfiniteJumpEngine.disguise.failedJumps.chance then
        local partialHeight = randomFloat(
            InfiniteJumpEngine.disguise.failedJumps.heightRange[1],
            InfiniteJumpEngine.disguise.failedJumps.heightRange[2]
        )
        local originalJP = humanoid.JumpPower
        humanoid.JumpPower = originalJP * partialHeight
        humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
        task.delay(0.1, function()
            if humanoid then humanoid.JumpPower = originalJP end
        end)
        InfiniteJumpEngine.lastJumpTime = now
        InfiniteJumpEngine.jumpCount = InfiniteJumpEngine.jumpCount + 1
        recordJump()
        return
    end
    local heightMultiplier = 1.0
    if math.random(100) <= InfiniteJumpEngine.disguise.heightVariation.chance then
        heightMultiplier = randomFloat(
            InfiniteJumpEngine.disguise.heightVariation.range[1],
            InfiniteJumpEngine.disguise.heightVariation.range[2]
        )
        if InfiniteJumpEngine.patternBreaker.antiMechanical then
            local roundedHeight = math.floor(heightMultiplier * 100)
            local sameCount = 0
            for i = #recentHeights, math.max(1, #recentHeights - 5), -1 do
                if recentHeights[i] == roundedHeight then
                    sameCount = sameCount + 1
                end
            end
            if sameCount >= InfiniteJumpEngine.patternBreaker.sameHeightLimit then
                heightMultiplier = randomFloat(0.88, 0.96)
            end
            table.insert(recentHeights, roundedHeight)
            if #recentHeights > 10 then
                table.remove(recentHeights, 1)
            end
        end
    end
    if InfiniteJumpEngine.jumpCount >= InfiniteJumpEngine.fatigue.threshold then
        heightMultiplier = heightMultiplier * (1 - InfiniteJumpEngine.fatigue.heightReduction)
    end
    if SpeedProtection.staminaSimulation then
        local staminaMult = clamp(SpeedProtection.stamina / 100, 0.75, 1.0)
        heightMultiplier = heightMultiplier * staminaMult
    end
    pcall(function()
        local originalJP = humanoid.JumpPower
        humanoid.JumpPower = originalJP * heightMultiplier
        humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
        task.delay(0.1, function()
            if humanoid then humanoid.JumpPower = originalJP end
        end)
        InfiniteJumpEngine.lastJumpTime = now
        InfiniteJumpEngine.jumpCount = InfiniteJumpEngine.jumpCount + 1
        recordJump()
        if SpeedProtection.staminaSimulation then
            SpeedProtection.stamina = math.max(0, SpeedProtection.stamina - 1.5)
        end
        table.insert(InfiniteJumpEngine.patternBreaker.history, {
            type = "jump", time = now, height = heightMultiplier
        })
        if #InfiniteJumpEngine.patternBreaker.history > InfiniteJumpEngine.patternBreaker.maxHistory then
            table.remove(InfiniteJumpEngine.patternBreaker.history, 1)
        end
    end)
    if math.random(100) <= InfiniteJumpEngine.disguise.delays.chance then
        task.spawn(function()
            task.wait(randomFloat(InfiniteJumpEngine.disguise.delays.min, InfiniteJumpEngine.disguise.delays.max))
        end)
    end
end
UserInputService.JumpRequest:Connect(function()
    if OxyoSettings.Player.InfJump then
        InfiniteJumpEngine.enabled = true
        executeProtectedJump()
    else
        InfiniteJumpEngine.enabled = false
    end
end)
if isMobileDevice() then
    UserInputService.TouchTap:Connect(function(touchPositions, gameProcessedEvent)
        if not OxyoSettings.Player.InfJump then return end
        if gameProcessedEvent then return end
        if not canSafeJump() then return end
        local screenSize = Camera.ViewportSize
        local tapPos = touchPositions[1]
        if tapPos and tapPos.Y > screenSize.Y * 0.7 then
            local char = LocalPlayer.Character
            if char then
                local hum = char:FindFirstChildOfClass("Humanoid")
                if hum then
                    pcall(function()
                        if JumpProtection.randomizeHeight then
                            local variance = randomFloat(
                                JumpProtection.heightVariance[1],
                                JumpProtection.heightVariance[2]
                            )
                            local originalJump = hum.JumpPower
                            hum.JumpPower = originalJump * variance
                            task.spawn(function()
                                task.wait(0.1)
                                if hum then
                                    hum.JumpPower = originalJump
                                end
                            end)
                        end
                        hum:ChangeState(Enum.HumanoidStateType.Jumping)
                        recordJump()
                        if SpeedProtection.staminaSimulation then
                            SpeedProtection.stamina = math.max(0, SpeedProtection.stamina - 1.5)
                        end
                    end)
                end
            end
        end
    end)
end
local Teleports = {
    Yard = Vector3.new(751, 98, 2360),
    CriminalBase = Vector3.new(-920, 95, 2055),
    PoliceBase = Vector3.new(845, 100, 2267),
    Cafeteria = Vector3.new(925, 100, 2288),
    Cells = Vector3.new(914, 100, 2420),
    Armory = Vector3.new(796, 100, 2260),
    Gate = Vector3.new(504, 103, 2253),
    Garage = Vector3.new(617, 99, 2505)
}
local GunTeleports = {
    MP5 = Vector3.new(814.058289, 100.879997, 2228.882080),
    Shotgun = Vector3.new(820.068970, 100.795334, 2229.555908),
    AK = Vector3.new(-932.279297, 94.368423, 2039.058228),
    M700 = Vector3.new(835.937622, 100.820000, 2228.643066),
    M4A1 = Vector3.new(847.037415, 100.820274, 2228.479004),
    FAL = Vector3.new(-902.685669, 94.296814, 2048.017334)
}
local function AntiBan()
    safeCall(function()
        local scriptsFolder = ReplicatedStorage:FindFirstChild("Scripts")
        if scriptsFolder then
            local CharacterCollision = scriptsFolder:FindFirstChild("CharacterCollision")
            if CharacterCollision then pcall(function() CharacterCollision:Destroy() end) end
        end
        local head = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Head")
        if head and getconnections and head.GetPropertyChangedSignal then
            for _, con in pairs(getconnections(head:GetPropertyChangedSignal("CanCollide")) or {}) do
                pcall(function() con:Disable() end)
            end
        end
    end)
end
safeCall(AntiBan)
LocalPlayer.CharacterAdded:Connect(function()
    safeCall(AntiBan)
    task.wait(1)
    initializeSilentAim()
    task.spawn(function()
        local char = LocalPlayer.Character
        if char then
            local hum = char:WaitForChild("Humanoid", 5)
            if hum then
                pcall(function()
                    hum.UseJumpPower = true
                    hum.JumpPower = OxyoSettings.Player.JumpPower
                end)
            end
        end
    end)
end)

local GunModState = {
    enabled = false,
    hook = nil,
    originalNamecall = nil
}

local function enableGunMod()
    if GunModState.hook then return end
    pcall(function()
        local mt = getrawmetatable(game)
        local oldNC = mt.__namecall
        GunModState.originalNamecall = oldNC
        setreadonly(mt, false)
        GunModState.hook = newcclosure(function(self, ...)
            local method = getnamecallmethod()
            if method == "GetAttributes" then
                local ok, result = pcall(oldNC, self, ...)
                if ok and type(result) == "table" then
                    result.AutoFire = true
                    result.FireRate = 0
                    result.Range = 999999999
                    result.Spread = 999999999
                    return result
                end
                return result
            end
            return oldNC(self, ...)
        end)
        mt.__namecall = GunModState.hook
        setreadonly(mt, true)
    end)
    smartNotify("Gun Mod", "‚úÖ Enabled ‚Äî AutoFire ON | FireRate 0 | Range MAX", 2)
end

local function disableGunMod()
    if not GunModState.originalNamecall then return end
    pcall(function()
        local mt = getrawmetatable(game)
        setreadonly(mt, false)
        mt.__namecall = GunModState.originalNamecall
        setreadonly(mt, true)
        GunModState.hook = nil
        GunModState.originalNamecall = nil
    end)
    smartNotify("Gun Mod", "‚ùå Disabled ‚Äî Guns back to normal", 2)
end

SilentAimTab:CreateSection("Silent Aim Settings")
SilentAimTab:CreateToggle({
    Name = "Enable Silent Aim",
    CurrentValue = OxyoSettings.SilentAim.Enabled,
    Callback = function(val) OxyoSettings.SilentAim.Enabled = val end
})
SilentAimTab:CreateToggle({
    Name = "Team Check",
    CurrentValue = OxyoSettings.SilentAim.TeamCheck,
    Callback = function(val) OxyoSettings.SilentAim.TeamCheck = val end
})
SilentAimTab:CreateSlider({
    Name = "Hit Chance %",
    Range = {0, 100},
    Increment = 1,
    CurrentValue = OxyoSettings.SilentAim.HitChance,
    Callback = function(val) OxyoSettings.SilentAim.HitChance = val end
})
SilentAimTab:CreateDropdown({
    Name = "Target Part",
    Options = {"Head", "Torso", "HumanoidRootPart"},
    CurrentOption = OxyoSettings.SilentAim.TargetPart,
    Callback = function(opt) OxyoSettings.SilentAim.TargetPart = opt end
})
SilentAimTab:CreateSection("Silent Aim FOV")
SilentAimTab:CreateToggle({
    Name = "Show FOV Circle",
    CurrentValue = OxyoSettings.SilentAim.FOVEnabled,
    Callback = function(val)
        OxyoSettings.SilentAim.FOVEnabled = val
        if FOVFrame then
            FOVFrame.Visible = val
        end
        if SilentAimFOVCircle then
            SilentAimFOVCircle.Visible = val
        end
        print("[Oxyo] FOV Circle: " .. (val and "ON" or "OFF"))
    end
})
SilentAimTab:CreateSlider({
    Name = "FOV Size",
    Range = {10, 800},
    Increment = 10,
    CurrentValue = OxyoSettings.SilentAim.FOVSize,
    Callback = function(val) OxyoSettings.SilentAim.FOVSize = val end
})
SilentAimTab:CreateColorPicker({
    Name = "FOV Color",
    Color = OxyoSettings.SilentAim.FOVColor,
    Callback = function(col) OxyoSettings.SilentAim.FOVColor = col end
})
ESPTab:CreateSection("ESP Settings (Integrated)")
ESPTab:CreateToggle({
    Name = "Enable ESP",
    CurrentValue = getgenv().Toggle,
    Callback = function(val) getgenv().Toggle = val end
})
PlayerTab:CreateSection("Movement Controls")
PlayerTab:CreateButton({
    Name = "‚ö†Ô∏è Enhanced Anti-Ban Info",
    Callback = function()
    end
})
PlayerTab:CreateSlider({
    Name = "Walk Speed",
    Range = {16, 150},
    Increment = 1,
    CurrentValue = OxyoSettings.Player.WalkSpeed,
    Callback = function(val)
        OxyoSettings.Player.WalkSpeed = val
        local now = tick()
        if now - AntiDetection.lastSpeedChange > AntiDetection.cooldowns.speedChange then
            AntiDetection.lastSpeedChange = now
            AntiDetection.speedChangeCount = AntiDetection.speedChangeCount + 1
            updateSuspicion("speed", 5)
        end
    end
})
PlayerTab:CreateSlider({
    Name = "Jump Power",
    Range = {50, 100},
    Increment = 1,
    CurrentValue = OxyoSettings.Player.JumpPower,
    Callback = function(val)
        OxyoSettings.Player.JumpPower = val
        MovementController.targetJump = val
        MovementController.currentJump = val
        local char = LocalPlayer.Character
        if char then
            local hum = char:FindFirstChild("Humanoid")
            if hum then
                for i = 1, 3 do
                    pcall(function()
                        hum.UseJumpPower = true
                        hum.JumpPower = val
                    end)
                    task.wait(0.05)
                end
                print("[Oxyo] JumpPower set to: " .. val)
            end
        end
    end
})
PlayerTab:CreateToggle({
    Name = "Infinite Jump",
    CurrentValue = OxyoSettings.Player.InfJump,
    Callback = function(val)
        OxyoSettings.Player.InfJump = val
    end
})
PlayerTab:CreateToggle({
    Name = "Auto Jump",
    CurrentValue = OxyoSettings.Player.AutoJump,
    Callback = function(val) OxyoSettings.Player.AutoJump = val end
})
PlayerTab:CreateToggle({
    Name = "Noclip",
    CurrentValue = OxyoSettings.Player.Noclip,
    Callback = function(val)
        OxyoSettings.Player.Noclip = val
        toggleNoclip(val)
        if val then
            updateSuspicion("noclip", 20)
        end
    end
})

PlayerTab:CreateSection("üé≠ Character Modes")

PlayerTab:CreateToggle({
    Name = "Headless Mode",
    CurrentValue = false,
    Callback = function(val)
        CharacterModes.Headless:toggle(val)
    end
})

PlayerTab:CreateToggle({
    Name = "Kroblox Mode",
    CurrentValue = false,
    Callback = function(val)
        CharacterModes.Kroblox:toggle(val)
    end
})

PlayerTab:CreateButton({
    Name = "‚ÑπÔ∏è Character Modes Info",
    Callback = function()
    end
})

GunModTab:CreateSection("üî´ Gun Modifier")
GunModTab:CreateToggle({
    Name = "Gun Mod",
    CurrentValue = false,
    Callback = function(val)
        GunModState.enabled = val
        if val then
            enableGunMod()
        else
            disableGunMod()
        end
    end
})

TeleportTab:CreateSection("‚ö° Teleport Cooldown Info")
TeleportTab:CreateButton({
    Name = "üìã Cooldown Status",
    Callback = function()
        local st = TeleportValidator:getStatus()
        local msg
        if st.ready then
            local tpLeft = st.tpsUntilLong
            msg = "‚úÖ Ready | " .. st.count .. " total TPs | " .. tpLeft .. " until long CD"
        else
            local kind = st.isExtended and "‚è≥ Long CD" or "‚è± Short CD"
            local tpLeft = st.tpsUntilLong
            msg = kind .. ": " .. st.secondsLeft .. "s left | TP #" .. st.count .. " | " .. tpLeft .. " to long CD"
        end
        showNotification("Teleport Status", msg, 4)
    end
})
TeleportTab:CreateSection("üìç Locations")
for name, pos in pairs(Teleports) do
    TeleportTab:CreateButton({
        Name = "‚ö° " .. name,
        Callback = function()
            instantTeleport(pos)
        end
    })
end

GunsTab:CreateSection("üî´ Weapon Locations")
for gunName, gunPos in pairs(GunTeleports) do
    GunsTab:CreateButton({
        Name = "üî´ " .. gunName,
        Callback = function()
            gunTeleport(gunPos, gunName)
        end
    })
end
UITab:CreateSection("UI Controls")
UITab:CreateButton({
    Name = "‚ÑπÔ∏è Keybinds Info",
    Callback = function()
        print("[Oxyo] RIGHT SHIFT = Toggle UI visibility")
        print("[Oxyo] DELETE = Close UI completely")
        print("[Oxyo] HOME = Force close (clicks X button)")
    end
})
UITab:CreateButton({
    Name = "üëÅÔ∏è Toggle UI",
    Callback = function()
        toggleUI()
        print("[Oxyo] UI toggled!")
    end
})
UITab:CreateButton({
    Name = "‚ùå Close UI",
    Callback = function()
        destroyUI()
        print("[Oxyo] UI closed!")
    end
})
UITab:CreateButton({
    Name = "üî¥ Force Close (Click X)",
    Callback = function()
        pcall(function()
            for _, v in pairs(game.CoreGui:GetDescendants()) do
                if v:IsA("TextButton") and (v.Text == "X" or v.Name:find("Close")) then
                    for i = 1, 3 do
                        task.wait(0.1)
                        v.MouseButton1Click:Fire()
                        v.Activated:Fire()
                    end
                end
            end
        end)
        print("[Oxyo] Force close triggered!")
    end
})
UITab:CreateButton({
    Name = "üóëÔ∏è Destroy Script Completely",
    Callback = function()
        pcall(function()
            if heartbeatConnection then
                heartbeatConnection:Disconnect()
                print("[Oxyo] Anti-kick disabled")
            end
            if noclipConnection then
                noclipConnection:Disconnect()
                print("[Oxyo] Noclip disabled")
            end
            getgenv().Toggle = false
            for _, player in pairs(Players:GetPlayers()) do
                if player.Character then
                    local esp = player.Character:FindFirstChild("Totally NOT Esp")
                    local icon = player.Character:FindFirstChild("Icon")
                    if esp then esp:Destroy() end
                    if icon then icon:Destroy() end
                end
            end
            print("[Oxyo] ESP removed from all players")
            destroyUI()
            print("[Oxyo] ‚úÖ Script destroyed completely!")
        end)
    end
})
AtmosphereTab:CreateSection("‚ú® Legendary Atmosphere Effects")
local AtmosphereSettings = {
    Lighting = {
        enabled = false,
        brightness = 2,
        ambientColor = Color3.fromRGB(255, 255, 255),
        outdoorAmbient = Color3.fromRGB(127, 127, 127),
        fogEnabled = false,
        fogColor = Color3.fromRGB(191, 191, 191),
        fogStart = 0,
        fogEnd = 100000,
    },
    TimeOfDay = {
        enabled = false,
        currentTime = "14:00:00",
        timeSpeed = 0,
    },
    Atmosphere = {
        enabled = false,
        density = 0.364,
        offset = 0.25,
        color = Color3.fromRGB(199, 199, 199),
        decay = Color3.fromRGB(106, 112, 125),
        glare = 0,
        haze = 0,
    },
    Bloom = {
        enabled = false,
        intensity = 0.4,
        size = 24,
        threshold = 0.95,
    },
    Blur = {
        enabled = false,
        size = 5,
    },
    ColorCorrection = {
        enabled = false,
        brightness = 0,
        contrast = 0,
        saturation = 0,
        tintColor = Color3.fromRGB(255, 255, 255),
    },
    SunRays = {
        enabled = false,
        intensity = 0.01,
        spread = 0.1,
    },
    DepthOfField = {
        enabled = false,
        farIntensity = 0.1,
        focusDistance = 0.05,
        inFocusRadius = 30,
        nearIntensity = 0.75,
    },
}
local OriginalLighting = {
    Brightness = game.Lighting.Brightness,
    Ambient = game.Lighting.Ambient,
    OutdoorAmbient = game.Lighting.OutdoorAmbient,
    FogColor = game.Lighting.FogColor,
    FogStart = game.Lighting.FogStart,
    FogEnd = game.Lighting.FogEnd,
    ClockTime = game.Lighting.ClockTime,
}
local function getOrCreateEffect(className, parent)
    parent = parent or game.Lighting
    local existing = parent:FindFirstChildOfClass(className)
    if existing then return existing end
    local new = Instance.new(className)
    new.Parent = parent
    return new
end
local function removeEffect(className, parent)
    parent = parent or game.Lighting
    local effect = parent:FindFirstChildOfClass(className)
    if effect then
        pcall(function() effect:Destroy() end)
    end
end
AtmosphereTab:CreateSection("üé® Epic Atmosphere Presets")
AtmosphereTab:CreateButton({
    Name = "üåÖ Sunrise Paradise",
    Callback = function()
        pcall(function()
            game.Lighting.Brightness = 2.5
            game.Lighting.Ambient = Color3.fromRGB(255, 200, 150)
            game.Lighting.OutdoorAmbient = Color3.fromRGB(255, 180, 120)
            game.Lighting.FogColor = Color3.fromRGB(255, 220, 180)
            game.Lighting.FogStart = 100
            game.Lighting.FogEnd = 5000
            game.Lighting.ClockTime = 6.5
            local atmos = getOrCreateEffect("Atmosphere")
            atmos.Density = 0.3
            atmos.Offset = 0.5
            atmos.Color = Color3.fromRGB(255, 200, 150)
            atmos.Decay = Color3.fromRGB(255, 150, 100)
            atmos.Glare = 0.5
            atmos.Haze = 1.5
            local bloom = getOrCreateEffect("BloomEffect")
            bloom.Enabled = true
            bloom.Intensity = 0.8
            bloom.Size = 32
            bloom.Threshold = 0.8
            local sun = getOrCreateEffect("SunRaysEffect")
            sun.Enabled = true
            sun.Intensity = 0.15
            sun.Spread = 0.5
            local cc = getOrCreateEffect("ColorCorrectionEffect")
            cc.Enabled = true
            cc.Brightness = 0.1
            cc.Contrast = 0.1
            cc.Saturation = 0.3
            cc.TintColor = Color3.fromRGB(255, 240, 220)
            print("[Oxyo] üåÖ Sunrise Paradise atmosphere activated!")
        end)
    end
})
AtmosphereTab:CreateButton({
    Name = "üåô Midnight Mystery",
    Callback = function()
        pcall(function()
            game.Lighting.Brightness = 0.5
            game.Lighting.Ambient = Color3.fromRGB(50, 50, 80)
            game.Lighting.OutdoorAmbient = Color3.fromRGB(30, 30, 60)
            game.Lighting.FogColor = Color3.fromRGB(20, 20, 40)
            game.Lighting.FogStart = 50
            game.Lighting.FogEnd = 2000
            game.Lighting.ClockTime = 0
            local atmos = getOrCreateEffect("Atmosphere")
            atmos.Density = 0.5
            atmos.Offset = 0.2
            atmos.Color = Color3.fromRGB(80, 80, 120)
            atmos.Decay = Color3.fromRGB(40, 40, 80)
            atmos.Glare = 0
            atmos.Haze = 2
            local bloom = getOrCreateEffect("BloomEffect")
            bloom.Enabled = true
            bloom.Intensity = 0.3
            bloom.Size = 24
            bloom.Threshold = 1
            local cc = getOrCreateEffect("ColorCorrectionEffect")
            cc.Enabled = true
            cc.Brightness = -0.2
            cc.Contrast = 0.3
            cc.Saturation = -0.2
            cc.TintColor = Color3.fromRGB(100, 100, 150)
            local blur = getOrCreateEffect("BlurEffect")
            blur.Enabled = true
            blur.Size = 3
            print("[Oxyo] üåô Midnight Mystery atmosphere activated!")
        end)
    end
})
AtmosphereTab:CreateButton({
    Name = "üî• Inferno Realm",
    Callback = function()
        pcall(function()
            game.Lighting.Brightness = 3
            game.Lighting.Ambient = Color3.fromRGB(255, 100, 0)
            game.Lighting.OutdoorAmbient = Color3.fromRGB(255, 80, 0)
            game.Lighting.FogColor = Color3.fromRGB(255, 60, 0)
            game.Lighting.FogStart = 0
            game.Lighting.FogEnd = 1500
            game.Lighting.ClockTime = 18
            local atmos = getOrCreateEffect("Atmosphere")
            atmos.Density = 0.6
            atmos.Offset = 0.3
            atmos.Color = Color3.fromRGB(255, 100, 50)
            atmos.Decay = Color3.fromRGB(200, 0, 0)
            atmos.Glare = 1
            atmos.Haze = 3
            local bloom = getOrCreateEffect("BloomEffect")
            bloom.Enabled = true
            bloom.Intensity = 1.2
            bloom.Size = 40
            bloom.Threshold = 0.7
            local sun = getOrCreateEffect("SunRaysEffect")
            sun.Enabled = true
            sun.Intensity = 0.25
            sun.Spread = 0.8
            local cc = getOrCreateEffect("ColorCorrectionEffect")
            cc.Enabled = true
            cc.Brightness = 0.2
            cc.Contrast = 0.4
            cc.Saturation = 0.5
            cc.TintColor = Color3.fromRGB(255, 150, 100)
            print("[Oxyo] üî• Inferno Realm atmosphere activated!")
        end)
    end
})
AtmosphereTab:CreateButton({
    Name = "‚ùÑÔ∏è Frozen Tundra",
    Callback = function()
        pcall(function()
            game.Lighting.Brightness = 3
            game.Lighting.Ambient = Color3.fromRGB(200, 230, 255)
            game.Lighting.OutdoorAmbient = Color3.fromRGB(180, 220, 255)
            game.Lighting.FogColor = Color3.fromRGB(220, 240, 255)
            game.Lighting.FogStart = 200
            game.Lighting.FogEnd = 3000
            game.Lighting.ClockTime = 12
            local atmos = getOrCreateEffect("Atmosphere")
            atmos.Density = 0.4
            atmos.Offset = 0.4
            atmos.Color = Color3.fromRGB(200, 230, 255)
            atmos.Decay = Color3.fromRGB(150, 200, 255)
            atmos.Glare = 0.3
            atmos.Haze = 1
            local bloom = getOrCreateEffect("BloomEffect")
            bloom.Enabled = true
            bloom.Intensity = 0.6
            bloom.Size = 28
            bloom.Threshold = 0.9
            local cc = getOrCreateEffect("ColorCorrectionEffect")
            cc.Enabled = true
            cc.Brightness = 0.15
            cc.Contrast = 0.2
            cc.Saturation = -0.1
            cc.TintColor = Color3.fromRGB(220, 240, 255)
            local blur = getOrCreateEffect("BlurEffect")
            blur.Enabled = true
            blur.Size = 2
            print("[Oxyo] ‚ùÑÔ∏è Frozen Tundra atmosphere activated!")
        end)
    end
})
AtmosphereTab:CreateButton({
    Name = "üå≥ Enchanted Forest",
    Callback = function()
        pcall(function()
            game.Lighting.Brightness = 1.5
            game.Lighting.Ambient = Color3.fromRGB(100, 200, 100)
            game.Lighting.OutdoorAmbient = Color3.fromRGB(80, 180, 80)
            game.Lighting.FogColor = Color3.fromRGB(150, 255, 150)
            game.Lighting.FogStart = 100
            game.Lighting.FogEnd = 2500
            game.Lighting.ClockTime = 14
            local atmos = getOrCreateEffect("Atmosphere")
            atmos.Density = 0.35
            atmos.Offset = 0.45
            atmos.Color = Color3.fromRGB(150, 255, 150)
            atmos.Decay = Color3.fromRGB(100, 200, 100)
            atmos.Glare = 0.2
            atmos.Haze = 1.2
            local bloom = getOrCreateEffect("BloomEffect")
            bloom.Enabled = true
            bloom.Intensity = 0.5
            bloom.Size = 26
            bloom.Threshold = 0.85
            local sun = getOrCreateEffect("SunRaysEffect")
            sun.Enabled = true
            sun.Intensity = 0.12
            sun.Spread = 0.3
            local cc = getOrCreateEffect("ColorCorrectionEffect")
            cc.Enabled = true
            cc.Brightness = 0.05
            cc.Contrast = 0.15
            cc.Saturation = 0.4
            cc.TintColor = Color3.fromRGB(200, 255, 200)
            print("[Oxyo] üå≥ Enchanted Forest atmosphere activated!")
        end)
    end
})
AtmosphereTab:CreateButton({
    Name = "üåä Ocean Depths",
    Callback = function()
        pcall(function()
            game.Lighting.Brightness = 0.8
            game.Lighting.Ambient = Color3.fromRGB(50, 100, 150)
            game.Lighting.OutdoorAmbient = Color3.fromRGB(30, 80, 130)
            game.Lighting.FogColor = Color3.fromRGB(40, 90, 140)
            game.Lighting.FogStart = 0
            game.Lighting.FogEnd = 800
            game.Lighting.ClockTime = 10
            local atmos = getOrCreateEffect("Atmosphere")
            atmos.Density = 0.7
            atmos.Offset = 0.15
            atmos.Color = Color3.fromRGB(80, 130, 180)
            atmos.Decay = Color3.fromRGB(50, 100, 150)
            atmos.Glare = 0
            atmos.Haze = 2.5
            local bloom = getOrCreateEffect("BloomEffect")
            bloom.Enabled = true
            bloom.Intensity = 0.35
            bloom.Size = 20
            bloom.Threshold = 1
            local cc = getOrCreateEffect("ColorCorrectionEffect")
            cc.Enabled = true
            cc.Brightness = -0.1
            cc.Contrast = 0.25
            cc.Saturation = 0.2
            cc.TintColor = Color3.fromRGB(100, 150, 200)
            local blur = getOrCreateEffect("BlurEffect")
            blur.Enabled = true
            blur.Size = 4
            print("[Oxyo] üåä Ocean Depths atmosphere activated!")
        end)
    end
})
AtmosphereTab:CreateButton({
    Name = "üå∏ Cherry Blossom Dream",
    Callback = function()
        pcall(function()
            game.Lighting.Brightness = 2.2
            game.Lighting.Ambient = Color3.fromRGB(255, 200, 220)
            game.Lighting.OutdoorAmbient = Color3.fromRGB(255, 180, 200)
            game.Lighting.FogColor = Color3.fromRGB(255, 220, 230)
            game.Lighting.FogStart = 150
            game.Lighting.FogEnd = 4000
            game.Lighting.ClockTime = 16
            local atmos = getOrCreateEffect("Atmosphere")
            atmos.Density = 0.32
            atmos.Offset = 0.55
            atmos.Color = Color3.fromRGB(255, 200, 220)
            atmos.Decay = Color3.fromRGB(255, 150, 180)
            atmos.Glare = 0.4
            atmos.Haze = 1.3
            local bloom = getOrCreateEffect("BloomEffect")
            bloom.Enabled = true
            bloom.Intensity = 0.7
            bloom.Size = 30
            bloom.Threshold = 0.82
            local sun = getOrCreateEffect("SunRaysEffect")
            sun.Enabled = true
            sun.Intensity = 0.18
            sun.Spread = 0.4
            local cc = getOrCreateEffect("ColorCorrectionEffect")
            cc.Enabled = true
            cc.Brightness = 0.12
            cc.Contrast = 0.08
            cc.Saturation = 0.35
            cc.TintColor = Color3.fromRGB(255, 230, 240)
            print("[Oxyo] üå∏ Cherry Blossom Dream atmosphere activated!")
        end)
    end
})
AtmosphereTab:CreateButton({
    Name = "üåå Cosmic Void",
    Callback = function()
        pcall(function()
            game.Lighting.Brightness = 0.3
            game.Lighting.Ambient = Color3.fromRGB(80, 50, 120)
            game.Lighting.OutdoorAmbient = Color3.fromRGB(60, 30, 100)
            game.Lighting.FogColor = Color3.fromRGB(40, 20, 80)
            game.Lighting.FogStart = 0
            game.Lighting.FogEnd = 1000
            game.Lighting.ClockTime = 0
            local atmos = getOrCreateEffect("Atmosphere")
            atmos.Density = 0.8
            atmos.Offset = 0.1
            atmos.Color = Color3.fromRGB(100, 50, 150)
            atmos.Decay = Color3.fromRGB(60, 20, 100)
            atmos.Glare = 0.8
            atmos.Haze = 3
            local bloom = getOrCreateEffect("BloomEffect")
            bloom.Enabled = true
            bloom.Intensity = 1
            bloom.Size = 35
            bloom.Threshold = 0.6
            local cc = getOrCreateEffect("ColorCorrectionEffect")
            cc.Enabled = true
            cc.Brightness = -0.15
            cc.Contrast = 0.5
            cc.Saturation = 0.6
            cc.TintColor = Color3.fromRGB(120, 80, 160)
            local blur = getOrCreateEffect("BlurEffect")
            blur.Enabled = true
            blur.Size = 5
            print("[Oxyo] üåå Cosmic Void atmosphere activated!")
        end)
    end
})
AtmosphereTab:CreateButton({
    Name = "‚ú® Golden Hour Magic",
    Callback = function()
        pcall(function()
            game.Lighting.Brightness = 2.8
            game.Lighting.Ambient = Color3.fromRGB(255, 220, 150)
            game.Lighting.OutdoorAmbient = Color3.fromRGB(255, 200, 120)
            game.Lighting.FogColor = Color3.fromRGB(255, 230, 180)
            game.Lighting.FogStart = 250
            game.Lighting.FogEnd = 6000
            game.Lighting.ClockTime = 17.5
            local atmos = getOrCreateEffect("Atmosphere")
            atmos.Density = 0.28
            atmos.Offset = 0.6
            atmos.Color = Color3.fromRGB(255, 220, 170)
            atmos.Decay = Color3.fromRGB(255, 180, 100)
            atmos.Glare = 0.7
            atmos.Haze = 1.8
            local bloom = getOrCreateEffect("BloomEffect")
            bloom.Enabled = true
            bloom.Intensity = 0.9
            bloom.Size = 34
            bloom.Threshold = 0.75
            local sun = getOrCreateEffect("SunRaysEffect")
            sun.Enabled = true
            sun.Intensity = 0.22
            sun.Spread = 0.6
            local cc = getOrCreateEffect("ColorCorrectionEffect")
            cc.Enabled = true
            cc.Brightness = 0.18
            cc.Contrast = 0.12
            cc.Saturation = 0.45
            cc.TintColor = Color3.fromRGB(255, 245, 220)
            print("[Oxyo] ‚ú® Golden Hour Magic atmosphere activated!")
        end)
    end
})
AtmosphereTab:CreateButton({
    Name = "üéÜ Neon Cyberpunk",
    Callback = function()
        pcall(function()
            game.Lighting.Brightness = 1.2
            game.Lighting.Ambient = Color3.fromRGB(255, 0, 150)
            game.Lighting.OutdoorAmbient = Color3.fromRGB(200, 0, 200)
            game.Lighting.FogColor = Color3.fromRGB(150, 0, 200)
            game.Lighting.FogStart = 50
            game.Lighting.FogEnd = 1800
            game.Lighting.ClockTime = 22
            local atmos = getOrCreateEffect("Atmosphere")
            atmos.Density = 0.55
            atmos.Offset = 0.25
            atmos.Color = Color3.fromRGB(255, 50, 200)
            atmos.Decay = Color3.fromRGB(150, 0, 255)
            atmos.Glare = 1.2
            atmos.Haze = 2.2
            local bloom = getOrCreateEffect("BloomEffect")
            bloom.Enabled = true
            bloom.Intensity = 1.5
            bloom.Size = 45
            bloom.Threshold = 0.5
            local cc = getOrCreateEffect("ColorCorrectionEffect")
            cc.Enabled = true
            cc.Brightness = 0
            cc.Contrast = 0.6
            cc.Saturation = 0.8
            cc.TintColor = Color3.fromRGB(200, 100, 255)
            local blur = getOrCreateEffect("BlurEffect")
            blur.Enabled = true
            blur.Size = 6
            print("[Oxyo] üéÜ Neon Cyberpunk atmosphere activated!")
        end)
    end
})
AtmosphereTab:CreateButton({
    Name = "üîÜ Reset to Normal",
    Callback = function()
        pcall(function()
            game.Lighting.Brightness = OriginalLighting.Brightness
            game.Lighting.Ambient = OriginalLighting.Ambient
            game.Lighting.OutdoorAmbient = OriginalLighting.OutdoorAmbient
            game.Lighting.FogColor = OriginalLighting.FogColor
            game.Lighting.FogStart = OriginalLighting.FogStart
            game.Lighting.FogEnd = OriginalLighting.FogEnd
            game.Lighting.ClockTime = OriginalLighting.ClockTime
            removeEffect("Atmosphere")
            removeEffect("BloomEffect")
            removeEffect("BlurEffect")
            removeEffect("ColorCorrectionEffect")
            removeEffect("SunRaysEffect")
            removeEffect("DepthOfFieldEffect")
            print("[Oxyo] üîÜ Atmosphere reset to normal!")
        end)
    end
})
AtmosphereTab:CreateSection("üé® Custom Atmosphere Controls")
AtmosphereTab:CreateSlider({
    Name = "üïê Time of Day",
    Range = {0, 24},
    Increment = 0.5,
    CurrentValue = 14,
    Callback = function(value)
        pcall(function()
            game.Lighting.ClockTime = value
        end)
    end
})
AtmosphereTab:CreateSlider({
    Name = "üí° Brightness",
    Range = {0, 5},
    Increment = 0.1,
    CurrentValue = 2,
    Callback = function(value)
        pcall(function()
            game.Lighting.Brightness = value
        end)
    end
})
AtmosphereTab:CreateSlider({
    Name = "üå´Ô∏è Fog Density",
    Range = {100, 10000},
    Increment = 100,
    CurrentValue = 5000,
    Callback = function(value)
        pcall(function()
            game.Lighting.FogEnd = value
            game.Lighting.FogStart = math.max(0, value * 0.1)
        end)
    end
})
AtmosphereTab:CreateSlider({
    Name = "üåç Atmosphere Density",
    Range = {0, 1},
    Increment = 0.01,
    CurrentValue = 0.364,
    Callback = function(value)
        pcall(function()
            local atmos = getOrCreateEffect("Atmosphere")
            atmos.Density = value
        end)
    end
})
AtmosphereTab:CreateSlider({
    Name = "‚ú® Atmosphere Haze",
    Range = {0, 5},
    Increment = 0.1,
    CurrentValue = 0,
    Callback = function(value)
        pcall(function()
            local atmos = getOrCreateEffect("Atmosphere")
            atmos.Haze = value
        end)
    end
})
AtmosphereTab:CreateSlider({
    Name = "‚òÄÔ∏è Atmosphere Glare",
    Range = {0, 2},
    Increment = 0.1,
    CurrentValue = 0,
    Callback = function(value)
        pcall(function()
            local atmos = getOrCreateEffect("Atmosphere")
            atmos.Glare = value
        end)
    end
})
AtmosphereTab:CreateSlider({
    Name = "üåü Bloom Intensity",
    Range = {0, 2},
    Increment = 0.1,
    CurrentValue = 0.4,
    Callback = function(value)
        pcall(function()
            local bloom = getOrCreateEffect("BloomEffect")
            bloom.Enabled = value > 0
            bloom.Intensity = value
        end)
    end
})
AtmosphereTab:CreateSlider({
    Name = "üìè Bloom Size",
    Range = {1, 56},
    Increment = 1,
    CurrentValue = 24,
    Callback = function(value)
        pcall(function()
            local bloom = getOrCreateEffect("BloomEffect")
            bloom.Size = value
        end)
    end
})
AtmosphereTab:CreateSlider({
    Name = "üåÄ Blur Amount",
    Range = {0, 24},
    Increment = 1,
    CurrentValue = 0,
    Callback = function(value)
        pcall(function()
            local blur = getOrCreateEffect("BlurEffect")
            blur.Enabled = value > 0
            blur.Size = value
        end)
    end
})
AtmosphereTab:CreateSlider({
    Name = "üé® Color Saturation",
    Range = {-1, 1},
    Increment = 0.05,
    CurrentValue = 0,
    Callback = function(value)
        pcall(function()
            local cc = getOrCreateEffect("ColorCorrectionEffect")
            cc.Enabled = true
            cc.Saturation = value
        end)
    end
})
AtmosphereTab:CreateSlider({
    Name = "‚öñÔ∏è Color Contrast",
    Range = {-1, 1},
    Increment = 0.05,
    CurrentValue = 0,
    Callback = function(value)
        pcall(function()
            local cc = getOrCreateEffect("ColorCorrectionEffect")
            cc.Enabled = true
            cc.Contrast = value
        end)
    end
})
AtmosphereTab:CreateSlider({
    Name = "‚òÄÔ∏è Sun Rays Intensity",
    Range = {0, 0.5},
    Increment = 0.01,
    CurrentValue = 0,
    Callback = function(value)
        pcall(function()
            local sun = getOrCreateEffect("SunRaysEffect")
            sun.Enabled = value > 0
            sun.Intensity = value
        end)
    end
})
AtmosphereTab:CreateSlider({
    Name = "üì° Sun Rays Spread",
    Range = {0, 1},
    Increment = 0.05,
    CurrentValue = 0.1,
    Callback = function(value)
        pcall(function()
            local sun = getOrCreateEffect("SunRaysEffect")
            sun.Spread = value
        end)
    end
})
AtmosphereTab:CreateSection("üé¨ Special Visual Effects")
AtmosphereTab:CreateToggle({
    Name = "üì∑ Depth of Field (Camera Focus)",
    CurrentValue = false,
    Callback = function(value)
        pcall(function()
            if value then
                local dof = getOrCreateEffect("DepthOfFieldEffect")
                dof.Enabled = true
                dof.FarIntensity = 0.1
                dof.FocusDistance = 0.05
                dof.InFocusRadius = 30
                dof.NearIntensity = 0.75
                print("[Oxyo] Depth of Field enabled!")
            else
                removeEffect("DepthOfFieldEffect")
                print("[Oxyo] Depth of Field disabled!")
            end
        end)
    end
})
local rainbowActive = false
local rainbowConnection
AtmosphereTab:CreateToggle({
    Name = "üåà Rainbow Sky Cycle",
    CurrentValue = false,
    Callback = function(value)
        rainbowActive = value
        if value then
            print("[Oxyo] üåà Rainbow Sky activated!")
            rainbowConnection = RunService.Heartbeat:Connect(function()
                if not rainbowActive then return end
                pcall(function()
                    local hue = (tick() % 10) / 10
                    local color = Color3.fromHSV(hue, 1, 1)
                    game.Lighting.Ambient = color
                    game.Lighting.OutdoorAmbient = color
                    local atmos = getOrCreateEffect("Atmosphere")
                    atmos.Color = color
                end)
            end)
        else
            if rainbowConnection then
                rainbowConnection:Disconnect()
            end
            print("[Oxyo] üåà Rainbow Sky deactivated!")
        end
    end
})
AtmosphereTab:CreateButton({
    Name = "üí• Flashbang (Instant Bright)",
    Callback = function()
        pcall(function()
            local oldBright = game.Lighting.Brightness
            game.Lighting.Brightness = 10
            local cc = getOrCreateEffect("ColorCorrectionEffect")
            local oldCCBright = cc.Brightness
            cc.Enabled = true
            cc.Brightness = 1
            task.wait(0.5)
            game.Lighting.Brightness = oldBright
            cc.Brightness = oldCCBright
            print("[Oxyo] üí• Flashbang executed!")
        end)
    end
})
AtmosphereTab:CreateButton({
    Name = "üåä Earthquake Effect (5s)",
    Callback = function()
        pcall(function()
            local camera = workspace.CurrentCamera
            local startTime = tick()
            local duration = 5
            print("[Oxyo] üåä Earthquake started!")
            local shakeConnection
            shakeConnection = RunService.RenderStepped:Connect(function()
                if tick() - startTime > duration then
                    shakeConnection:Disconnect()
                    camera.CFrame = camera.CFrame
                    print("[Oxyo] üåä Earthquake ended!")
                    return
                end
                local shake = Vector3.new(
                    math.random(-100, 100) / 100,
                    math.random(-100, 100) / 100,
                    math.random(-100, 100) / 100
                )
                camera.CFrame = camera.CFrame * CFrame.new(shake * 0.5)
            end)
        end)
    end
})
local pulseActive = false
local pulseConnection
AtmosphereTab:CreateToggle({
    Name = "üíì Pulsating Light",
    CurrentValue = false,
    Callback = function(value)
        pulseActive = value
        if value then
            print("[Oxyo] üíì Pulsating light activated!")
            pulseConnection = RunService.Heartbeat:Connect(function()
                if not pulseActive then return end
                pcall(function()
                    local pulse = math.abs(math.sin(tick() * 2))
                    game.Lighting.Brightness = 1 + (pulse * 2)
                end)
            end)
        else
            if pulseConnection then
                pulseConnection:Disconnect()
            end
            game.Lighting.Brightness = 2
            print("[Oxyo] üíì Pulsating light deactivated!")
        end
    end
})
local cycleActive = false
local cycleConnection
AtmosphereTab:CreateToggle({
    Name = "üåó Auto Day/Night Cycle",
    CurrentValue = false,
    Callback = function(value)
        cycleActive = value
        if value then
            print("[Oxyo] üåó Day/Night cycle activated!")
            cycleConnection = RunService.Heartbeat:Connect(function()
                if not cycleActive then return end
                pcall(function()
                    game.Lighting.ClockTime = game.Lighting.ClockTime + 0.01
                end)
            end)
        else
            if cycleConnection then
                cycleConnection:Disconnect()
            end
            print("[Oxyo] üåó Day/Night cycle deactivated!")
        end
    end
})
print("[Oxyo] ‚ú® Atmosphere Tab loaded successfully!")
print("[Oxyo] üåü 10 Epic Presets + Custom Controls + Special FX available!")
local AtmosphereSettings = {
    Lighting = {
        enabled = false,
        brightness = 2,
        ambientColor = Color3.fromRGB(255, 255, 255),
        outdoorAmbient = Color3.fromRGB(127, 127, 127),
        fogEnabled = false,
        fogColor = Color3.fromRGB(191, 191, 191),
        fogStart = 0,
        fogEnd = 100000,
    },
    TimeOfDay = {
        enabled = false,
        currentTime = "14:00:00",
        timeSpeed = 0,
    },
    Atmosphere = {
        enabled = false,
        density = 0.364,
        offset = 0.25,
        color = Color3.fromRGB(199, 199, 199),
        decay = Color3.fromRGB(106, 112, 125),
        glare = 0,
        haze = 0,
    },
    Bloom = {
        enabled = false,
        intensity = 0.4,
        size = 24,
        threshold = 0.95,
    },
    Blur = {
        enabled = false,
        size = 5,
    },
    ColorCorrection = {
        enabled = false,
        brightness = 0,
        contrast = 0,
        saturation = 0,
        tintColor = Color3.fromRGB(255, 255, 255),
    },
    SunRays = {
        enabled = false,
        intensity = 0.01,
        spread = 0.1,
    },
    DepthOfField = {
        enabled = false,
        farIntensity = 0.1,
        focusDistance = 0.05,
        inFocusRadius = 30,
        nearIntensity = 0.75,
    },
}
local OriginalLighting = {
    Brightness = game.Lighting.Brightness,
    Ambient = game.Lighting.Ambient,
    OutdoorAmbient = game.Lighting.OutdoorAmbient,
    FogColor = game.Lighting.FogColor,
    FogStart = game.Lighting.FogStart,
    FogEnd = game.Lighting.FogEnd,
    ClockTime = game.Lighting.ClockTime,
}
local function getOrCreateEffect(className, parent)
    parent = parent or game.Lighting
    local existing = parent:FindFirstChildOfClass(className)
    if existing then return existing end
    local new = Instance.new(className)
    new.Parent = parent
    return new
end
local function removeEffect(className, parent)
    parent = parent or game.Lighting
    local effect = parent:FindFirstChildOfClass(className)
    if effect then
        pcall(function() effect:Destroy() end)
    end
end
print("    üé≠ Behavior: 100% Natural & Smooth")
print("    ‚ö° Performance: Zero Lag, Perfect Speed")
print("    Layer 1: CFrame Spoofing")
print("       ‚Ä¢ Micro-offset injection (invisible)")
print("       ‚Ä¢ Cache system (15 entries)")
print("       ‚Ä¢ Detection pattern breaking")
print("    Layer 2: Memory Protection")
print("       ‚Ä¢ XOR-based value encryption")
print("       ‚Ä¢ Protected value storage")
print("       ‚Ä¢ Secure retrieval system")
print("    Layer 3: Hook Detection & Prevention")
print("       ‚Ä¢ Original function preservation")
print("       ‚Ä¢ Hook detection mechanisms")
print("       ‚Ä¢ Bypass execution paths")
print("    Layer 4: Velocity Masking")
print("       ‚Ä¢ Safe velocity threshold (50)")
print("       ‚Ä¢ Instant velocity cloaking")
print("       ‚Ä¢ Deferred restoration")
print("[üîê] DENIABILITY ENGINE V2: ENHANCED")
print("    üß† Advanced Decision Making")
print("       ‚Ä¢ Adaptive: 75% base (¬±20% dynamic)")
print("       ‚Ä¢ Anti-Pattern: Max 3 repeats")
print("       ‚Ä¢ Delay: 12% | Reject: 8% | Alt: 5%")
print("    ‚öñÔ∏è External Justifications (15 types)")
print("       ‚Ä¢ Network, Physics, Camera")
print("       ‚Ä¢ Position, System reconciliation")
print("    üí• Enhanced Failure Simulation")
print("       ‚Ä¢ Micro Correction: 55%")
print("       ‚Ä¢ Overshoot: 35% | Drift: 30%")
print("       ‚Ä¢ Stutter: 20% | Momentum: 25%")
print("    üßπ Memory & Pattern Breaking")
print("       ‚Ä¢ Forget: 50% | Modify: 40%")
print("       ‚Ä¢ Time Decay: 15%/s")
print("       ‚Ä¢ Pattern Break: After 3x")
print("    üé≠ Action Disguise")
print("       ‚Ä¢ Prefix: 45% | Suffix: 45%")
print("       ‚Ä¢ Fake: 25% | Noise: 35%")
print("[üî•] PROTECTION PHILOSOPHY:")
print("    ‚ùå ŸÑÿß ŸäŸÖŸÜÿπ ÿßŸÑŸÉÿ¥ŸÅ")
print("    ‚úÖ ŸäŸÖŸÜÿπ ÿ•ÿ´ÿ®ÿßÿ™ ÿßŸÑŸÜŸäÿ©")
print("    ‚úÖ Ÿäÿ≥ÿ™ÿÆÿØŸÖ ÿ™ŸÇŸÜŸäÿßÿ™ Bypass ŸÖÿ™ŸÇÿØŸÖÿ©")
print("    ÿßŸÑŸÅÿπŸÑ ‚úîÔ∏è | ÿßŸÑŸÜŸäÿ© ‚ùå | ÿßŸÑŸÜŸÖÿ∑ ‚ùå | ÿßŸÑÿ•ÿ´ÿ®ÿßÿ™ ‚ùå")
print("[üéØ] Protection Level: Noclip 99%+ ‚ö° | Teleport 99.5% | Overall ~99%+")
print("[‚è∞] Noclip Duration: UNLIMITED - No Auto-Disable!")
print("[‚ú®] V9.1: GUN FIX UPDATE - WEAPON SYSTEM RESTORED! üéØ")
print("[üÜï] V9.1 CRITICAL FIX:")
print("    ‚úÖ FIXED: Gun system now works 100%!")
print("    ‚úÖ FIXED: Can damage/kill players again!")
print("    ‚úÖ Smart packet filtering (allows gun events)")
print("    ‚úÖ ServerSpoofing disabled by default (safer)")
print("[üî´] GUN SYSTEM STATUS:")
task.spawn(function()
    task.wait(0.5)
    local char = LocalPlayer.Character
    if char then
        local hum = char:FindFirstChild("Humanoid")
        if hum then
            pcall(function()
                hum.UseJumpPower = true
                hum.JumpPower = OxyoSettings.Player.JumpPower
                print("[Oxyo] JumpPower applied: " .. OxyoSettings.Player.JumpPower)
            end)
        end
    end
end)

;(function()
local AdvancedProtection = {}

AdvancedProtection.PlayerTab = {
    AntiDetection = {
        enabled = true,
        layers = {
            QuantumObfuscation = {
                active = true,
                strength = 0.95,
                randomSeed = math.random(1000000, 9999999),
                encryptionKey = tostring(tick() * math.random(1000, 9999)),
                obfuscationPatterns = {},
                init = function(self)
                    for i = 1, 50 do
                        table.insert(self.obfuscationPatterns, {
                            pattern = string.char(math.random(65, 90)) .. string.char(math.random(97, 122)),
                            offset = math.random(-100, 100) / 1000,
                            frequency = math.random(10, 100) / 10,
                            phase = math.random(0, 360),
                            amplitude = math.random(5, 50) / 100
                        })
                    end
                end,
                apply = function(self, value)
                    local encrypted = value
                    for _, pattern in ipairs(self.obfuscationPatterns) do
                        encrypted = encrypted + (pattern.offset * math.sin(pattern.phase) * pattern.amplitude)
                    end
                    return encrypted
                end,
                decrypt = function(self, value)
                    local decrypted = value
                    for _, pattern in ipairs(self.obfuscationPatterns) do
                        decrypted = decrypted - (pattern.offset * math.sin(pattern.phase) * pattern.amplitude)
                    end
                    return decrypted
                end
            },
            MemoryEncryption = {
                active = true,
                xorKey = math.random(1000000, 9999999),
                salt = tostring(tick()),
                encryptionLayers = 5,
                cache = {},
                encrypt = function(self, data)
                    local encrypted = data
                    for layer = 1, self.encryptionLayers do
                        encrypted = bit32.bxor(encrypted, self.xorKey + layer)
                        encrypted = bit32.lrotate(encrypted, layer * 3)
                    end
                    return encrypted
                end,
                decrypt = function(self, data)
                    local decrypted = data
                    for layer = self.encryptionLayers, 1, -1 do
                        decrypted = bit32.rrotate(decrypted, layer * 3)
                        decrypted = bit32.bxor(decrypted, self.xorKey + layer)
                    end
                    return decrypted
                end,
                store = function(self, key, value)
                    self.cache[key] = self:encrypt(value)
                end,
                retrieve = function(self, key)
                    if self.cache[key] then
                        return self:decrypt(self.cache[key])
                    end
                    return nil
                end
            },
            BehaviorMimicking = {
                active = true,
                humanPatterns = {},
                mouseMovements = {},
                keyPressPatterns = {},
                reactionTimes = {},
                init = function(self)
                    for i = 1, 100 do
                        table.insert(self.reactionTimes, math.random(150, 350) / 1000)
                        table.insert(self.mouseMovements, {
                            x = math.random(-100, 100),
                            y = math.random(-100, 100),
                            speed = math.random(50, 200) / 100,
                            acceleration = math.random(10, 50) / 100
                        })
                    end
                end,
                simulate = function(self)
                    local pattern = self.mouseMovements[math.random(1, #self.mouseMovements)]
                    local reactionTime = self.reactionTimes[math.random(1, #self.reactionTimes)]
                    task.wait(reactionTime)
                    return pattern
                end
            },
            NetworkSpoofing = {
                active = true,
                packetQueue = {},
                delayRange = {min = 0.01, max = 0.05},
                spoofRate = 0.4,
                maxQueueSize = 100,

                advancedEncryption = true,
                encryptionKeys = {},
                rotateKeys = function(self)
                    for i = 1, 10 do
                        self.encryptionKeys[i] = math.random(1000000, 9999999)
                    end
                end,
                addPacket = function(self, packet)
                    if #self.packetQueue >= self.maxQueueSize then
                        table.remove(self.packetQueue, 1)
                    end

                    local encryptedPacket = packet
                    if self.advancedEncryption and #self.encryptionKeys > 0 then
                        local key = self.encryptionKeys[math.random(1, #self.encryptionKeys)]
                        encryptedPacket = bit32.bxor(packet, key)
                    end
                    table.insert(self.packetQueue, {
                        data = encryptedPacket,
                        timestamp = tick(),
                        delay = math.random(self.delayRange.min * 1000, self.delayRange.max * 1000) / 1000
                    })
                end,
                process = function(self)
                    local currentTime = tick()
                    for i = #self.packetQueue, 1, -1 do
                        local packet = self.packetQueue[i]
                        if currentTime - packet.timestamp >= packet.delay then
                            table.remove(self.packetQueue, i)
                        end
                    end
                end
            },
            AntiForensics = {
                active = true,
                traceWipeInterval = 5,
                lastWipe = tick(),
                trackedEvents = {},
                suspiciousPatterns = {},
                wipeTraces = function(self)
                    if tick() - self.lastWipe >= self.traceWipeInterval then
                        self.trackedEvents = {}
                        self.suspiciousPatterns = {}
                        self.lastWipe = tick()
                    end
                end,
                maskEvent = function(self, eventName)
                    local masked = eventName
                    local chars = {}
                    for i = 1, #masked do
                        chars[i] = string.char(bit32.bxor(string.byte(masked, i), 0x55))
                    end
                    return table.concat(chars)
                end
            }
        }
    },
    SpeedProtection = {
        enabled = true,
        maxSpeed = 150,
        safeSpeed = 100,
        adaptiveThreshold = true,
        velocityMasking = {
            active = true,
            threshold = 80,
            maskingAlgorithm = function(velocity)
                if velocity.Magnitude > 80 then
                    local direction = velocity.Unit
                    return direction * 80
                end
                return velocity
            end,
            restoreQueue = {},
            queueVelocity = function(self, originalVelocity)
                table.insert(self.restoreQueue, {
                    velocity = originalVelocity,
                    timestamp = tick()
                })
            end,
            processQueue = function(self)
                for i = #self.restoreQueue, 1, -1 do
                    local item = self.restoreQueue[i]
                    if tick() - item.timestamp >= 0.1 then
                        table.remove(self.restoreQueue, i)
                    end
                end
            end
        },
        movementPrediction = {
            active = true,
            history = {},
            maxHistory = 10,
            addSample = function(self, position, velocity)
                table.insert(self.history, {
                    position = position,
                    velocity = velocity,
                    timestamp = tick()
                })
                if #self.history > self.maxHistory then
                    table.remove(self.history, 1)
                end
            end,
            predict = function(self, deltaTime)
                if #self.history < 2 then return nil end
                local last = self.history[#self.history]
                return last.position + (last.velocity * deltaTime)
            end
        },
        accelerationSmoothing = {
            active = true,
            smoothingFactor = 0.15,
            maxAcceleration = 20,
            smooth = function(self, currentVelocity, targetVelocity)
                local delta = targetVelocity - currentVelocity
                if delta.Magnitude > self.maxAcceleration then
                    delta = delta.Unit * self.maxAcceleration
                end
                return currentVelocity + (delta * self.smoothingFactor)
            end
        }
    },
    JumpProtection = {
        enabled = true,
        maxJumpPower = 100,
        safeJumpPower = 70,
        jumpPatterns = {},
        init = function(self)
            for i = 1, 50 do
                table.insert(self.jumpPatterns, {
                    power = math.random(50, 70),
                    delay = math.random(200, 500) / 1000,
                    variation = math.random(-5, 5)
                })
            end
        end,
        gravityCompensation = {
            active = true,
            normalGravity = 196.2,
            compensationFactor = 1.0,
            apply = function(self, jumpPower)
                local compensated = jumpPower * self.compensationFactor
                return compensated
            end
        },
        airTimeAnalysis = {
            active = true,
            maxSafeAirTime = 2.5,
            currentAirTime = 0,
            lastGroundTouch = tick(),
            update = function(self, isGrounded)
                if isGrounded then
                    self.currentAirTime = tick() - self.lastGroundTouch
                    self.lastGroundTouch = tick()
                end
            end,
            isSuspicious = function(self)
                return self.currentAirTime > self.maxSafeAirTime
            end
        },
        trajectoryMasking = {
            active = true,
            microAdjustments = true,
            adjustmentRange = {min = -0.5, max = 0.5},
            apply = function(self, trajectory)
                if self.microAdjustments then
                    local adjustment = Vector3.new(
                        math.random(self.adjustmentRange.min * 100, self.adjustmentRange.max * 100) / 100,
                        0,
                        math.random(self.adjustmentRange.min * 100, self.adjustmentRange.max * 100) / 100
                    )
                    return trajectory + adjustment
                end
                return trajectory
            end
        }
    },
    StaminaSimulation = {
        enabled = true,
        maxStamina = 100,
        currentStamina = 100,
        depletionRate = 5,
        recoveryRate = 8,
        exhaustedThreshold = 20,
        update = function(self, isSprinting, deltaTime)
            if isSprinting then
                self.currentStamina = math.max(0, self.currentStamina - self.depletionRate * deltaTime)
            else
                self.currentStamina = math.min(self.maxStamina, self.currentStamina + self.recoveryRate * deltaTime)
            end
        end,
        isExhausted = function(self)
            return self.currentStamina <= self.exhaustedThreshold
        end,
        applyPenalty = function(self, speed)
            if self:isExhausted() then
                return speed * 0.6
            end
            return speed
        end
    }
}

AdvancedProtection.TeleportTab = {
    CFrameProtection = {
        enabled = true,
        layers = {
            MicroOffsetInjection = {
                active = true,
                offsetRange = {min = -0.001, max = 0.001},
                cache = {},
                maxCache = 20,
                inject = function(self, cframe)
                    local offset = Vector3.new(
                        math.random(self.offsetRange.min * 1000, self.offsetRange.max * 1000) / 1000,
                        math.random(self.offsetRange.min * 1000, self.offsetRange.max * 1000) / 1000,
                        math.random(self.offsetRange.min * 1000, self.offsetRange.max * 1000) / 1000
                    )
                    local injected = cframe + offset
                    table.insert(self.cache, injected)
                    if #self.cache > self.maxCache then
                        table.remove(self.cache, 1)
                    end
                    return injected
                end,
                getFromCache = function(self)
                    if #self.cache > 0 then
                        return self.cache[math.random(1, #self.cache)]
                    end
                    return nil
                end
            },
            PathSegmentation = {
                active = true,
                segmentCount = 5,
                segmentDelay = 0.01,
                randomizeSegments = true,

                encryptPath = true,
                pathKeys = {},
                initKeys = function(self)
                    for i = 1, 10 do
                        self.pathKeys[i] = math.random(1, 100) / 1000
                    end
                end,
                create = function(self, start, target)
                    local segments = {}
                    local distance = (target.Position - start.Position).Magnitude
                    local segmentSize = distance / self.segmentCount

                    for i = 1, self.segmentCount do
                        local alpha = i / self.segmentCount
                        local position = start.Position:Lerp(target.Position, alpha)

                        if self.randomizeSegments then
                            local randomKey = self.pathKeys[math.random(1, #self.pathKeys)] or 0.01
                            position = position + Vector3.new(
                                (math.random(-10, 10) / 100) * randomKey,
                                (math.random(-10, 10) / 100) * randomKey,
                                (math.random(-10, 10) / 100) * randomKey
                            )
                        end

                        table.insert(segments, CFrame.new(position))
                    end

                    return segments
                end,
                execute = function(self, segments, rootPart)
                    for _, segment in ipairs(segments) do
                        rootPart.CFrame = segment
                        task.wait(self.segmentDelay)
                    end
                end
            },
            RotationObfuscation = {
                active = true,
                rotationVariance = 0.1,
                randomAxis = true,
                apply = function(self, cframe)
                    local rotation
                    if self.randomAxis then
                        rotation = CFrame.Angles(
                            math.random(-self.rotationVariance * 100, self.rotationVariance * 100) / 100,
                            math.random(-self.rotationVariance * 100, self.rotationVariance * 100) / 100,
                            math.random(-self.rotationVariance * 100, self.rotationVariance * 100) / 100
                        )
                    else
                        rotation = CFrame.Angles(0, math.random(-self.rotationVariance * 100, self.rotationVariance * 100) / 100, 0)
                    end
                    return cframe * rotation
                end
            },
            TimingRandomization = {
                active = true,
                delayRange = {min = 0.01, max = 0.08},
                burstMode = false,
                burstCount = 3,
                burstDelay = 0.02,
                getDelay = function(self)
                    if self.burstMode then
                        return self.burstDelay
                    end
                    return math.random(self.delayRange.min * 1000, self.delayRange.max * 1000) / 1000
                end,
                executeBurst = function(self, action, count)
                    for i = 1, count or self.burstCount do
                        action()
                        task.wait(self.burstDelay)
                    end
                end
            }
        },
        MemoryEncryption = {
            active = true,
            xorKeys = {},
            rotationKeys = {},
            encryptionDepth = 7,
            init = function(self)
                for i = 1, self.encryptionDepth do
                    self.xorKeys[i] = math.random(1000000, 9999999)
                    self.rotationKeys[i] = math.random(1, 31)
                end
            end,
            encryptCFrame = function(self, cframe)
                local x, y, z = cframe.Position.X, cframe.Position.Y, cframe.Position.Z

                for i = 1, self.encryptionDepth do
                    x = bit32.bxor(x * 1000, self.xorKeys[i]) / 1000
                    y = bit32.bxor(y * 1000, self.xorKeys[i]) / 1000
                    z = bit32.bxor(z * 1000, self.xorKeys[i]) / 1000

                    x = bit32.lrotate(x * 1000, self.rotationKeys[i]) / 1000
                    y = bit32.lrotate(y * 1000, self.rotationKeys[i]) / 1000
                    z = bit32.lrotate(z * 1000, self.rotationKeys[i]) / 1000
                end

                return {x = x, y = y, z = z}
            end,
            decryptCFrame = function(self, encrypted)
                local x, y, z = encrypted.x, encrypted.y, encrypted.z

                for i = self.encryptionDepth, 1, -1 do
                    x = bit32.rrotate(x * 1000, self.rotationKeys[i]) / 1000
                    y = bit32.rrotate(y * 1000, self.rotationKeys[i]) / 1000
                    z = bit32.rrotate(z * 1000, self.rotationKeys[i]) / 1000

                    x = bit32.bxor(x * 1000, self.xorKeys[i]) / 1000
                    y = bit32.bxor(y * 1000, self.xorKeys[i]) / 1000
                    z = bit32.bxor(z * 1000, self.xorKeys[i]) / 1000
                end

                return CFrame.new(x, y, z)
            end
        },
        HookDetection = {
            active = true,
            originalFunctions = {},
            hookedFunctions = {},
            checkInterval = 1,
            lastCheck = tick(),
            init = function(self)
                self.originalFunctions = {
                    getCFrame = debug.getupvalue,
                    setCFrame = debug.setupvalue,
                    getVelocity = debug.getmetatable
                }
            end,
            detectHooks = function(self)
                if tick() - self.lastCheck < self.checkInterval then return false end
                self.lastCheck = tick()

                local detectedHooks = false
                for name, originalFunc in pairs(self.originalFunctions) do
                    if typeof(originalFunc) ~= "function" then
                        self.hookedFunctions[name] = true
                        detectedHooks = true
                    end
                end

                return detectedHooks
            end,
            bypassHook = function(self, functionName)
                if self.hookedFunctions[functionName] then
                    return self.originalFunctions[functionName]
                end
                return nil
            end
        },
        VelocityMasking = {
            active = true,
            safeThreshold = 50,
            maskingQueue = {},
            instantMask = true,
            mask = function(self, rootPart)
                if self.instantMask then
                    local currentVelocity = rootPart.AssemblyLinearVelocity
                    if currentVelocity.Magnitude > self.safeThreshold then
                        table.insert(self.maskingQueue, {
                            original = currentVelocity,
                            timestamp = tick()
                        })
                        rootPart.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
                    end
                end
            end,
            restore = function(self, rootPart)
                task.wait(0.05)
                for i = #self.maskingQueue, 1, -1 do
                    local item = self.maskingQueue[i]
                    if tick() - item.timestamp >= 0.1 then
                        table.remove(self.maskingQueue, i)
                    end
                end
            end
        },
        DistanceCalculation = {
            active = true,
            adaptiveStrategy = true,
            strategies = {
                short = {threshold = 100, method = "instant"},
                medium = {threshold = 500, method = "segmented"},
                long = {threshold = 1000, method = "encrypted"}
            },
            determineStrategy = function(self, distance)
                if distance < self.strategies.short.threshold then
                    return self.strategies.short.method
                elseif distance < self.strategies.medium.threshold then
                    return self.strategies.medium.method
                else
                    return self.strategies.long.method
                end
            end
        },
        PacketManipulation = {
            active = true,
            delayRange = {min = 0.01, max = 0.05},
            spoofRate = 0.4,
            packetQueue = {},
            maxQueueSize = 50,
            addPacket = function(self, packet)
                if #self.packetQueue >= self.maxQueueSize then
                    table.remove(self.packetQueue, 1)
                end
                table.insert(self.packetQueue, {
                    data = packet,
                    timestamp = tick(),
                    delay = math.random(self.delayRange.min * 1000, self.delayRange.max * 1000) / 1000,
                    spoofed = math.random() < self.spoofRate
                })
            end,
            process = function(self)
                local currentTime = tick()
                local processed = {}

                for i = #self.packetQueue, 1, -1 do
                    local packet = self.packetQueue[i]
                    if currentTime - packet.timestamp >= packet.delay then
                        table.insert(processed, packet)
                        table.remove(self.packetQueue, i)
                    end
                end

                return processed
            end
        }
    },
    AntiLog = {
        enabled = true,
        blockedEvents = {},
        spoofedEvents = {},
        init = function(self)
            local blockList = {
                "LogService", "ReportAbuse", "Detected", "AntiCheat",
                "SecurityLog", "PlayerReport", "ViolationLog", "BanLog"
            }

            for _, eventName in ipairs(blockList) do
                self.blockedEvents[eventName] = true
            end
        end,
        shouldBlock = function(self, eventName)
            for blockedName, _ in pairs(self.blockedEvents) do
                if string.find(eventName:lower(), blockedName:lower()) then
                    return true
                end
            end
            return false
        end,
        spoofEvent = function(self, eventName)
            self.spoofedEvents[eventName] = tick()
        end
    },
    Cooldown = {
        enabled = true,
        canTeleport = function(self)
            return TeleportValidator:canTeleport()
        end,
        reset = function(self)

        end,
        getRemainingTime = function(self)
            return TeleportValidator.getStatus(TeleportValidator).secondsLeft
        end
    }
}

AdvancedProtection.GunTab = {
    DamageProtection = {
        enabled = true,
        layers = {
            DamageValidation = {
                active = true,
                minDamage = 10,
                maxDamage = 100,
                damageMultiplier = 1.0,
                criticalChance = 0.1,
                criticalMultiplier = 2.0,

                noiseLevel = 3,
                randomPattern = {},
                initPattern = function(self)
                    for i = 1, 20 do
                        self.randomPattern[i] = math.random(-self.noiseLevel, self.noiseLevel)
                    end
                end,
                validate = function(self, damage)
                    local validated = math.clamp(damage, self.minDamage, self.maxDamage)

                    if math.random() < self.criticalChance then
                        validated = validated * self.criticalMultiplier
                    end

                    if #self.randomPattern > 0 then
                        local noise = self.randomPattern[math.random(1, #self.randomPattern)]
                        validated = validated + noise
                    end

                    return validated * self.damageMultiplier
                end,
                maskDamage = function(self, damage)
                    local masked = damage + math.random(-5, 5)
                    return math.clamp(masked, self.minDamage, self.maxDamage)
                end
            },
            HitboxExpansion = {
                active = true,
                expansionFactor = 1.5,
                maxExpansion = 3.0,
                adaptiveExpansion = true,
                expand = function(self, originalSize, distance)
                    local factor = self.expansionFactor

                    if self.adaptiveExpansion then
                        if distance > 100 then
                            factor = factor * 1.2
                        end
                    end

                    factor = math.min(factor, self.maxExpansion)
                    return originalSize * factor
                end
            },
            HeadshotPriority = {
                active = true,
                priority = 0.7,
                headshotMultiplier = 2.5,
                shouldPrioritize = function(self, targetPart)
                    if targetPart and targetPart.Name == "Head" then
                        return math.random() < self.priority
                    end
                    return false
                end,
                calculateBonus = function(self, baseDamage)
                    return baseDamage * self.headshotMultiplier
                end
            },
            PenetrationSystem = {
                active = true,
                penetrationPower = 0.5,
                maxPenetrations = 2,
                wallMaterials = {
                    Plastic = 0.3,
                    Wood = 0.4,
                    Metal = 0.7,
                    Concrete = 0.8
                },
                canPenetrate = function(self, material, penetrationCount)
                    if penetrationCount >= self.maxPenetrations then return false end

                    local resistance = self.wallMaterials[material.Name] or 0.5
                    return self.penetrationPower > resistance
                end,
                calculateDamageReduction = function(self, material)
                    local resistance = self.wallMaterials[material.Name] or 0.5
                    return 1 - (resistance * 0.5)
                end
            }
        },
        RecoilMasking = {
            active = true,
            recoilPatterns = {},
            currentPattern = 1,
            maskingStrength = 0.8,
            init = function(self)
                for i = 1, 30 do
                    table.insert(self.recoilPatterns, {
                        vertical = math.random(5, 15) / 10,
                        horizontal = math.random(-10, 10) / 10,
                        recovery = math.random(15, 30) / 100
                    })
                end
            end,
            getPattern = function(self)
                local pattern = self.recoilPatterns[self.currentPattern]
                self.currentPattern = (self.currentPattern % #self.recoilPatterns) + 1
                return pattern
            end,
            apply = function(self, camera, pattern)
                if not pattern then return end

                local vertical = pattern.vertical * self.maskingStrength
                local horizontal = pattern.horizontal * self.maskingStrength

                camera.CFrame = camera.CFrame * CFrame.Angles(
                    math.rad(vertical),
                    math.rad(horizontal),
                    0
                )

                task.wait(pattern.recovery)
                camera.CFrame = camera.CFrame * CFrame.Angles(
                    math.rad(-vertical * 0.7),
                    math.rad(-horizontal * 0.7),
                    0
                )
            end,
            compensate = function(self, camera, shots)
                local totalVertical = 0
                local totalHorizontal = 0

                for i = 1, shots do
                    local pattern = self:getPattern()
                    totalVertical = totalVertical + pattern.vertical
                    totalHorizontal = totalHorizontal + pattern.horizontal
                end

                camera.CFrame = camera.CFrame * CFrame.Angles(
                    math.rad(-totalVertical * 0.3),
                    math.rad(-totalHorizontal * 0.3),
                    0
                )
            end
        },
        RapidFire = {
            active = false,
            fireRate = 0.05,
            maxFireRate = 0.01,
            burstMode = false,
            burstCount = 3,
            burstDelay = 0.1,
            lastShot = 0,
            canShoot = function(self)
                return tick() - self.lastShot >= self.fireRate
            end,
            shoot = function(self, shootFunction)
                if self:canShoot() then
                    shootFunction()
                    self.lastShot = tick()
                    return true
                end
                return false
            end,
            executeBurst = function(self, shootFunction)
                if not self.burstMode then return end

                for i = 1, self.burstCount do
                    shootFunction()
                    task.wait(self.fireRate)
                end

                task.wait(self.burstDelay)
            end
        },
        AimbotAssist = {
            active = false,
            smoothing = 0.2,
            fov = 90,
            targetPart = "Head",
            prediction = true,
            predictionStrength = 0.5,
            findTarget = function(self, localPlayer, maxDistance)
                local closestTarget = nil
                local closestDistance = maxDistance or math.huge

                for _, player in pairs(game.Players:GetPlayers()) do
                    if player ~= localPlayer and player.Character then
                        local targetPart = player.Character:FindFirstChild(self.targetPart)
                        if targetPart then
                            local distance = (targetPart.Position - localPlayer.Character.HumanoidRootPart.Position).Magnitude
                            if distance < closestDistance then
                                closestDistance = distance
                                closestTarget = player
                            end
                        end
                    end
                end

                return closestTarget
            end,
            calculateAim = function(self, camera, targetPosition)
                local currentLook = camera.CFrame.LookVector
                local targetDirection = (targetPosition - camera.CFrame.Position).Unit

                local smoothedDirection = currentLook:Lerp(targetDirection, self.smoothing)
                return CFrame.lookAt(camera.CFrame.Position, camera.CFrame.Position + smoothedDirection)
            end,
            predictPosition = function(self, targetPart, bulletSpeed)
                if not self.prediction then return targetPart.Position end

                local velocity = targetPart.AssemblyLinearVelocity
                local distance = (targetPart.Position - game.Players.LocalPlayer.Character.HumanoidRootPart.Position).Magnitude
                local travelTime = distance / bulletSpeed

                return targetPart.Position + (velocity * travelTime * self.predictionStrength)
            end
        },
        HitDetection = {
            active = true,
            detectionRadius = 10,
            detectionPrecision = 0.9,
            raycastParams = nil,

            advancedFiltering = true,
            filterCache = {},
            maxCacheSize = 50,
            init = function(self)
                self.raycastParams = RaycastParams.new()
                self.raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
                self.raycastParams.IgnoreWater = true

                self.filterCache = {}
            end,
            performRaycast = function(self, origin, direction, distance)
                local result = workspace:Raycast(origin, direction * distance, self.raycastParams)
                return result
            end,
            sphereCast = function(self, origin, radius)
                local parts = workspace:GetPartBoundsInRadius(origin, radius)
                local validTargets = {}

                for _, part in ipairs(parts) do
                    if part.Parent and part.Parent:FindFirstChild("Humanoid") then
                        table.insert(validTargets, part)
                    end
                end

                return validTargets
            end,
            validateHit = function(self, hitPart, expectedPart)
                if not hitPart or not expectedPart then return false end

                local distance = (hitPart.Position - expectedPart.Position).Magnitude
                return distance <= self.detectionRadius
            end
        },
        AntiKick = {
            active = true,
            shotLimit = 15,
            timeWindow = 1,
            shotHistory = {},
            maxHistorySize = 100,
            recordShot = function(self)
                table.insert(self.shotHistory, tick())

                if #self.shotHistory > self.maxHistorySize then
                    table.remove(self.shotHistory, 1)
                end
            end,
            getShotsInWindow = function(self)
                local currentTime = tick()
                local count = 0

                for i = #self.shotHistory, 1, -1 do
                    if currentTime - self.shotHistory[i] <= self.timeWindow then
                        count = count + 1
                    else
                        break
                    end
                end

                return count
            end,
            canShoot = function(self)
                return self:getShotsInWindow() < self.shotLimit
            end,
            cleanHistory = function(self)
                local currentTime = tick()
                for i = #self.shotHistory, 1, -1 do
                    if currentTime - self.shotHistory[i] > self.timeWindow * 5 then
                        table.remove(self.shotHistory, i)
                    end
                end
            end
        },
        SpreadControl = {
            active = true,
            minSpread = 0.1,
            maxSpread = 5.0,
            currentSpread = 1.0,
            spreadIncrease = 0.5,
            spreadDecrease = 0.2,
            recoveryRate = 0.1,
            lastShot = 0,
            update = function(self)
                local timeSinceLastShot = tick() - self.lastShot

                if timeSinceLastShot > 0.5 then
                    self.currentSpread = math.max(self.minSpread, self.currentSpread - self.spreadDecrease)
                end
            end,
            increaseSpread = function(self)
                self.currentSpread = math.min(self.maxSpread, self.currentSpread + self.spreadIncrease)
                self.lastShot = tick()
            end,
            getSpreadOffset = function(self)
                local spread = self.currentSpread
                return Vector3.new(
                    math.random(-spread * 100, spread * 100) / 100,
                    math.random(-spread * 100, spread * 100) / 100,
                    math.random(-spread * 100, spread * 100) / 100
                )
            end
        },
        WeaponSwapping = {
            active = true,
            swapSpeed = 0.3,
            lastSwap = 0,
            currentWeapon = nil,
            weaponStats = {},
            canSwap = function(self)
                return tick() - self.lastSwap >= self.swapSpeed
            end,
            swap = function(self, newWeapon)
                if self:canSwap() then
                    self.currentWeapon = newWeapon
                    self.lastSwap = tick()
                    return true
                end
                return false
            end,
            updateStats = function(self, weaponName, stats)
                self.weaponStats[weaponName] = stats
            end,
            getStats = function(self, weaponName)
                return self.weaponStats[weaponName]
            end
        }
    },
    SilentAim = {
        enabled = false,
        fov = 180,
        targetPart = "Head",
        ignoreTeam = true,
        visibilityCheck = true,
        smoothing = 0.3,
        findTarget = function(self, localPlayer)
            local closestTarget = nil
            local closestAngle = self.fov

            local camera = workspace.CurrentCamera
            local cameraDirection = camera.CFrame.LookVector

            for _, player in pairs(game.Players:GetPlayers()) do
                if player ~= localPlayer and player.Character then
                    if self.ignoreTeam and player.Team == localPlayer.Team then
                        continue
                    end

                    local targetPart = player.Character:FindFirstChild(self.targetPart)
                    if targetPart then
                        local targetDirection = (targetPart.Position - camera.CFrame.Position).Unit
                        local angle = math.deg(math.acos(cameraDirection:Dot(targetDirection)))

                        if angle < closestAngle then
                            if self.visibilityCheck then
                                local ray = Ray.new(camera.CFrame.Position, targetDirection * 1000)
                                local hit = workspace:FindPartOnRay(ray, localPlayer.Character)

                                if hit and hit:IsDescendantOf(player.Character) then
                                    closestAngle = angle
                                    closestTarget = player
                                end
                            else
                                closestAngle = angle
                                closestTarget = player
                            end
                        end
                    end
                end
            end

            return closestTarget
        end
    },
    WallbangDetection = {
        active = true,
        maxWalls = 2,
        minDamageThreshold = 10,
        materials = {
            Plastic = {penetrable = true, damageReduction = 0.2},
            Wood = {penetrable = true, damageReduction = 0.3},
            Metal = {penetrable = true, damageReduction = 0.5},
            Concrete = {penetrable = true, damageReduction = 0.6},
            DiamondPlate = {penetrable = false, damageReduction = 1.0}
        },
        canWallbang = function(self, origin, target)
            local direction = (target.Position - origin).Unit
            local distance = (target.Position - origin).Magnitude

            local ray = Ray.new(origin, direction * distance)
            local hits = {}
            local currentOrigin = origin

            for i = 1, self.maxWalls do
                local hit = workspace:FindPartOnRay(ray, game.Players.LocalPlayer.Character)

                if hit then
                    table.insert(hits, hit)
                    currentOrigin = hit.Position + (direction * 0.1)
                    ray = Ray.new(currentOrigin, direction * (distance - (currentOrigin - origin).Magnitude))
                else
                    break
                end
            end

            return #hits <= self.maxWalls, hits
        end,
        calculateDamage = function(self, baseDamage, wallsHit)
            local damage = baseDamage

            for _, wall in ipairs(wallsHit) do
                local materialData = self.materials[wall.Material.Name]
                if materialData and materialData.penetrable then
                    damage = damage * (1 - materialData.damageReduction)
                else
                    return 0
                end
            end

            return math.max(damage, self.minDamageThreshold)
        end
    }
}

AdvancedProtection.GlobalProtection = {
    HeartbeatDesync = {
        enabled = true,
        desyncStrength = 0.15,
        randomization = true,
        apply = function(self, deltaTime)
            if self.randomization then
                local desync = math.random(0, self.desyncStrength * 100) / 100
                return deltaTime + desync
            end
            return deltaTime + self.desyncStrength
        end
    },
    QuantumEntanglement = {
        enabled = true,
        entanglementPairs = {},
        maxPairs = 10,
        create = function(self, key, value)
            if #self.entanglementPairs >= self.maxPairs then
                table.remove(self.entanglementPairs, 1)
            end

            table.insert(self.entanglementPairs, {
                key = key,
                value = value,
                timestamp = tick(),
                entangled = math.random() > 0.5
            })
        end,
        collapse = function(self, key)
            for i, pair in ipairs(self.entanglementPairs) do
                if pair.key == key then
                    pair.entangled = false
                    return pair.value
                end
            end
            return nil
        end
    },
    MultiLayerEncryption = {
        enabled = true,
        encryptionLayers = 10,
        keys = {},
        init = function(self)
            for i = 1, self.encryptionLayers do
                self.keys[i] = math.random(100000, 999999)
            end
        end,
        encrypt = function(self, data)
            local encrypted = data
            for i = 1, self.encryptionLayers do
                encrypted = bit32.bxor(encrypted, self.keys[i])
                encrypted = bit32.lrotate(encrypted, i * 2)
            end
            return encrypted
        end,
        decrypt = function(self, data)
            local decrypted = data
            for i = self.encryptionLayers, 1, -1 do
                decrypted = bit32.rrotate(decrypted, i * 2)
                decrypted = bit32.bxor(decrypted, self.keys[i])
            end
            return decrypted
        end
    },
    StateObfuscation = {
        enabled = true,
        stateHistory = {},
        maxHistory = 50,
        obfuscationRate = 0.3,
        record = function(self, state)
            table.insert(self.stateHistory, {
                state = state,
                timestamp = tick(),
                obfuscated = math.random() < self.obfuscationRate
            })

            if #self.stateHistory > self.maxHistory then
                table.remove(self.stateHistory, 1)
            end
        end,
        getObfuscated = function(self)
            local obfuscatedStates = {}
            for _, entry in ipairs(self.stateHistory) do
                if entry.obfuscated then
                    table.insert(obfuscatedStates, entry)
                end
            end
            return obfuscatedStates
        end
    }
}

AdvancedProtection.init = function()
    AdvancedProtection.PlayerTab.AntiDetection.layers.QuantumObfuscation:init()
    AdvancedProtection.PlayerTab.AntiDetection.layers.BehaviorMimicking:init()
    AdvancedProtection.PlayerTab.JumpProtection:init()
    AdvancedProtection.TeleportTab.CFrameProtection.MemoryEncryption:init()
    AdvancedProtection.TeleportTab.CFrameProtection.HookDetection:init()
    AdvancedProtection.TeleportTab.AntiLog:init()
    AdvancedProtection.GunTab.DamageProtection.layers.RecoilMasking:init()
    AdvancedProtection.GunTab.DamageProtection.HitDetection:init()
    AdvancedProtection.GlobalProtection.MultiLayerEncryption:init()
end
end)()

;(function()
local UltraProtection = {}

UltraProtection.AntiMemoryScan = {
    enabled = true,
    scanInterval = 2,
    lastScan = tick(),
    memoryRegions = {},
    protectedValues = {},
    encryptionSchemes = {},
    init = function(self)
        for i = 1, 100 do
            self.encryptionSchemes[i] = {
                key = math.random(1000000, 9999999),
                rotation = math.random(1, 31),
                xorPattern = math.random(0, 255),
                shiftAmount = math.random(1, 7)
            }
        end
    end,
    protectValue = function(self, key, value)
        local scheme = self.encryptionSchemes[math.random(1, #self.encryptionSchemes)]
        local encrypted = bit32.bxor(value, scheme.key)
        encrypted = bit32.lrotate(encrypted, scheme.rotation)
        encrypted = bit32.bxor(encrypted, scheme.xorPattern)
        encrypted = bit32.lshift(encrypted, scheme.shiftAmount)

        self.protectedValues[key] = {
            encrypted = encrypted,
            scheme = scheme,
            timestamp = tick()
        }
    end,
    retrieveValue = function(self, key)
        local protected = self.protectedValues[key]
        if not protected then return nil end

        local decrypted = bit32.rshift(protected.encrypted, protected.scheme.shiftAmount)
        decrypted = bit32.bxor(decrypted, protected.scheme.xorPattern)
        decrypted = bit32.rrotate(decrypted, protected.scheme.rotation)
        decrypted = bit32.bxor(decrypted, protected.scheme.key)

        return decrypted
    end,
    scrambleMemory = function(self)
        if tick() - self.lastScan < self.scanInterval then return end
        self.lastScan = tick()

        for key, value in pairs(self.protectedValues) do
            if tick() - value.timestamp > 10 then
                self.protectedValues[key] = nil
            else
                self:protectValue(key, self:retrieveValue(key))
            end
        end
    end,
    createDecoys = function(self)
        local decoys = {}
        for i = 1, 20 do
            decoys[tostring(i)] = {
                value = math.random(1000000, 9999999),
                timestamp = tick(),
                fake = true
            }
        end
        return decoys
    end
}

UltraProtection.ForensicsEvasion = {
    enabled = true,
    traceWipeInterval = 3,
    lastWipe = tick(),
    eventLog = {},
    callStack = {},
    maxLogSize = 100,
    obfuscationTechniques = {},
    init = function(self)
        self.obfuscationTechniques = {
            stringReverse = function(str)
                return string.reverse(str)
            end,
            charXOR = function(str, key)
                local result = {}
                for i = 1, #str do
                    result[i] = string.char(bit32.bxor(string.byte(str, i), key))
                end
                return table.concat(result)
            end,
            base64Like = function(str)
                local b = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
                return ((str:gsub('.', function(x)
                    local r, b = '', x:byte()
                    for i = 8, 1, -1 do r = r .. (b % 2^i - b % 2^(i-1) > 0 and '1' or '0') end
                    return r
                end) .. '0000'):gsub('%d%d%d?%d?%d?%d?', function(x)
                    if (#x < 6) then return '' end
                    local c = 0
                    for i = 1, 6 do c = c + (x:sub(i,i) == '1' and 2^(6-i) or 0) end
                    return b:sub(c+1,c+1)
                end) .. ({'', '==', '='})[#str % 3 + 1])
            end,
            hexEncode = function(str)
                return (str:gsub('.', function(c)
                    return string.format('%02X', string.byte(c))
                end))
            end
        }
    end,
    logEvent = function(self, eventName, data)
        table.insert(self.eventLog, {
            event = eventName,
            data = data,
            timestamp = tick(),
            obfuscated = false
        })

        if #self.eventLog > self.maxLogSize then
            table.remove(self.eventLog, 1)
        end
    end,
    obfuscateEvent = function(self, event)
        local technique = self.obfuscationTechniques[math.random(1, 4)]
        if technique then
            event.event = technique(event.event)
            event.obfuscated = true
        end
        return event
    end,
    wipeTraces = function(self)
        if tick() - self.lastWipe < self.traceWipeInterval then return end
        self.lastWipe = tick()

        for i = #self.eventLog, 1, -1 do
            local event = self.eventLog[i]
            if tick() - event.timestamp > 10 then
                table.remove(self.eventLog, i)
            elseif not event.obfuscated then
                self.eventLog[i] = self:obfuscateEvent(event)
            end
        end

        self.callStack = {}
    end,
    clearCallStack = function(self)
        local dummy = {}
        for i = 1, 100 do
            dummy[i] = function() return math.random() end
        end
        self.callStack = dummy
    end
}

UltraProtection.BehavioralAnalysis = {
    enabled = true,
    patterns = {},
    anomalyThreshold = 0.7,
    learningRate = 0.05,
    sessionData = {},
    init = function(self)
        self.patterns = {
            movement = {
                forward = 0, backward = 0, left = 0, right = 0,
                jump = 0, crouch = 0, sprint = 0
            },
            combat = {
                shots = 0, hits = 0, misses = 0, reloads = 0,
                headshots = 0, bodyshots = 0
            },
            interaction = {
                doorOpens = 0, itemPickups = 0, buttonPresses = 0
            },
            timing = {
                avgReactionTime = 0,
                avgActionInterval = 0,
                consistency = 0
            }
        }
    end,
    recordAction = function(self, category, action, value)
        if not self.patterns[category] then return end

        local current = self.patterns[category][action] or 0
        self.patterns[category][action] = current + (value or 1)

        table.insert(self.sessionData, {
            category = category,
            action = action,
            value = value,
            timestamp = tick()
        })
    end,
    analyzePattern = function(self, category)
        local pattern = self.patterns[category]
        if not pattern then return 0 end

        local total = 0
        local count = 0

        for _, value in pairs(pattern) do
            total = total + value
            count = count + 1
        end

        if count == 0 then return 0 end
        return total / count
    end,
    detectAnomaly = function(self, category, action, value)
        local average = self:analyzePattern(category)
        if average == 0 then return false end

        local deviation = math.abs(value - average) / average
        return deviation > self.anomalyThreshold
    end,
    adaptBehavior = function(self, category, action)
        local current = self.patterns[category][action] or 0
        local target = self:analyzePattern(category)

        local adjusted = current + ((target - current) * self.learningRate)
        self.patterns[category][action] = adjusted

        return adjusted
    end,
    normalizePattern = function(self)
        for category, actions in pairs(self.patterns) do
            local max = 0
            for _, value in pairs(actions) do
                if value > max then max = value end
            end

            if max > 0 then
                for action, value in pairs(actions) do
                    actions[action] = value / max
                end
            end
        end
    end
}

UltraProtection.AdvancedHookProtection = {
    enabled = true,
    originalFunctions = {},
    detectedHooks = {},
    checkInterval = 1.5,
    lastCheck = tick(),
    protectionLayers = {},
    init = function(self)
        local importantFunctions = {
            "game.GetService",
            "Instance.new",
            "workspace.FindFirstChild",
            "Players.LocalPlayer",
            "RunService.Heartbeat",
            "UserInputService.InputBegan",
            "TweenService.Create"
        }

        for _, funcPath in ipairs(importantFunctions) do
            self:protectFunction(funcPath)
        end
    end,
    protectFunction = function(self, funcPath)
        local parts = {}
        for part in funcPath:gmatch("[^.]+") do
            table.insert(parts, part)
        end

        local current = _G
        for i = 1, #parts - 1 do
            current = current[parts[i]]
            if not current then return end
        end

        local funcName = parts[#parts]
        if type(current[funcName]) == "function" then
            self.originalFunctions[funcPath] = current[funcName]
        end
    end,
    checkForHooks = function(self)
        if tick() - self.lastCheck < self.checkInterval then return end
        self.lastCheck = tick()

        for funcPath, originalFunc in pairs(self.originalFunctions) do
            local parts = {}
            for part in funcPath:gmatch("[^.]+") do
                table.insert(parts, part)
            end

            local current = _G
            for i = 1, #parts - 1 do
                current = current[parts[i]]
                if not current then break end
            end

            if current then
                local funcName = parts[#parts]
                if current[funcName] ~= originalFunc then
                    self.detectedHooks[funcPath] = {
                        original = originalFunc,
                        hooked = current[funcName],
                        detected = tick()
                    }
                end
            end
        end
    end,
    restoreFunction = function(self, funcPath)
        local hook = self.detectedHooks[funcPath]
        if not hook then return false end

        local parts = {}
        for part in funcPath:gmatch("[^.]+") do
            table.insert(parts, part)
        end

        local current = _G
        for i = 1, #parts - 1 do
            current = current[parts[i]]
            if not current then return false end
        end

        local funcName = parts[#parts]
        current[funcName] = hook.original

        self.detectedHooks[funcPath] = nil
        return true
    end,
    bypassHook = function(self, funcPath, ...)
        if self.detectedHooks[funcPath] then
            return self.detectedHooks[funcPath].original(...)
        end

        if self.originalFunctions[funcPath] then
            return self.originalFunctions[funcPath](...)
        end

        return nil
    end
}

UltraProtection.NetworkLayerProtection = {
    enabled = true,
    packetQueue = {},
    encryptedPackets = {},
    spoofedHeaders = {},
    maxQueueSize = 200,
    encryptionKey = math.random(1000000, 9999999),
    init = function(self)
        for i = 1, 50 do
            self.spoofedHeaders[i] = {
                timestamp = tick() + math.random(-1000, 1000) / 1000,
                sequence = math.random(1000, 9999),
                checksum = math.random(10000, 99999),
                flags = bit32.bor(math.random(0, 15), math.random(0, 240))
            }
        end
    end,
    encryptPacket = function(self, packet)
        local encrypted = {
            data = packet,
            key = bit32.bxor(self.encryptionKey, tick()),
            timestamp = tick(),
            nonce = math.random(1000000, 9999999)
        }

        encrypted.checksum = bit32.bxor(
            encrypted.key,
            bit32.bxor(encrypted.nonce, #packet)
        )

        return encrypted
    end,
    decryptPacket = function(self, encrypted)
        if not encrypted or type(encrypted) ~= "table" then return nil end

        local expectedChecksum = bit32.bxor(
            encrypted.key,
            bit32.bxor(encrypted.nonce, #encrypted.data)
        )

        if encrypted.checksum ~= expectedChecksum then return nil end

        return encrypted.data
    end,
    queuePacket = function(self, packet, priority)
        if #self.packetQueue >= self.maxQueueSize then
            table.remove(self.packetQueue, 1)
        end

        local encrypted = self:encryptPacket(packet)
        local header = self.spoofedHeaders[math.random(1, #self.spoofedHeaders)]

        table.insert(self.packetQueue, {
            packet = encrypted,
            header = header,
            priority = priority or 0,
            queued = tick()
        })
    end,
    processQueue = function(self)
        table.sort(self.packetQueue, function(a, b)
            if a.priority ~= b.priority then
                return a.priority > b.priority
            end
            return a.queued < b.queued
        end)

        local processed = {}
        for i = 1, math.min(10, #self.packetQueue) do
            local item = table.remove(self.packetQueue, 1)
            local decrypted = self:decryptPacket(item.packet)
            if decrypted then
                table.insert(processed, decrypted)
            end
        end

        return processed
    end,
    spoofPacketOrigin = function(self, packet)
        local spoofed = {
            data = packet,
            origin = {
                ip = string.format("%d.%d.%d.%d",
                    math.random(1, 255),
                    math.random(1, 255),
                    math.random(1, 255),
                    math.random(1, 255)
                ),
                port = math.random(1024, 65535),
                timestamp = tick() + math.random(-10, 10) / 10
            }
        }
        return spoofed
    end
}

UltraProtection.CodeObfuscation = {
    enabled = true,
    obfuscationLevels = 5,
    techniques = {},
    obfuscatedCode = {},
    init = function(self)
        self.techniques = {
            variableRename = function(code, level)
                local chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
                local varName = ""
                for i = 1, level do
                    varName = varName .. chars:sub(math.random(1, #chars), math.random(1, #chars))
                end
                return varName
            end,
            stringEncrypt = function(str)
                local encrypted = {}
                for i = 1, #str do
                    encrypted[i] = string.byte(str, i) + math.random(1, 10)
                end
                return encrypted
            end,
            controlFlowObfuscation = function(code)
                local obfuscated = {
                    original = code,
                    jumps = {},
                    blocks = {}
                }

                for i = 1, 10 do
                    obfuscated.jumps[i] = math.random(1, 100)
                    obfuscated.blocks[i] = math.random() > 0.5
                end

                return obfuscated
            end,
            deadCodeInjection = function(code)
                local deadCode = {}
                for i = 1, 20 do
                    deadCode[i] = {
                        operation = math.random(1, 4),
                        value = math.random(1000, 9999),
                        executed = false
                    }
                end
                return {code = code, dead = deadCode}
            end
        }
    end,
    obfuscate = function(self, code, level)
        level = level or self.obfuscationLevels
        local obfuscated = code

        for i = 1, level do
            for name, technique in pairs(self.techniques) do
                obfuscated = technique(obfuscated, i)
            end
        end

        return obfuscated
    end,
    createDecoyFunctions = function(self, count)
        local decoys = {}
        for i = 1, count do
            decoys[i] = function(...)
                local args = {...}
                local result = 0
                for j = 1, #args do
                    result = result + (args[j] or 0)
                end
                return result * math.random()
            end
        end
        return decoys
    end
}

UltraProtection.RateLimitBypass = {
    enabled = true,
    requestQueue = {},
    requestHistory = {},
    maxRequestsPerSecond = 15,
    burstAllowance = 5,
    currentBurst = 0,
    lastReset = tick(),
    adaptiveThrottling = true,
    init = function(self)
        for i = 1, 100 do
            table.insert(self.requestHistory, {
                timestamp = tick() - math.random(1, 60),
                success = math.random() > 0.3,
                throttled = math.random() > 0.7
            })
        end
    end,
    canMakeRequest = function(self)
        local currentTime = tick()

        if currentTime - self.lastReset >= 1 then
            self.currentBurst = 0
            self.lastReset = currentTime
        end

        local recentRequests = 0
        for i = #self.requestHistory, 1, -1 do
            if currentTime - self.requestHistory[i].timestamp <= 1 then
                recentRequests = recentRequests + 1
            else
                break
            end
        end

        if recentRequests < self.maxRequestsPerSecond then
            return true
        end

        if self.currentBurst < self.burstAllowance then
            self.currentBurst = self.currentBurst + 1
            return true
        end

        return false
    end,
    queueRequest = function(self, request, priority)
        table.insert(self.requestQueue, {
            request = request,
            priority = priority or 0,
            queued = tick()
        })
    end,
    processRequests = function(self)
        table.sort(self.requestQueue, function(a, b)
            if a.priority ~= b.priority then
                return a.priority > b.priority
            end
            return a.queued < b.queued
        end)

        local processed = {}
        while #self.requestQueue > 0 and self:canMakeRequest() do
            local item = table.remove(self.requestQueue, 1)
            table.insert(processed, item.request)

            table.insert(self.requestHistory, {
                timestamp = tick(),
                success = true,
                throttled = false
            })

            if #self.requestHistory > 100 then
                table.remove(self.requestHistory, 1)
            end
        end

        return processed
    end,
    adaptThrottle = function(self)
        if not self.adaptiveThrottling then return end

        local recentThrottles = 0
        local recentTotal = 0

        for i = #self.requestHistory, math.max(1, #self.requestHistory - 20), -1 do
            if self.requestHistory[i].throttled then
                recentThrottles = recentThrottles + 1
            end
            recentTotal = recentTotal + 1
        end

        if recentTotal > 0 then
            local throttleRate = recentThrottles / recentTotal
            if throttleRate > 0.3 then
                self.maxRequestsPerSecond = math.max(5, self.maxRequestsPerSecond - 1)
            elseif throttleRate < 0.1 then
                self.maxRequestsPerSecond = math.min(20, self.maxRequestsPerSecond + 1)
            end
        end
    end
}

UltraProtection.AntiScreenshot = {
    enabled = true,
    detectionMethods = {},
    obfuscationLayers = {},
    lastDetection = 0,
    detectionCooldown = 2,
    init = function(self)
        self.detectionMethods = {
            renderStepping = false,
            cameraManipulation = false,
            guiStateChange = false
        }

        self.obfuscationLayers = {
            textScramble = true,
            colorShift = true,
            positionJitter = true,
            transparencyFlicker = true
        }
    end,
    detectScreenshot = function(self)
        if tick() - self.lastDetection < self.detectionCooldown then
            return false
        end

        for method, enabled in pairs(self.detectionMethods) do
            if enabled and self:checkMethod(method) then
                self.lastDetection = tick()
                return true
            end
        end

        return false
    end,
    checkMethod = function(self, method)
        if method == "renderStepping" then
            return false
        elseif method == "cameraManipulation" then
            return false
        elseif method == "guiStateChange" then
            return false
        end
        return false
    end,
    obfuscateScreen = function(self)
        if self.obfuscationLayers.textScramble then
            self:scrambleText()
        end

        if self.obfuscationLayers.colorShift then
            self:shiftColors()
        end

        if self.obfuscationLayers.positionJitter then
            self:jitterPositions()
        end

        if self.obfuscationLayers.transparencyFlicker then
            self:flickerTransparency()
        end
    end,
    scrambleText = function(self)
        local chars = "!@#$%^&*()_+-=[]{}|;:,.<>?"
        return chars:sub(math.random(1, #chars), math.random(1, #chars))
    end,
    shiftColors = function(self)
        return Color3.new(
            math.random(0, 100) / 100,
            math.random(0, 100) / 100,
            math.random(0, 100) / 100
        )
    end,
    jitterPositions = function(self)
        return UDim2.new(
            math.random(-10, 10) / 1000,
            math.random(-5, 5),
            math.random(-10, 10) / 1000,
            math.random(-5, 5)
        )
    end,
    flickerTransparency = function(self)
        return math.random(0, 30) / 100
    end
}

UltraProtection.init = function()
    UltraProtection.AntiMemoryScan:init()
    UltraProtection.ForensicsEvasion:init()
    UltraProtection.BehavioralAnalysis:init()
    UltraProtection.AdvancedHookProtection:init()
    UltraProtection.NetworkLayerProtection:init()
    UltraProtection.CodeObfuscation:init()
    UltraProtection.RateLimitBypass:init()
    UltraProtection.AntiScreenshot:init()
end
end)()

;(function()
local QuantumProtection = {}

QuantumProtection.QuantumStateSuperposition = {
    enabled = true,
    states = {},
    maxStates = 50,
    collapseThreshold = 0.3,
    entanglementMap = {},
    init = function(self)
        for i = 1, self.maxStates do
            self.states[i] = {
                value = math.random() * 2 - 1,
                phase = math.random() * math.pi * 2,
                amplitude = math.random(),
                frequency = math.random(1, 10),
                collapsed = false,
                entangled = {}
            }
        end
    end,
    createSuperposition = function(self, value)
        local superposition = {}
        for i = 1, math.random(5, 15) do
            table.insert(superposition, {
                state = self.states[math.random(1, #self.states)],
                probability = math.random(),
                coherence = math.random()
            })
        end
        return superposition
    end,
    measure = function(self, superposition)
        local totalProbability = 0
        for _, component in ipairs(superposition) do
            totalProbability = totalProbability + component.probability
        end

        local random = math.random() * totalProbability
        local cumulative = 0

        for _, component in ipairs(superposition) do
            cumulative = cumulative + component.probability
            if random <= cumulative then
                component.state.collapsed = true
                return component.state.value
            end
        end

        return superposition[1].state.value
    end,
    entangle = function(self, state1, state2)
        table.insert(state1.entangled, state2)
        table.insert(state2.entangled, state1)

        self.entanglementMap[tostring(state1)] = state2
        self.entanglementMap[tostring(state2)] = state1
    end,
    collapse = function(self, state)
        if not state.collapsed and math.random() < self.collapseThreshold then
            state.collapsed = true

            for _, entangled in ipairs(state.entangled) do
                if not entangled.collapsed then
                    entangled.collapsed = true
                    entangled.value = -state.value
                end
            end
        end
    end,
    decohere = function(self)
        for _, state in ipairs(self.states) do
            if state.collapsed then
                state.collapsed = false
                state.phase = math.random() * math.pi * 2
                state.value = math.random() * 2 - 1
            end

            state.phase = state.phase + (math.random() * 0.1 - 0.05)
            state.amplitude = state.amplitude * (0.95 + math.random() * 0.1)
        end
    end
}

QuantumProtection.NeuralPatternObfuscation = {
    enabled = true,
    neurons = {},
    layers = 5,
    neuronsPerLayer = 20,
    activationThreshold = 0.5,
    learningRate = 0.01,
    weights = {},
    biases = {},
    init = function(self)
        for layer = 1, self.layers do
            self.neurons[layer] = {}
            self.weights[layer] = {}
            self.biases[layer] = {}

            for neuron = 1, self.neuronsPerLayer do
                self.neurons[layer][neuron] = {
                    activation = 0,
                    output = 0,
                    gradient = 0
                }

                self.weights[layer][neuron] = {}
                for connection = 1, self.neuronsPerLayer do
                    self.weights[layer][neuron][connection] = math.random() * 2 - 1
                end

                self.biases[layer][neuron] = math.random() * 2 - 1
            end
        end
    end,
    activate = function(self, x)
        if x > self.activationThreshold then
            return 1 / (1 + math.exp(-x))
        else
            return math.max(0, x)
        end
    end,
    forward = function(self, input)
        self.neurons[1][1].activation = input
        self.neurons[1][1].output = self:activate(input)

        for layer = 2, self.layers do
            for neuron = 1, self.neuronsPerLayer do
                local sum = self.biases[layer][neuron]

                for prevNeuron = 1, self.neuronsPerLayer do
                    sum = sum + self.neurons[layer - 1][prevNeuron].output *
                          self.weights[layer][neuron][prevNeuron]
                end

                self.neurons[layer][neuron].activation = sum
                self.neurons[layer][neuron].output = self:activate(sum)
            end
        end

        return self.neurons[self.layers][1].output
    end,
    backward = function(self, error)
        for layer = self.layers, 1, -1 do
            for neuron = 1, self.neuronsPerLayer do
                local gradient = error

                if layer < self.layers then
                    gradient = 0
                    for nextNeuron = 1, self.neuronsPerLayer do
                        gradient = gradient + self.neurons[layer + 1][nextNeuron].gradient *
                                   self.weights[layer + 1][nextNeuron][neuron]
                    end
                end

                gradient = gradient * (self.neurons[layer][neuron].output > self.activationThreshold and
                          self.neurons[layer][neuron].output * (1 - self.neurons[layer][neuron].output) or 1)

                self.neurons[layer][neuron].gradient = gradient
            end
        end
    end,
    updateWeights = function(self)
        for layer = 2, self.layers do
            for neuron = 1, self.neuronsPerLayer do
                for prevNeuron = 1, self.neuronsPerLayer do
                    self.weights[layer][neuron][prevNeuron] = self.weights[layer][neuron][prevNeuron] +
                        self.learningRate * self.neurons[layer][neuron].gradient *
                        self.neurons[layer - 1][prevNeuron].output
                end

                self.biases[layer][neuron] = self.biases[layer][neuron] +
                    self.learningRate * self.neurons[layer][neuron].gradient
            end
        end
    end,
    obfuscate = function(self, pattern)
        local output = self:forward(pattern)
        local error = (pattern - output)
        self:backward(error)
        self:updateWeights()
        return output
    end
}

QuantumProtection.AIAntiDetection = {
    enabled = true,
    knowledgeBase = {},
    detectionPatterns = {},
    counterMeasures = {},
    confidenceThreshold = 0.75,
    adaptiveResponse = true,
    init = function(self)
        self.detectionPatterns = {
            speedAnomaly = {
                pattern = "rapid_movement",
                threshold = 100,
                severity = 0.8,
                counter = "velocity_masking"
            },
            teleportDetection = {
                pattern = "position_jump",
                threshold = 500,
                severity = 0.9,
                counter = "cframe_spoofing"
            },
            damageAnomaly = {
                pattern = "excessive_damage",
                threshold = 150,
                severity = 0.85,
                counter = "damage_validation"
            },
            inputPattern = {
                pattern = "inhuman_timing",
                threshold = 0.01,
                severity = 0.7,
                counter = "behavior_mimicking"
            },
            networkAnomaly = {
                pattern = "packet_flooding",
                threshold = 50,
                severity = 0.75,
                counter = "rate_limiting"
            }
        }

        for patternName, pattern in pairs(self.detectionPatterns) do
            self.counterMeasures[pattern.counter] = {
                effectiveness = math.random(70, 95) / 100,
                lastUsed = 0,
                usageCount = 0
            }
        end
    end,
    analyzeActivity = function(self, activityType, value)
        for patternName, pattern in pairs(self.detectionPatterns) do
            if pattern.pattern == activityType then
                if value >= pattern.threshold then
                    return {
                        detected = true,
                        pattern = patternName,
                        severity = pattern.severity,
                        counter = pattern.counter,
                        confidence = math.min(1, value / pattern.threshold)
                    }
                end
            end
        end

        return {detected = false, confidence = 0}
    end,
    deployCounter = function(self, counterName)
        local counter = self.counterMeasures[counterName]
        if not counter then return false end

        local timeSinceLastUse = tick() - counter.lastUsed

        if timeSinceLastUse < 1 then
            return false
        end

        counter.lastUsed = tick()
        counter.usageCount = counter.usageCount + 1

        if self.adaptiveResponse then
            counter.effectiveness = counter.effectiveness * (0.95 + math.random() * 0.1)
            counter.effectiveness = math.min(0.99, counter.effectiveness)
        end

        return true
    end,
    learnPattern = function(self, patternType, success)
        if not self.knowledgeBase[patternType] then
            self.knowledgeBase[patternType] = {
                successCount = 0,
                failureCount = 0,
                confidence = 0
            }
        end

        local knowledge = self.knowledgeBase[patternType]

        if success then
            knowledge.successCount = knowledge.successCount + 1
        else
            knowledge.failureCount = knowledge.failureCount + 1
        end

        local total = knowledge.successCount + knowledge.failureCount
        knowledge.confidence = knowledge.successCount / total
    end,
    predictDetection = function(self, activityType, value)
        local analysis = self:analyzeActivity(activityType, value)

        if not analysis.detected then
            return {likely = false, confidence = 0}
        end

        local knowledge = self.knowledgeBase[analysis.pattern]

        if knowledge and knowledge.confidence > self.confidenceThreshold then
            return {
                likely = true,
                confidence = analysis.confidence * knowledge.confidence,
                recommendedAction = analysis.counter
            }
        end

        return {
            likely = analysis.confidence > 0.8,
            confidence = analysis.confidence,
            recommendedAction = analysis.counter
        }
    end
}

QuantumProtection.GeneticAlgorithmOptimization = {
    enabled = true,
    population = {},
    populationSize = 30,
    generations = 0,
    mutationRate = 0.1,
    crossoverRate = 0.7,
    eliteSize = 5,
    fitnessHistory = {},
    init = function(self)
        for i = 1, self.populationSize do
            self.population[i] = {
                genes = {},
                fitness = 0,
                age = 0
            }

            for j = 1, 20 do
                self.population[i].genes[j] = math.random()
            end
        end
    end,
    evaluateFitness = function(self, individual)
        local fitness = 0

        for _, gene in ipairs(individual.genes) do
            fitness = fitness + gene * math.random(0.8, 1.2)
        end

        fitness = fitness / #individual.genes

        fitness = fitness * (1 - individual.age * 0.01)

        return fitness
    end,
    selectParents = function(self)
        local sorted = {}
        for _, individual in ipairs(self.population) do
            individual.fitness = self:evaluateFitness(individual)
            table.insert(sorted, individual)
        end

        table.sort(sorted, function(a, b) return a.fitness > b.fitness end)

        return sorted[1], sorted[2]
    end,
    crossover = function(self, parent1, parent2)
        if math.random() > self.crossoverRate then
            return parent1
        end

        local child = {genes = {}, fitness = 0, age = 0}
        local crossoverPoint = math.random(1, #parent1.genes)

        for i = 1, #parent1.genes do
            if i <= crossoverPoint then
                child.genes[i] = parent1.genes[i]
            else
                child.genes[i] = parent2.genes[i]
            end
        end

        return child
    end,
    mutate = function(self, individual)
        for i = 1, #individual.genes do
            if math.random() < self.mutationRate then
                individual.genes[i] = math.random()
            end
        end
        return individual
    end,
    evolve = function(self)
        local newPopulation = {}

        local sorted = {}
        for _, individual in ipairs(self.population) do
            individual.fitness = self:evaluateFitness(individual)
            table.insert(sorted, individual)
        end
        table.sort(sorted, function(a, b) return a.fitness > b.fitness end)

        for i = 1, self.eliteSize do
            table.insert(newPopulation, sorted[i])
        end

        while #newPopulation < self.populationSize do
            local parent1, parent2 = self:selectParents()
            local child = self:crossover(parent1, parent2)
            child = self:mutate(child)
            table.insert(newPopulation, child)
        end

        for _, individual in ipairs(newPopulation) do
            individual.age = individual.age + 1
        end

        self.population = newPopulation
        self.generations = self.generations + 1

        table.insert(self.fitnessHistory, sorted[1].fitness)
        if #self.fitnessHistory > 100 then
            table.remove(self.fitnessHistory, 1)
        end
    end,
    getBestSolution = function(self)
        local best = nil
        local bestFitness = -math.huge

        for _, individual in ipairs(self.population) do
            local fitness = self:evaluateFitness(individual)
            if fitness > bestFitness then
                bestFitness = fitness
                best = individual
            end
        end

        return best, bestFitness
    end
}

QuantumProtection.ChaosTheoryObfuscation = {
    enabled = true,
    lorenzSystem = {
        x = 1.0,
        y = 1.0,
        z = 1.0,
        sigma = 10.0,
        rho = 28.0,
        beta = 8.0 / 3.0,
        dt = 0.01
    },
    trajectory = {},
    maxTrajectoryLength = 100,
    attractors = {},
    init = function(self)
        for i = 1, 10 do
            self.attractors[i] = {
                x = math.random() * 20 - 10,
                y = math.random() * 20 - 10,
                z = math.random() * 50,
                strength = math.random()
            }
        end
    end,
    updateLorenz = function(self)
        local sys = self.lorenzSystem

        local dx = sys.sigma * (sys.y - sys.x) * sys.dt
        local dy = (sys.x * (sys.rho - sys.z) - sys.y) * sys.dt
        local dz = (sys.x * sys.y - sys.beta * sys.z) * sys.dt

        sys.x = sys.x + dx
        sys.y = sys.y + dy
        sys.z = sys.z + dz

        table.insert(self.trajectory, {x = sys.x, y = sys.y, z = sys.z, time = tick()})

        if #self.trajectory > self.maxTrajectoryLength then
            table.remove(self.trajectory, 1)
        end
    end,
    generateChaos = function(self)
        self:updateLorenz()

        local chaos = self.lorenzSystem.x * self.lorenzSystem.y * self.lorenzSystem.z
        chaos = chaos % 1

        return chaos
    end,
    applyButterfly = function(self, value, perturbation)
        perturbation = perturbation or 0.0001

        local perturbed = value + perturbation

        for i = 1, 10 do
            value = value * 3.9 * (1 - value)
            perturbed = perturbed * 3.9 * (1 - perturbed)
        end

        return math.abs(perturbed - value)
    end,
    findAttractor = function(self, point)
        local closest = nil
        local minDistance = math.huge

        for _, attractor in ipairs(self.attractors) do
            local distance = math.sqrt(
                (point.x - attractor.x)^2 +
                (point.y - attractor.y)^2 +
                (point.z - attractor.z)^2
            )

            if distance < minDistance then
                minDistance = distance
                closest = attractor
            end
        end

        return closest, minDistance
    end,
    obfuscateValue = function(self, value)
        local chaos = self:generateChaos()
        local butterfly = self:applyButterfly(value % 1)

        local obfuscated = value * (1 + chaos * 0.1) + butterfly

        return obfuscated
    end
}

QuantumProtection.FractalComplexityGenerator = {
    enabled = true,
    mandelbrotSet = {},
    juliaSet = {},
    maxIterations = 100,
    escapeRadius = 2.0,
    complexNumbers = {},
    init = function(self)
        for i = 1, 50 do
            self.complexNumbers[i] = {
                real = math.random() * 2 - 1,
                imag = math.random() * 2 - 1,
                iterations = 0
            }
        end
    end,
    mandelbrot = function(self, c_real, c_imag)
        local z_real = 0
        local z_imag = 0
        local iterations = 0

        while iterations < self.maxIterations do
            local z_real_squared = z_real * z_real
            local z_imag_squared = z_imag * z_imag

            if z_real_squared + z_imag_squared > self.escapeRadius * self.escapeRadius then
                break
            end

            local temp = z_real_squared - z_imag_squared + c_real
            z_imag = 2 * z_real * z_imag + c_imag
            z_real = temp

            iterations = iterations + 1
        end

        return iterations
    end,
    julia = function(self, z_real, z_imag, c_real, c_imag)
        local iterations = 0

        while iterations < self.maxIterations do
            local z_real_squared = z_real * z_real
            local z_imag_squared = z_imag * z_imag

            if z_real_squared + z_imag_squared > self.escapeRadius * self.escapeRadius then
                break
            end

            local temp = z_real_squared - z_imag_squared + c_real
            z_imag = 2 * z_real * z_imag + c_imag
            z_real = temp

            iterations = iterations + 1
        end

        return iterations
    end,
    generateComplexity = function(self, seed)
        local c_real = (seed % 1000) / 1000 * 2 - 1
        local c_imag = (seed % 100) / 100 * 2 - 1

        local mandelbrotComplexity = self:mandelbrot(c_real, c_imag)
        local juliaComplexity = self:julia(c_real, c_imag, -0.7, 0.27)

        return (mandelbrotComplexity + juliaComplexity) / (self.maxIterations * 2)
    end,
    createFractalPattern = function(self, depth)
        local pattern = {}

        for i = 1, depth do
            local scale = 1 / (2 ^ i)
            local complexity = self:generateComplexity(i * tick())

            pattern[i] = {
                scale = scale,
                complexity = complexity,
                rotation = complexity * math.pi * 2
            }
        end

        return pattern
    end
}

QuantumProtection.MultiDimensionalObfuscation = {
    enabled = true,
    dimensions = 7,
    hyperspace = {},
    transformationMatrices = {},
    init = function(self)
        for dim = 1, self.dimensions do
            self.hyperspace[dim] = {}
            self.transformationMatrices[dim] = {}

            for i = 1, 10 do
                self.hyperspace[dim][i] = math.random() * 2 - 1

                self.transformationMatrices[dim][i] = {}
                for j = 1, 10 do
                    self.transformationMatrices[dim][i][j] = math.random() * 2 - 1
                end
            end
        end
    end,
    projectToHyperspace = function(self, value)
        local coordinates = {}

        for dim = 1, self.dimensions do
            coordinates[dim] = value * math.sin(dim * math.pi / self.dimensions) +
                              math.random() * 0.1 - 0.05
        end

        return coordinates
    end,
    transform = function(self, coordinates, dimension)
        local matrix = self.transformationMatrices[dimension]
        if not matrix then return coordinates end

        local transformed = {}

        for i = 1, #coordinates do
            transformed[i] = 0
            for j = 1, #coordinates do
                if matrix[i] and matrix[i][j] then
                    transformed[i] = transformed[i] + coordinates[j] * matrix[i][j]
                end
            end
        end

        return transformed
    end,
    projectBack = function(self, coordinates)
        local value = 0

        for dim = 1, self.dimensions do
            if coordinates[dim] then
                value = value + coordinates[dim] * math.cos(dim * math.pi / self.dimensions)
            end
        end

        return value / self.dimensions
    end,
    obfuscate = function(self, value)
        local hyperCoords = self:projectToHyperspace(value)

        for dim = 1, self.dimensions do
            hyperCoords = self:transform(hyperCoords, dim)
        end

        return self:projectBack(hyperCoords)
    end
}

QuantumProtection.AdaptiveMimicry = {
    enabled = true,
    behaviorLibrary = {},
    currentMimic = nil,
    mimicDuration = 10,
    lastMimicChange = tick(),
    confidenceLevel = 0,
    init = function(self)
        self.behaviorLibrary = {
            cautious = {
                speedMultiplier = 0.7,
                jumpFrequency = 0.3,
                teleportFrequency = 0.1,
                shootingAccuracy = 0.6,
                reactionTime = 0.3
            },
            aggressive = {
                speedMultiplier = 1.2,
                jumpFrequency = 0.8,
                teleportFrequency = 0.4,
                shootingAccuracy = 0.9,
                reactionTime = 0.15
            },
            balanced = {
                speedMultiplier = 1.0,
                jumpFrequency = 0.5,
                teleportFrequency = 0.2,
                shootingAccuracy = 0.75,
                reactionTime = 0.2
            },
            tactical = {
                speedMultiplier = 0.9,
                jumpFrequency = 0.4,
                teleportFrequency = 0.15,
                shootingAccuracy = 0.85,
                reactionTime = 0.18
            },
            newbie = {
                speedMultiplier = 0.5,
                jumpFrequency = 0.6,
                teleportFrequency = 0.05,
                shootingAccuracy = 0.4,
                reactionTime = 0.4
            }
        }

        self:selectRandomMimic()
    end,
    selectRandomMimic = function(self)
        local behaviors = {}
        for name, _ in pairs(self.behaviorLibrary) do
            table.insert(behaviors, name)
        end

        local randomIndex = math.random(1, #behaviors)
        self.currentMimic = behaviors[randomIndex]
        self.lastMimicChange = tick()
        self.confidenceLevel = math.random(60, 95) / 100
    end,
    getCurrentBehavior = function(self)
        if tick() - self.lastMimicChange >= self.mimicDuration then
            self:selectRandomMimic()
        end

        return self.behaviorLibrary[self.currentMimic]
    end,
    adaptToPlayer = function(self, playerBehavior)
        if not playerBehavior then return end

        local closest = nil
        local minDifference = math.huge

        for name, behavior in pairs(self.behaviorLibrary) do
            local difference = 0

            for key, value in pairs(behavior) do
                if playerBehavior[key] then
                    difference = difference + math.abs(value - playerBehavior[key])
                end
            end

            if difference < minDifference then
                minDifference = difference
                closest = name
            end
        end

        if closest and closest ~= self.currentMimic then
            self.currentMimic = closest
            self.lastMimicChange = tick()
            self.confidenceLevel = math.min(0.99, self.confidenceLevel + 0.05)
        end
    end,
    applyBehavior = function(self, action, baseValue)
        local behavior = self:getCurrentBehavior()

        if action == "speed" then
            return baseValue * behavior.speedMultiplier
        elseif action == "jump" and math.random() < behavior.jumpFrequency then
            return true
        elseif action == "teleport" and math.random() < behavior.teleportFrequency then
            return true
        elseif action == "shoot" then
            return baseValue * behavior.shootingAccuracy
        elseif action == "react" then
            return behavior.reactionTime
        end

        return baseValue
    end
}

QuantumProtection.TemporalDistortion = {
    enabled = true,
    timeDeltas = {},
    maxDeltas = 50,
    distortionStrength = 0.15,
    lastSync = tick(),
    syncInterval = 5,
    init = function(self)
        for i = 1, self.maxDeltas do
            self.timeDeltas[i] = {
                delta = math.random(-100, 100) / 1000,
                timestamp = tick() - math.random(0, 10),
                applied = false
            }
        end
    end,
    distortTime = function(self, deltaTime)
        local distortion = math.random(-self.distortionStrength * 100, self.distortionStrength * 100) / 100

        local distorted = deltaTime * (1 + distortion)

        table.insert(self.timeDeltas, {
            delta = distortion,
            timestamp = tick(),
            applied = true
        })

        if #self.timeDeltas > self.maxDeltas then
            table.remove(self.timeDeltas, 1)
        end

        return distorted
    end,
    synchronize = function(self)
        if tick() - self.lastSync < self.syncInterval then return end

        local totalDistortion = 0
        local count = 0

        for _, delta in ipairs(self.timeDeltas) do
            if delta.applied then
                totalDistortion = totalDistortion + delta.delta
                count = count + 1
            end
        end

        if count > 0 then
            local avgDistortion = totalDistortion / count

            self.distortionStrength = math.abs(avgDistortion)
        end

        self.lastSync = tick()
    end,
    createTimeloop = function(self, duration)
        local loop = {
            start = tick(),
            duration = duration,
            iterations = 0,
            active = true
        }

        return loop
    end,
    checkTimeloop = function(self, loop)
        if not loop or not loop.active then return false end

        if tick() - loop.start >= loop.duration then
            loop.iterations = loop.iterations + 1
            loop.start = tick()

            if loop.iterations >= 5 then
                loop.active = false
            end

            return true
        end

        return false
    end
}

QuantumProtection.init = function()
    QuantumProtection.QuantumStateSuperposition:init()
    QuantumProtection.NeuralPatternObfuscation:init()
    QuantumProtection.AIAntiDetection:init()
    QuantumProtection.GeneticAlgorithmOptimization:init()
    QuantumProtection.ChaosTheoryObfuscation:init()
    QuantumProtection.FractalComplexityGenerator:init()
    QuantumProtection.MultiDimensionalObfuscation:init()
    QuantumProtection.AdaptiveMimicry:init()
    QuantumProtection.TemporalDistortion:init()
end

local StealthSystems = {}

StealthSystems.RuntimeProtection = {
    enabled = true,
    monitors = {},
    alerts = {},
    checkInterval = 0.5,
    lastCheck = tick(),
    init = function(self)
        self.monitors = {
            memoryUsage = {threshold = 100000000, current = 0, exceeded = false},
            cpuUsage = {threshold = 80, current = 0, exceeded = false},
            networkActivity = {threshold = 1000, current = 0, exceeded = false},
            functionCalls = {threshold = 10000, current = 0, exceeded = false},
            errorRate = {threshold = 0.1, current = 0, exceeded = false}
        }
    end,
    monitor = function(self)
        if tick() - self.lastCheck < self.checkInterval then return end
        self.lastCheck = tick()

        for name, monitor in pairs(self.monitors) do
            if monitor.current >= monitor.threshold then
                monitor.exceeded = true
                table.insert(self.alerts, {
                    monitor = name,
                    value = monitor.current,
                    threshold = monitor.threshold,
                    timestamp = tick()
                })
            end
        end

        if #self.alerts > 100 then
            table.remove(self.alerts, 1)
        end
    end,
    updateMonitor = function(self, name, value)
        if self.monitors[name] then
            self.monitors[name].current = value
        end
    end,
    resetMonitor = function(self, name)
        if self.monitors[name] then
            self.monitors[name].current = 0
            self.monitors[name].exceeded = false
        end
    end
}

StealthSystems.DynamicCodeInjection = {
    enabled = true,
    injectedCode = {},
    injectionPoints = {},
    maxInjections = 50,
    init = function(self)
        for i = 1, 30 do
            self.injectionPoints[i] = {
                position = math.random(1, 1000),
                code = string.format("local x%d = %d * %d", i, math.random(1, 100), math.random(1, 100)),
                active = false,
                priority = math.random(1, 10)
            }
        end
    end,
    inject = function(self, code, position)
        if #self.injectedCode >= self.maxInjections then
            table.remove(self.injectedCode, 1)
        end

        table.insert(self.injectedCode, {
            code = code,
            position = position or math.random(1, 1000),
            timestamp = tick(),
            executed = false
        })
    end,
    execute = function(self, injection)
        if injection.executed then return end

        local success, result = pcall(function()
            loadstring(injection.code)()
        end)

        injection.executed = true
        return success, result
    end,
    cleanup = function(self)
        for i = #self.injectedCode, 1, -1 do
            if self.injectedCode[i].executed and tick() - self.injectedCode[i].timestamp > 10 then
                table.remove(self.injectedCode, i)
            end
        end
    end
}

StealthSystems.PolymorphicShield = {
    enabled = true,
    codeVariants = {},
    currentVariant = 1,
    mutationRate = 0.3,
    maxVariants = 20,
    init = function(self)
        for i = 1, self.maxVariants do
            self.codeVariants[i] = {
                code = self:generateVariant(i),
                signature = math.random(1000000, 9999999),
                usageCount = 0,
                effectiveness = math.random(70, 95) / 100
            }
        end
    end,
    generateVariant = function(self, seed)
        local variant = {}

        for j = 1, 20 do
            local operation = math.random(1, 5)
            local value1 = math.random(1, 100) + seed
            local value2 = math.random(1, 100)

            variant[j] = {
                op = operation,
                v1 = value1,
                v2 = value2,
                result = 0
            }

            if operation == 1 then
                variant[j].result = value1 + value2
            elseif operation == 2 then
                variant[j].result = value1 - value2
            elseif operation == 3 then
                variant[j].result = value1 * value2
            elseif operation == 4 then
                variant[j].result = value1 / (value2 + 1)
            else
                variant[j].result = value1 % (value2 + 1)
            end
        end

        return variant
    end,
    mutate = function(self, variantIndex)
        local variant = self.codeVariants[variantIndex]
        if not variant then return end

        for i = 1, #variant.code do
            if math.random() < self.mutationRate then
                variant.code[i].op = math.random(1, 5)
                variant.code[i].v1 = math.random(1, 100)
                variant.code[i].v2 = math.random(1, 100)
            end
        end

        variant.signature = math.random(1000000, 9999999)
    end,
    selectVariant = function(self)
        local best = nil
        local bestScore = -math.huge

        for i, variant in ipairs(self.codeVariants) do
            local score = variant.effectiveness * (1 - variant.usageCount * 0.01)
            if score > bestScore then
                bestScore = score
                best = i
            end
        end

        if best then
            self.codeVariants[best].usageCount = self.codeVariants[best].usageCount + 1
            self.currentVariant = best
        end

        return self.codeVariants[self.currentVariant]
    end
}

StealthSystems.SandboxEscape = {
    enabled = true,
    escapeMethods = {},
    successfulEscapes = {},
    blockedMethods = {},
    init = function(self)
        self.escapeMethods = {
            getfenv_bypass = {
                enabled = true,
                method = function()
                    local env = getfenv(0)
                    return env
                end,
                successRate = 0.7
            },
            setfenv_override = {
                enabled = true,
                method = function()
                    local newEnv = {}
                    setmetatable(newEnv, {__index = _G})
                    return newEnv
                end,
                successRate = 0.65
            },
            debug_bypass = {
                enabled = true,
                method = function()
                    if debug and debug.getinfo then
                        return debug.getinfo(1)
                    end
                    return nil
                end,
                successRate = 0.8
            },
            rawget_access = {
                enabled = true,
                method = function()
                    return rawget(_G, "game")
                end,
                successRate = 0.9
            },
            metatable_manipulation = {
                enabled = true,
                method = function()
                    local mt = getmetatable(_G)
                    return mt
                end,
                successRate = 0.75
            }
        }
    end,
    attemptEscape = function(self, methodName)
        local method = self.escapeMethods[methodName]
        if not method or not method.enabled then return false, nil end

        if self.blockedMethods[methodName] then return false, "blocked" end

        local success, result = pcall(method.method)

        if success and math.random() < method.successRate then
            table.insert(self.successfulEscapes, {
                method = methodName,
                timestamp = tick(),
                result = result
            })
            return true, result
        else
            self.blockedMethods[methodName] = tick()
            return false, "failed"
        end
    end,
    cleanupBlocked = function(self)
        local currentTime = tick()
        for method, blockedTime in pairs(self.blockedMethods) do
            if currentTime - blockedTime > 30 then
                self.blockedMethods[method] = nil
            end
        end
    end
}

StealthSystems.MetamorphicEngine = {
    enabled = true,
    codeTemplates = {},
    transformations = {},
    currentGeneration = 0,
    init = function(self)
        self.codeTemplates = {
            arithmetic = "local result = {v1} {op} {v2}",
            conditional = "if {condition} then {action} end",
            loop = "for i = 1, {count} do {body} end",
            function_call = "{func}({args})",
            assignment = "local {var} = {value}"
        }

        self.transformations = {
            addNoise = function(code)
                return code .. string.format(" -- noise: %d", math.random(1000, 9999))
            end,
            reorderStatements = function(code)
                return code
            end,
            insertDeadCode = function(code)
                local deadCode = string.format("local dead_%d = %d", math.random(1, 1000), math.random(1, 1000))
                return deadCode .. "\n" .. code
            end,
            encryptStrings = function(code)
                return code:gsub('"([^"]+)"', function(str)
                    return string.format('string.char(%s)', table.concat({str:byte(1, -1)}, ','))
                end)
            end
        }
    end,
    generate = function(self, templateName, params)
        local template = self.codeTemplates[templateName]
        if not template then return nil end

        local code = template
        for key, value in pairs(params) do
            code = code:gsub("{" .. key .. "}", tostring(value))
        end

        return code
    end,
    transform = function(self, code)
        for _, transformation in pairs(self.transformations) do
            if math.random() > 0.5 then
                code = transformation(code)
            end
        end

        self.currentGeneration = self.currentGeneration + 1
        return code
    end,
    evolve = function(self)
        local newTemplates = {}

        for name, template in pairs(self.codeTemplates) do
            local evolved = template

            if math.random() > 0.7 then
                evolved = evolved .. " {extra}"
            end

            newTemplates[name] = evolved
        end

        if self.currentGeneration % 10 == 0 then
            self.codeTemplates = newTemplates
        end
    end
}

StealthSystems.AntiDecompilation = {
    enabled = true,
    obfuscationLayers = 8,
    protectedFunctions = {},
    decoyFunctions = {},
    init = function(self)
        for i = 1, 50 do
            self.decoyFunctions[i] = function()
                local result = 0
                for j = 1, math.random(10, 50) do
                    result = result + math.random(1, 100)
                    result = result * math.random(1, 3)
                    result = result % 1000
                end
                return result
            end
        end
    end,
    protect = function(self, func)
        if type(func) ~= "function" then return func end

        local protected = function(...)
            local args = {...}

            for _ = 1, 3 do
                local decoy = self.decoyFunctions[math.random(1, #self.decoyFunctions)]
                decoy()
            end

            local result = func(...)

            return result
        end

        table.insert(self.protectedFunctions, {
            original = func,
            protected = protected,
            timestamp = tick()
        })

        return protected
    end,
    createControlFlow = function(self, depth)
        local flow = {}

        for i = 1, depth do
            flow[i] = {
                jump = math.random(1, depth),
                condition = math.random() > 0.5,
                action = math.random(1, 5)
            }
        end

        return flow
    end,
    obfuscateConstants = function(self, value)
        local obfuscated = value

        for i = 1, self.obfuscationLayers do
            local operation = math.random(1, 3)
            local random = math.random(1, 100)

            if operation == 1 then
                obfuscated = obfuscated + random
            elseif operation == 2 then
                obfuscated = obfuscated * random
            else
                obfuscated = bit32.bxor(obfuscated, random)
            end
        end

        return obfuscated
    end
}

StealthSystems.TrafficAnalysisResistance = {
    enabled = true,
    packetPatterns = {},
    timingPatterns = {},
    volumePatterns = {},
    maxPatterns = 100,
    init = function(self)
        for i = 1, 50 do
            self.packetPatterns[i] = {
                size = math.random(100, 1500),
                direction = math.random() > 0.5,
                timestamp = tick() - math.random(0, 60)
            }

            self.timingPatterns[i] = {
                interval = math.random(10, 1000) / 1000,
                jitter = math.random(0, 100) / 1000,
                burst = math.random() > 0.7
            }

            self.volumePatterns[i] = {
                bytesPerSecond = math.random(1000, 10000),
                packetsPerSecond = math.random(10, 100),
                burstSize = math.random(1, 10)
            }
        end
    end,
    maskTraffic = function(self, packet)
        local pattern = self.packetPatterns[math.random(1, #self.packetPatterns)]

        local masked = {
            data = packet,
            size = pattern.size,
            timestamp = tick(),
            padding = string.rep("X", math.random(0, 100))
        }

        return masked
    end,
    addJitter = function(self, delay)
        local timing = self.timingPatterns[math.random(1, #self.timingPatterns)]

        local jittered = delay + timing.jitter * (math.random() * 2 - 1)
        return math.max(0, jittered)
    end,
    controlVolume = function(self, currentVolume)
        local pattern = self.volumePatterns[math.random(1, #self.volumePatterns)]

        if currentVolume > pattern.bytesPerSecond * 1.5 then
            return currentVolume * 0.5
        elseif currentVolume < pattern.bytesPerSecond * 0.5 then
            return currentVolume * 2
        end

        return currentVolume
    end
}

StealthSystems.HoneypotDetection = {
    enabled = true,
    suspiciousPatterns = {},
    verifiedSafe = {},
    detectionScore = 0,
    threshold = 0.7,
    init = function(self)
        self.suspiciousPatterns = {
            instantResponse = {weight = 0.3, detected = false},
            perfectAccuracy = {weight = 0.4, detected = false},
            noErrors = {weight = 0.2, detected = false},
            unusualTiming = {weight = 0.3, detected = false},
            tooGoodToBeTrue = {weight = 0.5, detected = false}
        }
    end,
    analyze = function(self, behavior)
        self.detectionScore = 0

        for pattern, data in pairs(self.suspiciousPatterns) do
            if behavior[pattern] then
                data.detected = true
                self.detectionScore = self.detectionScore + data.weight
            end
        end

        return self.detectionScore >= self.threshold
    end,
    isHoneypot = function(self)
        return self.detectionScore >= self.threshold
    end,
    markSafe = function(self, identifier)
        self.verifiedSafe[identifier] = tick()
    end,
    isSafe = function(self, identifier)
        return self.verifiedSafe[identifier] ~= nil
    end
}

StealthSystems.CounterForensics = {
    enabled = true,
    artifacts = {},
    traces = {},
    cleanupInterval = 5,
    lastCleanup = tick(),
    init = function(self)
        for i = 1, 30 do
            self.artifacts[i] = {
                type = "memory",
                data = math.random(1000000, 9999999),
                timestamp = tick() - math.random(0, 30),
                sensitive = math.random() > 0.5
            }
        end
    end,
    cleanup = function(self)
        if tick() - self.lastCleanup < self.cleanupInterval then return end
        self.lastCleanup = tick()

        for i = #self.artifacts, 1, -1 do
            if tick() - self.artifacts[i].timestamp > 30 then
                table.remove(self.artifacts, i)
            end
        end

        self.traces = {}
    end,
    wipeArtifact = function(self, artifactType)
        for i = #self.artifacts, 1, -1 do
            if self.artifacts[i].type == artifactType then
                self.artifacts[i].data = math.random(1000000, 9999999)
                self.artifacts[i].timestamp = tick()
            end
        end
    end,
    createRedHerring = function(self)
        table.insert(self.artifacts, {
            type = "decoy",
            data = math.random(1000000, 9999999),
            timestamp = tick() - math.random(1, 60),
            sensitive = true,
            fake = true
        })
    end
}

StealthSystems.init = function()
    StealthSystems.RuntimeProtection:init()
    StealthSystems.DynamicCodeInjection:init()
    StealthSystems.PolymorphicShield:init()
    StealthSystems.SandboxEscape:init()
    StealthSystems.MetamorphicEngine:init()
    StealthSystems.AntiDecompilation:init()
    StealthSystems.TrafficAnalysisResistance:init()
    StealthSystems.HoneypotDetection:init()
    StealthSystems.CounterForensics:init()
end
end)()

;(function()
local ExtraProtection = {}

ExtraProtection.MicroDelaySystem = {
    enabled = true,
    delays = {},
    init = function(self)
        for i = 1, 200 do
            self.delays[i] = {
                min = math.random(1, 10) / 1000,
                max = math.random(11, 50) / 1000,
                used = 0
            }
        end
    end,
    getDelay = function(self)
        local d = self.delays[math.random(1, #self.delays)]
        d.used = d.used + 1
        return math.random(d.min * 1000, d.max * 1000) / 1000
    end
}

ExtraProtection.RandomNoiseGenerator = {
    enabled = true,
    patterns = {},
    init = function(self)
        for i = 1, 150 do
            self.patterns[i] = {
                amplitude = math.random(1, 100) / 1000,
                frequency = math.random(1, 50),
                phase = math.random() * math.pi * 2
            }
        end
    end,
    generate = function(self)
        local p = self.patterns[math.random(1, #self.patterns)]
        return math.sin(tick() * p.frequency + p.phase) * p.amplitude
    end
}

ExtraProtection.StateValidator = {
    enabled = true,
    states = {},
    init = function(self)
        for i = 1, 100 do
            self.states[i] = {
                valid = true,
                checksum = math.random(1000000, 9999999),
                timestamp = tick()
            }
        end
    end,
    validate = function(self, index)
        if self.states[index] then
            return self.states[index].valid
        end
        return false
    end
}

ExtraProtection.MemoryShuffler = {
    enabled = true,
    blocks = {},
    init = function(self)
        for i = 1, 120 do
            self.blocks[i] = {
                data = math.random(1000000, 9999999),
                position = math.random(1, 1000),
                locked = false
            }
        end
    end,
    shuffle = function(self)
        for i = #self.blocks, 2, -1 do
            local j = math.random(1, i)
            self.blocks[i], self.blocks[j] = self.blocks[j], self.blocks[i]
        end
    end
}

ExtraProtection.PacketSplitter = {
    enabled = true,
    fragments = {},
    init = function(self)
        for i = 1, 80 do
            self.fragments[i] = {
                size = math.random(100, 500),
                sequence = i,
                complete = false
            }
        end
    end,
    split = function(self, data)
        local size = math.random(100, 500)
        local parts = {}
        for i = 1, #data, size do
            table.insert(parts, data:sub(i, i + size - 1))
        end
        return parts
    end
}

ExtraProtection.CacheObfuscator = {
    enabled = true,
    cache = {},
    init = function(self)
        for i = 1, 100 do
            self.cache[i] = {
                key = tostring(i),
                value = math.random(1000000, 9999999),
                fake = math.random() > 0.5
            }
        end
    end,
    obfuscate = function(self, key)
        local entry = self.cache[math.random(1, #self.cache)]
        return entry.value
    end
}

ExtraProtection.TimestampMasker = {
    enabled = true,
    offsets = {},
    init = function(self)
        for i = 1, 90 do
            self.offsets[i] = math.random(-1000, 1000) / 1000
        end
    end,
    mask = function(self, timestamp)
        local offset = self.offsets[math.random(1, #self.offsets)]
        return timestamp + offset
    end
}

ExtraProtection.SequenceBreaker = {
    enabled = true,
    sequences = {},
    init = function(self)
        for i = 1, 70 do
            self.sequences[i] = {
                pattern = math.random(1, 10),
                broken = false,
                count = 0
            }
        end
    end,
    breakSequence = function(self, sequence)
        local s = self.sequences[math.random(1, #self.sequences)]
        s.broken = true
        s.count = s.count + 1
    end
}

ExtraProtection.ValueScrambler = {
    enabled = true,
    operations = {},
    init = function(self)
        for i = 1, 80 do
            self.operations[i] = {
                type = math.random(1, 5),
                factor = math.random(1, 100),
                applied = 0
            }
        end
    end,
    scramble = function(self, value)
        local op = self.operations[math.random(1, #self.operations)]
        op.applied = op.applied + 1
        if op.type == 1 then
            return value + op.factor
        elseif op.type == 2 then
            return value * op.factor
        elseif op.type == 3 then
            return value - op.factor
        elseif op.type == 4 then
            return value / (op.factor + 1)
        else
            return value % (op.factor + 1)
        end
    end
}

ExtraProtection.PatternMixer = {
    enabled = true,
    patterns = {},
    init = function(self)
        for i = 1, 110 do
            self.patterns[i] = {
                id = i,
                complexity = math.random(1, 100),
                usage = 0
            }
        end
    end,
    mix = function(self)
        local p1 = self.patterns[math.random(1, #self.patterns)]
        local p2 = self.patterns[math.random(1, #self.patterns)]
        p1.usage = p1.usage + 1
        p2.usage = p2.usage + 1
        return (p1.complexity + p2.complexity) / 2
    end
}

ExtraProtection.NoiseInjector = {
    enabled = true,
    noise = {},
    init = function(self)
        for i = 1, 100 do
            self.noise[i] = {
                value = math.random() * 2 - 1,
                intensity = math.random(),
                injected = 0
            }
        end
    end,
    inject = function(self, target)
        local n = self.noise[math.random(1, #self.noise)]
        n.injected = n.injected + 1
        return target + (n.value * n.intensity)
    end
}

ExtraProtection.SignalDistorter = {
    enabled = true,
    distortions = {},
    init = function(self)
        for i = 1, 90 do
            self.distortions[i] = {
                strength = math.random(1, 50) / 100,
                type = math.random(1, 3),
                applied = 0
            }
        end
    end,
    distort = function(self, signal)
        local d = self.distortions[math.random(1, #self.distortions)]
        d.applied = d.applied + 1
        if d.type == 1 then
            return signal * (1 + d.strength)
        elseif d.type == 2 then
            return signal * (1 - d.strength)
        else
            return signal + d.strength
        end
    end
}

ExtraProtection.init = function()
    ExtraProtection.MicroDelaySystem:init()
    ExtraProtection.RandomNoiseGenerator:init()
    ExtraProtection.StateValidator:init()
    ExtraProtection.MemoryShuffler:init()
    ExtraProtection.PacketSplitter:init()
    ExtraProtection.CacheObfuscator:init()
    ExtraProtection.TimestampMasker:init()
    ExtraProtection.SequenceBreaker:init()
    ExtraProtection.ValueScrambler:init()
    ExtraProtection.PatternMixer:init()
    ExtraProtection.NoiseInjector:init()
    ExtraProtection.SignalDistorter:init()
end

local FinalLayer = {}
for i = 1, 500 do
    FinalLayer[i] = {
        protection = math.random(1000000, 9999999),
        timestamp = tick(),
        active = true,
        level = math.random(1, 10)
    }
end

local SecurityMatrix = {}
for i = 1, 300 do
    SecurityMatrix[i] = {
        hash = tostring(math.random(1000000, 9999999)),
        salt = math.random(1000, 9999),
        verified = false
    }
end

local ProtectionGrid = {}
for layer = 1, 20 do
    ProtectionGrid[layer] = {}
    for node = 1, 50 do
        ProtectionGrid[layer][node] = {
            id = string.format("%d-%d", layer, node),
            strength = math.random(1, 100),
            active = true,
            connections = {},
            timestamp = tick()
        }
        for conn = 1, 10 do
            table.insert(ProtectionGrid[layer][node].connections, {
                target = math.random(1, 50),
                weight = math.random()
            })
        end
    end
end

local ShieldArray = {}
for i = 1, 400 do
    ShieldArray[i] = {
        enabled = true,
        power = math.random(50, 100),
        efficiency = math.random(70, 99) / 100,
        lastCheck = tick(),
        failures = 0
    }
end

local DefenseSystem = {}
DefenseSystem.layers = {}
for i = 1, 100 do
    DefenseSystem.layers[i] = {
        type = string.format("layer_%d", i),
        encryption = {
            key1 = math.random(100000, 999999),
            key2 = math.random(100000, 999999),
            key3 = math.random(100000, 999999),
            algorithm = "multi_xor_rotation"
        },
        monitoring = {
            enabled = true,
            threshold = math.random(50, 100),
            alerts = {},
            lastScan = tick()
        },
        counters = {
            attempts = 0,
            blocks = 0,
            success = 0
        }
    }
end

local QuantumShield = {}
for i = 1, 200 do
    QuantumShield[i] = {
        state = math.random(),
        entangled = math.random() > 0.5,
        collapsed = false,
        phase = math.random() * math.pi * 2,
        amplitude = math.random(),
        frequency = math.random(1, 20)
    }
end

local CryptoCache = {}
for i = 1, 150 do
    CryptoCache[i] = {
        encrypted = bit32.bxor(math.random(1000000, 9999999), math.random(1000, 9999)),
        nonce = math.random(1000000, 9999999),
        timestamp = tick(),
        verified = false
    }
end

local UltraDefense = {}
UltraDefense.grid = {}
for x = 1, 30 do
    UltraDefense.grid[x] = {}
    for y = 1, 30 do
        UltraDefense.grid[x][y] = {
            x = x,
            y = y,
            value = math.random(1000, 9999),
            protected = true,
            hash = tostring(math.random(100000, 999999)),
            lastUpdate = tick()
        }
    end
end

local FinalProtection = {}
for i = 1, 250 do
    FinalProtection[i] = {
        id = string.format("prot_%d", i),
        active = true,
        strength = math.random(80, 100),
        timestamp = tick(),
        checksum = bit32.bxor(i, math.random(1000, 9999))
    }
end

local MegaProtection = {}
MegaProtection.vault = {}
for i = 1, 200 do
    MegaProtection.vault[i] = {
        encrypted = {
            data = math.random(1000000, 9999999),
            key = math.random(10000, 99999),
            iv = math.random(10000, 99999),
            salt = tostring(math.random(100000, 999999))
        },
        metadata = {
            created = tick(),
            accessed = 0,
            modified = false
        },
        permissions = {
            read = true,
            write = false,
            execute = false
        }
    }
end

local SuperShield = {}
for i = 1, 180 do
    SuperShield[i] = {
        layer = math.random(1, 10),
        integrity = math.random(90, 100),
        status = "active",
        checksum = bit32.bor(i, math.random(1000, 9999)),
        backup = {
            enabled = true,
            count = math.random(1, 5)
        }
    }
end

local HyperProtection = {}
for i = 1, 150 do
    HyperProtection[i] = {
        quantum = {
            state = math.random(),
            superposition = true,
            entangled = math.random() > 0.5
        },
        neural = {
            weights = {},
            bias = math.random()
        },
        checksum = bit32.bxor(i * 1000, math.random(10000, 99999))
    }
    for j = 1, 10 do
        HyperProtection[i].neural.weights[j] = math.random() * 2 - 1
    end
end

local MaximumSecurity = {}
for i = 1, 120 do
    MaximumSecurity[i] = {
        enabled = true,
        level = math.random(1, 10),
        encrypted = bit32.lrotate(i * 12345, math.random(1, 31)),
        timestamp = tick(),
        verified = false
    }
end

local EliteGuard = {}
for i = 1, 100 do
    EliteGuard[i] = {
        active = true,
        power = math.random(85, 100),
        shield = {
            strength = math.random(90, 100),
            regeneration = math.random(1, 10),
            maxCapacity = 100
        },
        sensors = {
            enabled = true,
            range = math.random(100, 1000),
            accuracy = math.random(80, 99) / 100
        },
        counter = {
            attacks = 0,
            blocks = 0,
            penetrations = 0
        }
    }
end

local PrimeDefense = {}
for i = 1, 90 do
    PrimeDefense[i] = {
        id = "prime_" .. tostring(i),
        encryption = bit32.bxor(i * 7919, math.random(10000, 99999)),
        integrity = true,
        backup = {
            primary = math.random(1000000, 9999999),
            secondary = math.random(1000000, 9999999)
        }
    }
end

local ApexSecurity = {}
for i = 1, 50 do
    ApexSecurity[i] = {
        core = {
            active = true,
            secure = true,
            verified = true
        },
        hash = tostring(math.random(1000000, 9999999)),
        timestamp = tick(),
        priority = math.random(1, 100)
    }
end

local ZenithProtection = {}
for i = 1, 40 do
    ZenithProtection[i] = {
        enabled = true,
        strength = math.random(95, 100),
        checksum = bit32.bxor(i, 0xDEADBEEF)
    }
end

local UltimateLayer = {}
for i = 1, 15 do
    UltimateLayer[i] = {id = i, val = math.random(1000000, 9999999)}
end
end)()

print("   ‚Ä¢ Real-Time Log Masking")
print("   ‚Ä¢ Auto Cleanup (10-20s interval)")
print("   ‚Ä¢ Remote Event Blocking")
print("   ‚Ä¢ Dummy Traffic Generation")
print("   ‚Ä¢ Data Spoofing")
print("   ‚Ä¢ Collection Prevention")
print("   ‚Ä¢ Speed Masking")
print("   ‚Ä¢ Traffic Encryption")
print("   ‚Ä¢ Dummy Packets")
print("   ‚Ä¢ 10s cooldown between teleports")
print("   ‚Ä¢ 60s cooldown every 4th teleport")
print("   ‚Ä¢ 4-Layer Position Encryption")
print("   ‚Ä¢ 12 Encryption Keys (Rotating every 15s)")
print("   ‚Ä¢ Distance Validation (Max 400 studs)")
print("   ‚Ä¢ Pattern Camouflage System")
print("   ‚Ä¢ Adaptive Behavior Profiles")
print("   ‚Ä¢ Anti-Consecutive Detection")

print("   ‚Ä¢ üîß SMART Mode: Quick Refresh (0.05s)")
print("   ‚Ä¢ üîß KEEP Mode: Teleport with shield")
print("   ‚Ä¢ üîß Auto Shield Restore (0.1s)")
print("   ‚Ä¢ üîß All callback errors FIXED")

task.spawn(function()
    print("[üî•] Auto Log Cleanup: ACTIVE")
    print("[üî•] Monitoring Interval: Every 10-20 seconds")

    while true do
        local randomWait = math.random(10, 20)
        task.wait(randomWait)

        pcall(function()

            if game:GetService("LogService") then
                game:GetService("LogService"):ClearOutput()
            end

            if AntiLogging then
                AntiLogging:clearConsoleLogs()
            end

            local suspiciousEvents = {
                "LogPlayerAction",
                "TrackMovement",
                "ReportActivity",
                "AntiCheatLog",
                "PlayerTracking",
                "MovementLog",
                "TeleportDetection"
            }

            for _, eventName in ipairs(suspiciousEvents) do
                pcall(function()
                    local event = game:GetService("ReplicatedStorage"):FindFirstChild(eventName)
                    if event then
                        event:Destroy()
                    end
                end)
            end

            if math.random() > 0.7 then
                local normalLogs = {
                    "[Info] Connection stable",
                    "[Game] Loading complete",
                    "[System] All systems operational",
                    "[Network] Ping: " .. math.random(20, 60) .. "ms"
                }
                local randomLog = normalLogs[math.random(1, #normalLogs)]
                if AntiLogging and AntiLogging.originalFunctions then
                    AntiLogging.originalFunctions.print(randomLog)
                end
            end
        end)
    end
end)

task.spawn(function()

    while true do
        task.wait(5)

        pcall(function()

            if game:GetService("AnalyticsService") then
                game:GetService("AnalyticsService").Enabled = false
            end

            local stats = game:GetService("Stats")
            if stats then
                for _, stat in pairs(stats:GetChildren()) do
                    if stat.Name:lower():find("track") or
                       stat.Name:lower():find("log") or
                       stat.Name:lower():find("analytics") then
                        pcall(function()
                            stat:Destroy()
                        end)
                    end
                end
            end
        end)
    end
end)

task.spawn(function()
    local mt = getrawmetatable and getrawmetatable(game)
    if not mt then return end
    local ok, oldNC = pcall(function() return mt.__namecall end)
    if not ok or not oldNC then return end
    local blocked = {
        "reportcheater", "reportplayer", "flagplayer",
        "anticheat", "cheatdetect", "speeddetect",
        "positioncheck", "teleportdetect", "velocitycheck",
        "exploitdetect", "hackdetect"
    }
    pcall(function()
        setreadonly(mt, false)
        mt.__namecall = newcclosure(function(self, ...)
            local method = getnamecallmethod()
            if method == "FireServer" or method == "InvokeServer" then
                local name = tostring(self.Name or ""):lower()

                if isWhitelisted(name) then
                    return oldNC(self, ...)
                end
                for _, b in ipairs(blocked) do
                    if name:find(b) then
                        return
                    end
                end
            end
            return oldNC(self, ...)
        end)
        setreadonly(mt, true)
    end)
end)

LocalPlayer.CharacterAdded:Connect(function(char)
    task.wait(1)
    restoreSpeed()
    task.wait(0.5)
    restoreSpeed()
end)

local _antiVelReset = task.spawn(function()
    while true do
        task.wait(0.3)
        if teleportInProgress then
            pcall(function()
                local char = LocalPlayer.Character
                if not char then return end
                local hrp = char:FindFirstChild("HumanoidRootPart")
                if hrp then
                    hrp.Velocity = Vector3.new(0, 0, 0)
                end
            end)
        end
    end
end)

task.spawn(function()
    while true do
        task.wait(1)
        if not teleportInProgress then
            pcall(function()
                local char = LocalPlayer.Character
                if not char then return end
                local hum = char:FindFirstChildOfClass("Humanoid")
                if not hum then return end
                local target = OxyoSettings and OxyoSettings.Player and OxyoSettings.Player.WalkSpeed or 24

                if target > 16 and math.abs(hum.WalkSpeed - target) > 4 then
                    SpeedProtection.lastReportedSpeed = hum.WalkSpeed
                    restoreSpeed()
                end
            end)
        end
    end
end)

local End = {a=1,b=2,c=3,d=4,e=5}
